<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>shell命令</title>
    <url>/2020/04/18/shell%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>文件、目录操作命令<br>1、ls命令</p>
<p>功能：显示文件和目录的信息</p>
<p>ls　以默认方式显示当前目录文件列表</p>
<p>ls -a 显示所有文件包括隐藏文件</p>
<p>ls -l 显示文件属性，包括大小，日期，符号连接，是否可读写及是否可执行</p>
<p>ls -lh 显示文件的大小，以容易理解的格式印出文件大小 (例如 1K 234M2G)</p>
<p>ls -lt 显示文件，按照修改时间排序</p>
<p>2、cd命令</p>
<p>功能：改名目录</p>
<p>cd dir　切换到当前目录下的dir目录</p>
<p>cd /　切换到根目录</p>
<p>cd ..　切换到到上一级目录</p>
<p>cd ../..　切换到上二级目录</p>
<p>cd ~　切换到用户目录，比如是root用户，则切换到/root下</p>
<p>3、cp命令</p>
<p>功能：copy文件</p>
<p>cp source target　将文件source复制为target</p>
<p>cp /root /source.　将/root下的文件source复制到当前目录</p>
<p>cp –av soure_dir target_dir　将整个目录复制，两目录完全一样</p>
<p>4、rm命令</p>
<p>功能：删除文件或目录</p>
<p>rm file　删除某一个文件</p>
<p>rm -f file 删除时候不进行提示。可以于r参数配合使用</p>
<p>rm -rf dir　删除当前目录下叫dir的整个目录</p>
<p>5、mv命令</p>
<p>功能：将文件移动走，或者改名，在uinx下面没有改名的命令，如果想改名，可以使用该命令</p>
<p>mv source target　将文件source更名为target</p>
<p>6、diff</p>
<p>功能：比较文件内容</p>
<p>diff dir1 dir2　比较目录1与目录2的文件列表是否相同，但不比较文件的实际内容，不同则列出</p>
<p>diff file1<br>file2　比较文件1与文件2的内容是否相同，如果是文本格式的文件，则将不相同的内容显示，如果是二进制代码则只表示两个文件是不同的</p>
<p>comm file1 file2　比较文件，显示两个文件不相同的内容</p>
<p>7、ln命令</p>
<p>功能：建立链接。windows的快捷方式就是根据链接的原理来做的</p>
<p>ln source_path target_path 硬连接</p>
<p>ln -s source_path target_path 软连接</p>
<p>查看文件内容命令<br>1、cat命令</p>
<p>显示文件的内容，和DOS的type相同</p>
<p>cat file</p>
<p>2、more命令</p>
<p>功能：分页显示命令</p>
<p>more　file</p>
<p>more命令也可以通过管道符(|)与其他的命令一起使用,例如：</p>
<p>ps ux|more</p>
<p>ls|more</p>
<p>3、tail 命令</p>
<p>功能：显示文件的最后几行</p>
<p>tail -n 100 aaa.txt 显示文件aaa.txt文件的最后100行</p>
<p>4、vi命令</p>
<p>vi file　编辑文件file</p>
<p>vi 原基本使用及命令：</p>
<p>输入命令的方式为先按[ESC]键，然后输入:w(写入文件),:w!(不询问方式写入文件）,:wq保存并退出,:q退出,q!不保存退出</p>
<p>5、touch命令</p>
<p>功能：创建一个空文件</p>
<p>touch aaa.txt 创建一个空文件，文件名为aaa.txt</p>
<p>基本系统命令<br>1、man命令</p>
<p>功能：查看某个命令的帮助，如果你不知道某个命令的用法不懂，可以问他，他知道就回告诉你</p>
<p>例如：</p>
<p>man ls 显示ls命令的帮助内容</p>
<p>2、w命令</p>
<p>功能：显示登录用户的详细信息</p>
<p>例如：</p>
<p>Sarge:~# w</p>
<p>22:06:51 up 43 min, 1 user, load average: 0.00, 0.00, 0.00</p>
<p>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</p>
<p>zhoulj pts/0 10.140.0.109 21:24 0.00s 0.85s 0.09s sshd:<br>zhoulj [priv]</p>
<p>3、who命令</p>
<p>功能：显示登录用户</p>
<p>例如：</p>
<p>Sarge:~# who</p>
<p>zhoulj pts/0 Mar 13 21:24 (10.140.0.109)</p>
<p>4、last命令</p>
<p>功能：查看最近那些用户登录系统</p>
<p>例如：</p>
<p>Sarge:~# last</p>
<p>zhoulj pts/0 10.140.0.109 Mon Mar 13 21:24 still logged in</p>
<p>reboot system boot 2.6.8-2-386 Mon Mar 13 21:23 (00:43)</p>
<p>zhoulj pts/0 10.140.0.105 Sun Mar 12 22:51 - down (00:00)</p>
<p>zhoulj pts/0 10.140.0.105 Sun Mar 12 22:51 - 22:51 (00:00)</p>
<p>root tty1 Sun Mar 12 22:50 - down (00:01)</p>
<p>root tty1 Sun Mar 12 22:46 - 22:48 (00:02)</p>
<p>root tty1 Sun Mar 12 22:43 - 22:46 (00:02)</p>
<p>reboot system boot 2.6.8-2-386 Mon Mar 13 06:34 (-7:-41)</p>
<p>wtmp begins Mon Mar 13 06:34:11 2006</p>
<p>5、date命令</p>
<p>功能：系统日期设定</p>
<p>date　显示当前日期时间</p>
<p>date -s 20:30:30　设置系统时间为20:30:30</p>
<p>date -s 2002-3-5　设置系统时期为2003-3-5</p>
<p>date -s “060520 06:00:00”　设置系统时期为2006年5月20日6点整。</p>
<p>6、clock命令</p>
<p>功能：时钟设置</p>
<p>clock –r　对系统Bios中读取时间参数</p>
<p>clock –w　将系统时间(如由date设置的时间)写入Bios</p>
<p>7、uname命令</p>
<p>功能：查看系统版本</p>
<p>uname -R　显示操作系统内核的version</p>
<p>例如：</p>
<p>Sarge:~# uname -a</p>
<p>Linux Sarge 2.6.8-2-386 #1 Tue Aug 16 12:46:35 UTC 2005 i686 GNU/Linux</p>
<p>8、关闭和重新启动系统命令</p>
<p>reboot　 重新启动计算机</p>
<p>shutdown -r now 重新启动计算机，停止服务后重新启动计算机</p>
<p>shutdown -h now 关闭计算机，停止服务后再关闭系统</p>
<p>halt 关闭计算机</p>
<p>一般用shutdown -r now,在重启系统是，关闭相关服务，shutdown -h now也是如此。</p>
<p>9、su命令</p>
<p>功能：切换用户</p>
<p>su - 切换到root用户</p>
<p>su - zhoulj 切换到zhoulj用户，</p>
<p>注意：- ，他很关键，使用-，将使用用户的环境变量</p>
<p>四、监视系统状态命令</p>
<p>1、top命令</p>
<p>功能：查看系统cpu、内存等使用情况</p>
<p>2、free命令</p>
<p>功能：查看内存和swap分区使用情况</p>
<p>例如：</p>
<p>Sarge:~# free -tm</p>
<pre><code>        total       used       free     shared    buffers     cached</code></pre><p>1<br>Mem: 187 42 145 0 6 16</p>
<p>-/+ buffers/cache: 19 167</p>
<p>Swap: 243 0 243</p>
<p>Total: 430 42 388</p>
<p>3、uptime</p>
<p>功能：现在的时间 ，系统开机运转到现在经过的时间，连线的使用者数量，最近一分钟，五分钟和十五分钟的系统负载</p>
<p>例如：</p>
<p>Sarge:~# uptime</p>
<p>21:54:46 up 31 min, 1 user, load average: 0.00, 0.00, 0.00</p>
<p>4、vmstat命令</p>
<p>功能：监视虚拟内存使用情况</p>
<p>例如：</p>
<p>Sarge:~# vmstat</p>
<p>procs memory swap io system<br>cpu</p>
<p>r b swpd free buff cache si so bi bo in cs us<br>sy id wa</p>
<p>1 0 0 63704 8100 32272 0 0 8 3 103 17 0<br>1 98 1</p>
<p>5、ps命令</p>
<p>功能：显示进程信息</p>
<p>ps ux 显示当前用户的进程</p>
<p>ps uxwww 显示当前用户的进程的详细信息</p>
<p>ps aux 显示所有用户的进程</p>
<p>ps ef 显示系统所有进程信息</p>
<p>6、kill命令</p>
<p>功能：干掉某个进程，进程号可以通过ps命令得到</p>
<p>kill -9 1001　将进程编号为1001的程序干掉</p>
<p>kill all -9 apache　将所有名字为apapche的程序杀死，kill不是万能的，对僵死的程序则无效。</p>
<p>五、磁盘操作命令</p>
<p>1、df命令</p>
<p>功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>参数 功能</p>
<p>-a 列出全部目录</p>
<p>-Ta 列出全部目录，并且显示文件类型</p>
<p>-B 显示块信息</p>
<p>-i 以i节点列出全部目录</p>
<p>-h 按照日常习惯显示（如：1K、100M、20G）</p>
<p>-x [filesystype] 不显示[filesystype]</p>
<p>例如：</p>
<p>Sarge:~# df -Th</p>
<p>Filesystem Type Size Used Avail Use% Mounted on</p>
<p>/dev/sda1 ext3 265M 64M 187M 26% /</p>
<p>tmpfs tmpfs 94M 0 94M 0% /dev/shm</p>
<p>/dev/sda6 ext3 714M 8.1M 667M 2% /home</p>
<p>/dev/sda8 ext3 956M 215M 691M 24% /usr</p>
<p>/dev/sda7 ext3 714M 57M 619M 9% /var</p>
<p>2、du命令</p>
<p>功能：检测一个目录和（递归地）所有它的子目录中的文件占用的磁盘空间。</p>
<p>参数 功能</p>
<p>-s [dirName] 显示目录占用总空间</p>
<p>-sk [dirName] 显示目录占用总空间，以k为单位</p>
<p>-sb [dirName] 显示目录占用总空间，以b为单位</p>
<p>-sm [dirName] 显示目录占用总空间，以m为单位</p>
<p>-sc [dirName] 显示目录占用总空间，加上目录统计</p>
<p>-sh [dirName] 只统计目录大小</p>
<p>例如：</p>
<p>Sarge:~# du -sh /etc</p>
<p>1.3M /etc</p>
<p>3、mount命令</p>
<p>功能：使用mount命令就可在Linux中挂载各种文件系统。</p>
<p>格式：mount -t 设备名 挂载点</p>
<p>（1）、mount /dev/sda1 /mnt/filetest</p>
<p>mount -t vfat /dev/hda /mnt/fatfile</p>
<p>mount -t ntfs /dev/hda /mnt/ntfsfile</p>
<p>mount -t iso9660 /dev/cdrom /mnt/cdrom</p>
<p>mount -o 设备名 挂载点</p>
<p>（2）、使用usb设备</p>
<p>modprobe usb-storage</p>
<p>mkdir /mnt/usb</p>
<p>mount -t auto /dev/sdx1 /mnt/usb</p>
<p>umount /mnt/usb</p>
<p>4、mkswap命令</p>
<p>功能：使用mkswap命令可以创建swap空间，如：</p>
<p>debian:~# mkswap -c /dev/hda4</p>
<p>debian:~# swapon /dev/hda4 #启用新创建的swap空间，停用可使用swapoff命令</p>
<p>5、fdisk命令</p>
<p>功能：对磁盘进行分区</p>
<p>fdisk /dev/xxx 格式化xxx设备(xxx是指磁盘驱动器的名字，例如hdb，sdc)</p>
<p>fdisk -l 显示磁盘的分区表</p>
<p>6、mkfs命令</p>
<p>功能：格式化文件系统，可以指定文件系统的类型，如ext2、ext3、fat、ntfs等</p>
<p>格式1：mkfs.ext3 options /dev/xxx</p>
<p>格式2：mkfs -t ext2 options /dev/xxx</p>
<p>参数 功能</p>
<p>-b 块大小</p>
<p>-i 节点大写</p>
<p>-m 预留管理空间大小</p>
<p>例如：</p>
<p>debian:~#mkfs.ext3 /dev/sdb1</p>
<p>7、e2fsck命令</p>
<p>功能：磁盘检测</p>
<p>e2fsck /dev/hda1　检查/dev/hda1是否有文件系统错误，提示修复方式</p>
<p>e2fsck -p /dev/hda1　检查/dev/hda1是否有错误，如果有则自动修复</p>
<p>e2fsck -y /dev/hda1　检查错误，所有提问均于yes方式执行</p>
<p>e2fsck -c /dev/hda1　检查磁盘是否有坏区</p>
<p>8、tune2fs命令</p>
<p>功能：调整ext2/ext3文件的参数</p>
<p>参数 功能</p>
<p>-l 查看文件系统信息</p>
<p>-c 设置强制自检的挂载次数</p>
<p>-i 设置强制自检的间隔时间，单位天</p>
<p>-m 保留块的百分比</p>
<p>-j 将ext2文件系统转换成ext3格式</p>
<p>Sarge:~# tune2fs -l /dev/sda1</p>
<p>9、dd命令</p>
<p>功能：功能：把指定的输入文件拷贝到指定的输出文件中，并且在拷贝过程中可以进行格式转换。</p>
<p>跟DOS下的diskcopy命令的作用类似。</p>
<p>dd if=/dev/fd0 of=floppy.img　将软盘的内容复制成一个镜像</p>
<p>dd if=floppy.img of=/dev/fd0　将一个镜像的内容复制到软盘，做驱动盘的时候经常用。</p>
<p>用户和组相关命令<br>1、groupadd命令</p>
<p>功能：添加组</p>
<p>groupadd test1 添加test1组</p>
<p>groupadd -g 1111 test2 添加test2组，组id为1111</p>
<p>2、useradd命令</p>
<p>功能：添加用户</p>
<p>useradd user1 添加用户user1，home为/home/user1，组为user1</p>
<p>useradd -g test1 -m -d /home/test1 test1<br>添加用户test1，home为/home/test1，组为test1</p>
<p>user list　显示已登陆的用户列表</p>
<p>3、passwd命令</p>
<p>功能：更改用户密码</p>
<p>passwd user1　修改用户user1的密码</p>
<p>passwd -d root　将root用户的密码删除</p>
<p>4、userdel命令</p>
<p>功能：删除用户</p>
<p>userdel user1　删除user1用户</p>
<p>5、chown命令</p>
<p>功能：改变文件或目录的所有者</p>
<p>chown user1 /dir　将/dir目录设置为user1所有</p>
<p>chown -R user1.user1<br>/dir　将/dir目录下所有文件和目录，设置为user1所有,组为user1。-R递归到下面的每个文件和目录</p>
<p>6、chgrp命令</p>
<p>功能：改变文件或目录的所有组</p>
<p>chgrp user1 /dir　将/dir目录设置为user1所有</p>
<p>7、chmod命令</p>
<p>功能：改变用户的权限</p>
<p>chmod a+x file　将file文件设置为可执行，脚本类文件一定要这样设置一个，否则得用bash file才能执行</p>
<p>chmod 666 file　将文件file设置为可读写</p>
<p>chmod 750 file 将文件file设置为，所有者为完全权限，同组可以读和执行，其他无权限</p>
<p>8、id命令</p>
<p>功能：显示用户的信息，包括uid、gid等</p>
<p>Sarge:~# id zhoulj</p>
<p>uid=500(zhoulj) gid=500(zhoulj) groups=500(zhoulj)</p>
<p>9、finger命令</p>
<p>功能：显示用的信息</p>
<p>注意：debian下没有该命令。</p>
<p>Sarge:~# finger zhoulj</p>
<p>Login: zhoulj Name:</p>
<p>Directory: /home/zhoulj Shell: /bin/bash</p>
<p>On since Sun May 21 07:59 (CST) on pts/0 from 192.168.1.4</p>
<p>No mail.</p>
<p>No Plan.</p>
<p>压缩命令<br>1、gzip格式命令</p>
<p>功能：压缩文件，gz格式的</p>
<p>注意：生成的文件会把源文件覆盖</p>
<p>gzip -v 压缩文件，并且显示进度</p>
<p>-d 解压缩</p>
<p>gnuzip -f 解压缩</p>
<p>例如：</p>
<p>Sarge:~# gzip a.sh</p>
<p>Sarge:~#ll</p>
<p>-rwxr-xr-x 1 root root 71 12月 18 21:08 a.sh.gz</p>
<p>Sarge:~# gzip -d a.sh.gz</p>
<p>Sarge:~#ll</p>
<p>-rwxr-xr-x 1 root root 48 12月 18 21:08 a.sh</p>
<p>2、zip格式命令</p>
<p>功能：压缩和解压缩zip命令</p>
<p>zip</p>
<p>unzip</p>
<p>例如：</p>
<p>Sarge:~# zip a.sh.zip a.sh</p>
<p>adding: a.sh (stored 0%)</p>
<p>Sarge:~# ll</p>
<p>-rw-r–r– 1 root root 188 5月 21 10:37 a.sh.zip</p>
<p>Sarge:~# unzip a.sh.zip</p>
<p>Archive: a.sh.zip</p>
<p>replace a.sh? [y]es, [n]o, [A]ll, [N]one, [r]ename: r</p>
<p>new name: a1.sh</p>
<p>extracting: a1.sh</p>
<p>Sarge:~ # ll</p>
<p>-rwxr-xr-x 1 root root 48 12月 18 21:08 a1.sh</p>
<p>3、bzip2根式命令</p>
<p>功能：bzip2格式压缩命令，</p>
<p>注意：生成的文件会把源文件覆盖</p>
<p>bzip2</p>
<p>bunzip2</p>
<p>例如：</p>
<p>Sarge:~ # bzip2 a.sh</p>
<p>Sarge:~# ll</p>
<p>-rwxr-xr-x 1 root root 85 12月 18 21:08 a.sh.bz2</p>
<p>Sarge:~ # bunzip2 a.sh.bz2</p>
<p>Sarge:~# ll</p>
<p>-rwxr-xr-x 1 root root 48 12月 18 21:08 a.sh</p>
<p>4、tar命令</p>
<p>功能：归档、压缩等，比较重要，会经常使用。</p>
<p>-cvf 压缩文件或目录</p>
<p>-xvf 解压缩文件或目录</p>
<p>-zcvf 压缩文件或，格式tar.gz</p>
<p>-zxvf 解压缩文件或，格式tar.gz</p>
<p>-zcvf 压缩文件或，格式tgz</p>
<p>-zxvf 解压缩文件或，格式tgz</p>
<p>举例:</p>
<p>Sarge:~ # tar cvf abc.tar *.sh</p>
<p>Sarge:~# tar xvf abc.tar</p>
<p>Sarge:~# tar czvf abc.tar.gz *.sh</p>
<p>Sarge:~# ll</p>
<p>-rw-r–r– 1 root root 20480 5月 21 10:50 abc.tar</p>
<p>-rw-r–r– 1 root root 1223 5月 21 10:53 abc.tar.gz</p>
<p>Sarge:~# tar xzvf abc.tar.gz</p>
<p>网络相关命令<br>1、ifconfig命令</p>
<p>功能：显示修改网卡的信息</p>
<p>ifconfig 显示网络信息</p>
<p>ifconfig eth0 显示eth0网络信息</p>
<p>修改网络信息：</p>
<p>ifconfig eth0 192.168.1.1 netmask 255.255.255.0<br>设置网卡1的地址192.168.1.1，掩码为255.255.255.0</p>
<p>ifconfig eth0:1 192.168.1.2　 捆绑网卡1的第二个地址为192.168.1.2</p>
<p>ifconfig eth0:x 192.168.1.n　 捆绑网卡1的第n个地址为192.168.1.n</p>
<p>例如：</p>
<p>Sarge:~# ifconfig eth0:1 192.168.1.11</p>
<p>Sarge:~ # ifconfig</p>
<p>eth0 Link encap:Ethernet HWaddr 00:0C:29:06:9C:24</p>
<pre><code>  inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0

  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

  RX packets:4220 errors:0 dropped:0 overruns:0 frame:0

  TX packets:3586 errors:0 dropped:0 overruns:0 carrier:0

  collisions:0 txqueuelen:1000

  RX bytes:342493 (334.4 Kb)  TX bytes:469020 (458.0 Kb)

  Interrupt:9 Base address:0x1400</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>eth0:1 Link encap:Ethernet HWaddr 00:0C:29:06:9C:24</p>
<pre><code>  inet addr:192.168.1.11  Bcast:192.168.1.255  Mask:255.255.255.0

  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

  Interrupt:9 Base address:0x1400</code></pre><p>1<br>2<br>3<br>4<br>5<br>2、route命令</p>
<p>功能：显示当前路由设置情况</p>
<p>route 显示当前路由设置情况，比较慢一般不用。</p>
<p>route add -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254 添加静态路由</p>
<p>route del -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254 添加静态路由</p>
<p>route add default gw 192.168.1.1 metric1　 设置192.168.1.1为默认的路由</p>
<p>route del default　 将默认的路由删除</p>
<p>举例：</p>
<p>Sarge:~# route add -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254</p>
<p>Sarge:~# netstat -nr</p>
<p>Kernel IP routing table</p>
<p>Destination Gateway Genmask Flags MSS Window<br>irtt Iface</p>
<p>192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0</p>
<p>10.0.0.0 192.168.1.254 255.255.0.0 UG 0 0 0 eth0</p>
<p>169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0</p>
<p>0.0.0.0 192.168.1.254 0.0.0.0 UG 0 0 0 eth0</p>
<p>Sarge:~# route del -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254</p>
<p>Sarge:~# netstat -nr</p>
<p>Kernel IP routing table</p>
<p>Destination Gateway Genmask Flags MSS Window<br>irtt Iface</p>
<p>192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0</p>
<p>169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0</p>
<p>0.0.0.0 192.168.1.254 0.0.0.0 UG 0 0 0 eth0</p>
<p>3、netstat命令</p>
<p>功能：显示网络状态</p>
<p>netstat -an 查看网络端口信息</p>
<p>netstat -nr 查看路由表信息，比route快多了，</p>
<p>4、启动网络的命令</p>
<p>redhat族的命令:</p>
<p>/etc/init.d/network</p>
<p>debian命令:</p>
<p>/etc/init.d/networking</p>
<p>例如：</p>
<p>/etc/init.d/network stop 停止网络，</p>
<p>/etc/init.d/network start 启动网络，</p>
<p>5、手工修改网络配置</p>
<p>(1)、debian系统</p>
<p>配置文件位置为：/etc/network/interfaces</p>
<p>Sarge:~# The loopback network interface</p>
<p>auto lo</p>
<p>iface lo inet loopback</p>
<p>Sarge:~# The primary network interface</p>
<p>auto eth0 eth1</p>
<p>iface eth0 inet static</p>
<pre><code>address 10.4.5.6

netmask 255.255.255.0

network 10.4.5.0

broadcast 10.4.5.255</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>iface eth1 inet static</p>
<pre><code>address 219.25.5.60

netmask 255.255.255.192

network 219.25.5.0

broadcast 219.25.5.63

gateway 219.25.5.30</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>修改后保存配置后，运行</p>
<p>/etc/init.d/networking restart</p>
<p>网络配置就改变了</p>
<p>(2)、redhat系统</p>
<p>配置文件位置为：/etc/sysconfig/network-scripts/ifcfg-eth0</p>
<p>DEVICE=eth0</p>
<p>BOOTPROTO=static</p>
<p>BROADCAST=192.168.1.255</p>
<p>IPADDR=192.168.1.5</p>
<p>NETMASK=255.255.255.0</p>
<p>NETWORK=192.168.1.0</p>
<p>GATEWAY=192.168.1.254</p>
<p>ONBOOT=yes</p>
<p>TYPE=Ethernet</p>
<p>修改后保存配置后，运行</p>
<p>/etc/init.d/network restart</p>
<p>或者</p>
<p>service network restart</p>
<p>网络配置就改变了。</p>
<p>默认DNS的文件的位置为：/etc/resolv.conf</p>
<p>Sarge:~#cat /etc/resolv.conf</p>
<p>search test.com.cn</p>
<p>nameserver 192.168.1.11</p>
<p>6、网络排错</p>
<p>(1)、ping命令</p>
<p>功能：不说了，不知道就用干这行了。</p>
<p>ping</p>
<p>(2)、traceroute命令</p>
<p>功能：路由跟踪</p>
<p>traceroute</p>
<p>traceroute 207.68.173.7</p>
<p>(3)、nslookup命令</p>
<p>功能：域名解析排错</p>
<p>例如：</p>
<p>$ nslookup</p>
<p>Note: nslookup is deprecated and may be removed from future releases.</p>
<p>Consider using the dig’ orhost’ programs instead. Run nslookup<br>with</p>
<p>the `-sil[ent]’ option to prevent this message from appearing.</p>
<p>Server: 192.168.1.11</p>
<p>Address: 192.168.1.11#53</p>
<p>Non-authoritative answer:</p>
<p>Name:</p>
<p>Address: 202.118.66.66</p>
<p>server 202.118.66.6</p>
<p>Default server: 202.118.66.6</p>
<p>Address: 202.118.66.6#53</p>
<p>Server: 202.118.66.6</p>
<p>Address: 202.118.66.6#53</p>
<p>Non-authoritative answer: canonical name =</p>
<p>Name:</p>
<p>Address: 202.108.22.5</p>
<p>其他命令<br>1、ssh命令</p>
<p>功能：远程登陆到其他UNIX主机</p>
<p>ssh -l user1 192.168.1.2 使用用户名user1登陆到192.168.1.2</p>
<p>ssh</p>
<p>使用用户名user1登陆到192.168.1.2</p>
<p>2、scp命令</p>
<p>功能：安全copy</p>
<p>例如：</p>
<p>scp abc.tar.gz</p>
<p>:~ 将本地的abc.tar.gz 复制到 192.168.1.5的user1用户的根(/home/user1)下。</p>
<p>3、telnet命令</p>
<p>功能：登陆到远程主机</p>
<p>例如：</p>
<p>telnet 192.168.1.5</p>
<p>3、find</p>
<p>   find pathname -options [-print -exec -ok]<br>   让我们来看看该命令的参数：<br>   pathname find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。<br>   -print find命令将匹配的文件输出到标准输出。<br>   -exec find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {} ;，注意{}和\；之间的空格，同时两个{}之间没有空格,<br>   注意一定有分号结尾。<br>   0) -ok 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行<br>   find . -name “datafile” -ctime -1 -exec ls -l {} ; 找到文件名为datafile<em>, 同时创建实际为1天之内的文件, 然后显示他们的明细.<br>   find . -name “datafile” -ctime -1 -exec rm -f {} ; 找到文件名为datafile</em>, 同时创建实际为1天之内的文件, 然后删除他们.</p>
<p>   find . -name “datafile” -ctime -1 -ok ls -l {} ; 这两个例子和上面的唯一区别就是-ok会在每个文件被执行命令时提示用户, 更加安全.<br>   find . -name “datafile” -ctime -1 -ok rm -f {} ; </p>
<p>   1) find . -name   基于文件名查找,但是文件名的大小写敏感.<br>   find . -name “datafile*”</p>
<p>   2) find . -iname  基于文件名查找,但是文件名的大小写不敏感.<br>   find . -iname “datafile*”</p>
<p>   3) find . -maxdepth 2 -name fred 找出文件名为fred,其中find搜索的目录深度为2(距当前目录), 其中当前目录被视为第一层.</p>
<p>   4) find . -perm 644 -maxdepth 3 -name “datafile*”  (表示权限为644的, 搜索的目录深度为3, 名字为datafile*的文件)</p>
<p>   5) find . -path “./rw” -prune -o -name “datafile*” 列出所有不在./rw及其子目录下文件名为datafile<em>的文件。<br>   find . -path “./dir</em>“ 列出所有符合dir<em>的目录及其目录的文件.<br>   find . ( -path “./d1” -o -path “./d2” ) -prune -o -name “datafile</em>“ 列出所有不在./d1和d2及其子目录下文件名为datafile*的文件。</p>
<p>   6) find . -user ydev 找出所有属主用户为ydev的文件。<br>   find . ! -user ydev 找出所有属主用户不为ydev的文件， 注意!和-user之间的空格。</p>
<p>   7) find . -nouser    找出所有没有属主用户的文件，换句话就是，主用户可能已经被删除。</p>
<p>   8) find . -group ydev 找出所有属主用户组为ydev的文件。</p>
<p>   9) find . -nogroup    找出所有没有属主用户组的文件，换句话就是，主用户组可能已经被删除。</p>
<p>   10) find . -mtime -3[+3] 找出修改数据时间在3日之内[之外]的文件。<br>   find . -mmin  -3[+3] 找出修改数据时间在3分钟之内[之外]的文件。<br>   find . -atime -3[+3] 找出访问时间在3日之内[之外]的文件。<br>   find . -amin  -3[+3] 找出访问时间在3分钟之内[之外]的文件。<br>   find . -ctime -3[+3] 找出修改状态时间在3日之内[之外]的文件。<br>   find . -cmin  -3[+3] 找出修改状态时间在3分钟之内[之外]的文件。</p>
<p>   11) find . -newer eldest_file ! -newer newest_file 找出文件的更改时间 between eldest_file and newest_file。<br>   find . -newer file     找出所有比file的更改时间更新的文件<br>   find . ! -newer file 找出所有比file的更改时间更老的文件</p>
<p>   12) find . -type d    找出文件类型为目录的文件。<br>   find . ! -type d  找出文件类型为非目录的文件。<br>   b - 块设备文件。<br>   d - 目录。<br>   c - 字符设备文件。<br>   p - 管道文件。<br>   l - 符号链接文件。<br>   f - 普通文件。</p>
<p>   13) find . -size [+/-]100[c/k/M/G] 表示文件的长度为等于[大于/小于]100块[字节/k/M/G]的文件。</p>
<p>   14) find . -empty 查找所有的空文件或者空目录.</p>
<p>   15) find . -type f | xargs grep “ABC”<br>   使用xargs和-exec的区别是, -exec可能会为每个搜索出的file,启动一个新的进程执行-exec的操作, 而xargs都是在一个进程内完成, 效率更高.</p>
]]></content>
  </entry>
  <entry>
    <title>hexo命令</title>
    <url>/2020/04/17/hexo%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><pre><code>$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<pre><code>$ hexo new &quot;post title with whitespace&quot;</code></pre><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--path</code></td>
<td align="left">自定义新文章的路径</td>
</tr>
<tr>
<td align="left"><code>-r</code>, <code>--replace</code></td>
<td align="left">如果存在同名文章，将其替换</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--slug</code></td>
<td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p>
<pre><code>hexo new page --path about/me &quot;About me&quot;</code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<pre><code>hexo new page --path about/me</code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><pre><code>$ hexo generate</code></pre><p>生成静态文件。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-d</code>, <code>--deploy</code></td>
<td align="left">文件生成后立即部署网站</td>
</tr>
<tr>
<td align="left"><code>-w</code>, <code>--watch</code></td>
<td align="left">监视文件变动</td>
</tr>
<tr>
<td align="left"><code>-b</code>, <code>--bail</code></td>
<td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td align="left"><code>-f</code>, <code>--force</code></td>
<td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td align="left"><code>-c</code>, <code>--concurrency</code></td>
<td align="left">最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody></table>
<p>该命令可以简写为</p>
<pre><code>$ hexo g</code></pre><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><pre><code>$ hexo publish [layout] &lt;filename&gt;</code></pre><p>发表草稿。</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><pre><code>$ hexo server</code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--port</code></td>
<td align="left">重设端口</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--static</code></td>
<td align="left">只使用静态文件</td>
</tr>
<tr>
<td align="left"><code>-l</code>, <code>--log</code></td>
<td align="left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><pre><code>$ hexo deploy</code></pre><p>部署网站。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-g</code>, <code>--generate</code></td>
<td align="left">部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<p>该命令可以简写为：</p>
<pre><code>$ hexo d</code></pre><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><pre><code>$ hexo render &lt;file1&gt; [file2] ...</code></pre><p>渲染文件。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-o</code>, <code>--output</code></td>
<td align="left">设置输出路径</td>
</tr>
</tbody></table>
<h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><pre><code>$ hexo migrate &lt;type&gt;</code></pre><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration" target="_blank" rel="noopener">迁移内容</a>。</p>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><pre><code>$ hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><pre><code>$ hexo list &lt;type&gt;</code></pre><p>列出网站资料。</p>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><pre><code>$ hexo version</code></pre><p>显示 Hexo 版本。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><pre><code>$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><pre><code>$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new" target="_blank" rel="noopener">提交调试信息到 GitHub</a>。</p>
<h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><pre><code>$ hexo --silent</code></pre><p>隐藏终端信息。</p>
<h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><pre><code># 使用 custom.yml 代替默认的 _config.yml
$ hexo server --config custom.yml

# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高
$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>
<pre><code># 使用 custom.yml 代替默认的 _config.yml
$ hexo server --config custom.yml

# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json
$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>
<h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><pre><code>$ hexo --draft</code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>
<h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><pre><code>$ hexo --cwd /path/to/cwd</code></pre><p>自定义当前工作目录（Current working directory）的路径。</p>
]]></content>
  </entry>
  <entry>
    <title>最新(2020)virtualenv的一些命令</title>
    <url>/2020/04/16/%E6%9C%80%E6%96%B0(2020)virtualenv%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="最新-2020-virtualenv的一些命令"><a href="#最新-2020-virtualenv的一些命令" class="headerlink" title="最新(2020)virtualenv的一些命令"></a>最新(2020)virtualenv的一些命令</h1><p>which python3 查看python目录</p>
<p><a href="http://www.wailian.work/album/xUiBn/?sort=date_desc&amp;pagev=1" target="_blank" rel="noopener">http://www.wailian.work/album/xUiBn/?sort=date_desc&amp;pagev=1</a></p>
<p>virtualenv venv2 -p python3 安装指定版本</p>
<p>source bin/active 进入虚拟环境(已经更改了入口,现已不适用)</p>
<h2 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h2><p>在Windows上 virtualenv 创建了batch file</p>
<pre><code>\env\Scripts\activate.bat</code></pre><p>启动脚本在脚本文件夹</p>
<pre><code>\path\to\env\Scripts\activate</code></pre><p>如:</p>
<pre><code>C:\Users\&#39;Username&#39;\venv\Scripts\activate.bat</code></pre><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>虚拟环境是一个包含二进制程序和 shell 脚本的目录。二进制程序包含执行脚本的 <em>python</em> 和安装其它模块的 <em>pip</em>。脚本包括激活环境的脚本，<a href="https://wiki.archlinux.org/index.php/Bash" target="_blank" rel="noopener">bash</a>, csh 和<a href="https://wiki.archlinux.org/index.php/Fish" target="_blank" rel="noopener">fish</a> 个有一个。这个虚拟环境模拟了一个完整的 <a href="https://wiki.archlinux.org/index.php/Python" target="_blank" rel="noopener">Python</a> 执行环境和需要的模块，将程序运行的环境与系统其它部分隔离开来。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://wiki.archlinux.org/index.php/Python" target="_blank" rel="noopener">Python</a> 从 3.3 开始包含了 <em>venv</em> 程序，无需单独安装。 如果使用的是老版本的 Python, 需要额外<a href="https://wiki.archlinux.org/index.php/安装" target="_blank" rel="noopener">安装</a> <em>virtualenv</em>。</p>
<ul>
<li>Python 3.3+: <a href="https://www.archlinux.org/packages/?name=python" target="_blank" rel="noopener">python</a></li>
<li>Python 3: <a href="https://www.archlinux.org/packages/?name=python-virtualenv" target="_blank" rel="noopener">python-virtualenv</a></li>
<li>Python 2: <a href="https://www.archlinux.org/packages/?name=python2-virtualenv" target="_blank" rel="noopener">python2-virtualenv</a></li>
</ul>
<h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>使用<em>venv</em> 或 <em>virtualenv</em> 在项目目录创建虚拟环境，请将 venv 目录加入版本控制系统，这样只要执行 <code>pip freeze</code> 就可以重建虚拟环境。</p>
<h4 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h4><p><strong>Note:</strong> 此方法代替了从 <a href="https://www.archlinux.org/packages/?name=python" target="_blank" rel="noopener">python</a> 3.6 就不建议使用的 <em>pyvenv</em>。</p>
<p><a href="https://www.archlinux.org/packages/?name=python" target="_blank" rel="noopener">python</a> 软件包从 3.3 开始就提供了此工具:</p>
<pre><code>$ python -m venv venv</code></pre><h4 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h4><p>Python 3 使用 <a href="https://www.archlinux.org/packages/?name=python-virtualenv" target="_blank" rel="noopener">python-virtualenv</a> 提供的 <em>virtualenv</em>。</p>
<pre><code>$ virtualenv venv</code></pre><p>Python 2 使用 <a href="https://www.archlinux.org/packages/?name=python2-virtualenv" target="_blank" rel="noopener">python2-virtualenv</a> 提供的 <em>virtualenv2</em>。</p>
<pre><code>$ virtualenv2 venv</code></pre><h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>要激活虚拟环境(这里假设使用的是 bash):</p>
<pre><code>$ source venv/bin/activate
(venv) $</code></pre><p>一旦进入虚拟环境，就可以通过 <em>pip</em> 安装软件包，并正常执行脚本。</p>
<p>要退出寻环境，执行 <code>bin/activate</code> 下的:</p>
<pre><code>(venv) $ deactivate</code></pre><h2 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h2><p>二进制的版本由使用的虚拟环境工具决定。使用 Python 2 工具创建的虚拟环境中，<em>python</em> 命令指向 <code>bin/python2.7</code>，<em>venv</em> 创建的环境中， python 指向 <code>bin/python3.6</code>.</p>
<p><em>venv</em> 和 <em>virtualenv</em> 差别在于 venv 默认使用系统的 Python 程序:</p>
<pre><code>$ ls -l venv/bin/python3.6
lrwxrwxrwx 1 foo foo 7 Jun  3 19:57 venv/bin/python3.6 -&gt; /usr/bin/python3</code></pre><p>而 <em>virtualenv</em> 工具使用环境目录中的 Python 程序:</p>
<pre><code>$ ls -l virtualenv/bin/python3.6
lrwxrwxrwx 1 foo foo 7 Jun  3 19:58 virtualenv/bin/python3.6 -&gt; python3</code></pre>]]></content>
  </entry>
  <entry>
    <title>Python虚拟环境(创建激活操作删除-virtualenv、Pycharm、virtualenvwrapper、pipenv)</title>
    <url>/2020/04/16/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83(%E5%88%9B%E5%BB%BA%E6%BF%80%E6%B4%BB%E6%93%8D%E4%BD%9C%E5%88%A0%E9%99%A4-virtualenv%E3%80%81Pycharm%E3%80%81virtualenvwrapper%E3%80%81pipenv)/</url>
    <content><![CDATA[<h1 id="Python基础42-虚拟环境-创建-激活-操作-删除-virtualenv、Pycharm、virtualenvwrapper、pipenv"><a href="#Python基础42-虚拟环境-创建-激活-操作-删除-virtualenv、Pycharm、virtualenvwrapper、pipenv" class="headerlink" title="Python基础42-虚拟环境(创建/激活/操作/删除-virtualenv、Pycharm、virtualenvwrapper、pipenv)"></a>Python基础42-虚拟环境(创建/激活/操作/删除-virtualenv、Pycharm、virtualenvwrapper、pipenv)</h1><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><ul>
<li>一个独立的局部的 Python 环境</li>
<li>完全模拟系统全局 Python 环境的使用，如安装、卸载包到逻辑操作等</li>
</ul>
<h1 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h1><ul>
<li>让项目运行在一个独立的局部的 Python 环境中，使采用不同环境的项目互不干扰。</li>
</ul>
<h1 id="3-安装虚拟环境"><a href="#3-安装虚拟环境" class="headerlink" title="3 安装虚拟环境"></a>3 安装虚拟环境</h1><ul>
<li>virtualenv，就是一个三方包</li>
<li>安装命令，pip install virtualenv</li>
<li>使用文档，<a href="https://virtualenv.pypa.io/en/stable/userguide/" target="_blank" rel="noopener">https://virtualenv.pypa.io/en/stable/userguide/</a></li>
</ul>
<p>安装过程中，如果出现如下 error 信息是，可以尝试切换源重新下载</p>
<pre><code class="csharp">$ pip install virtualenv -i https://pypi.python.org/simple/                  
Looking in indexes: https://pypi.python.org/simple/
Collecting virtualenv
  Downloading https://files.pythonhosted.org/packages/b6/30/96a02b2287098b23b875bc8c2f58071c35d2efe84f747b64d523721dc2b5/virtualenv-16.0.0-py2.py3-none-any.whl (1.9MB)
    4% |█▌                              | 92kB 2.7kB/s eta 0:11:08Exception:
Traceback (most recent call last):
 ....
pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=&#39;files.pythonhosted.org&#39;, port=443): Read timed out.</code></pre>
<p>清华源，可以</p>
<pre><code class="cpp">$ pip install virtualenv -i https://pypi.tuna.tsinghua.edu.cn/simple/      
Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple/
Collecting virtualenv
  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/ed/ea/e20b5cbebf45d3096e8138ab74eda139595d827677f38e9dd543e6015bdf/virtualenv-15.2.0-py2.py3-none-any.whl (2.6MB)
    100% |████████████████████████████████| 2.6MB 4.1MB/s
Installing collected packages: virtualenv
Successfully installed virtualenv-15.2.0</code></pre>
<h1 id="4-使用虚拟环境"><a href="#4-使用虚拟环境" class="headerlink" title="4 使用虚拟环境"></a>4 使用虚拟环境</h1><h2 id="4-1-创建一个局部的隔离的虚拟环境"><a href="#4-1-创建一个局部的隔离的虚拟环境" class="headerlink" title="4.1 创建一个局部的隔离的虚拟环境"></a>4.1 创建一个局部的隔离的虚拟环境</h2><h3 id="4-1-1-创建命令：virtualenv-虚拟环境名称"><a href="#4-1-1-创建命令：virtualenv-虚拟环境名称" class="headerlink" title="4.1.1 创建命令：virtualenv 虚拟环境名称"></a>4.1.1 创建命令：virtualenv 虚拟环境名称</h3><pre><code class="undefined">virtualenv ENV</code></pre>
<ul>
<li>cd 到存放虚拟环境的的地址</li>
<li>执行命令virtualenv ENV，创建名为ENV 的虚拟环境</li>
</ul>
<pre><code class="bash">% cd /Users/xxx/Desktop/testvirtuals                    

% virtualenv virtual1                   
Using base prefix &#39;/usr/local/Cellar/python3/3.6.4_1/Frameworks/Python.framework/Versions/3.6&#39;
New python executable in /Users/xxx/Desktop/testvirtuals/virtual1/bin/python3.6
Also creating executable in /Users/xxx/Desktop/testvirtuals/virtual1/bin/python
Installing setuptools, pip, wheel...done.</code></pre>
<p>创建虚拟环境结果</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-6999784eb34dd793.png?imageMogr2/auto-orient/strip|imageView2/2/w/818/format/webp</p>
<p>注意：</p>
<ul>
<li><code>Using base prefix</code> 使用的是3.6版本环境，原因是 virtualenv 安装位置就在3.6下，所以默认使用的是其安装位置版本的 Python 环境</li>
<li>虚拟环境文件包括：Python解析器，包管理工具(setuptools, pip, wheel)，三方包等</li>
<li>即使创建的 bin 脚本命令集含有 python 和 python3两个脚本，实际它们的版本都是3.6，这个防止使用者理解不足导致已为使用 python 命令时是使用 Python2.x 版本。</li>
</ul>
<pre><code class="jsx">% /Users/xxx/Desktop/testvirtuals/virtual1/bin/python3 --version
Python 3.6.4

% /Users/xxx/Desktop/testvirtuals/virtual1/bin/python --version
Python 3.6.4</code></pre>
<h3 id="4-1-2-指定-Python-版本创建虚拟环境"><a href="#4-1-2-指定-Python-版本创建虚拟环境" class="headerlink" title="4.1.2 指定 Python 版本创建虚拟环境"></a>4.1.2 指定 Python 版本创建虚拟环境</h3><p>可选参数：-p<br> 指定 Python2.x 版本创建虚拟环境</p>
<pre><code class="bash">virtualenv -p /usr/local/bin/python2.7 testvirtual2</code></pre>
<p>执行效果</p>
<pre><code class="bash">$ virtualenv -p /usr/local/bin/python2.7 ENV
Running virtualenv with interpreter /usr/local/bin/python2.7
New python executable in /Users/minyu_leung/Desktop/virtual2/ENV/bin/python2.7
Also creating executable in /Users/minyu_leung/Desktop/virtual2/ENV/bin/python
Installing setuptools, pip, wheel...done.</code></pre>
<h3 id="4-1-3-是否继承系统三方库-system-site-packages"><a href="#4-1-3-是否继承系统三方库-system-site-packages" class="headerlink" title="4.1.3 是否继承系统三方库 --system-site-packages"></a>4.1.3 是否继承系统三方库 <code>--system-site-packages</code></h3><p>添加参数<code>--system-site-packages</code>，项目检索库的时候，也会到系统的三方库中找<br> 不添加时，默认只到虚拟环境中查找库</p>
<pre><code class="undefined">virtualenv --system-site-packages ENV</code></pre>
<h2 id="4-2-激活-退出-虚拟环境"><a href="#4-2-激活-退出-虚拟环境" class="headerlink" title="4.2 激活/退出 虚拟环境"></a>4.2 激活/退出 虚拟环境</h2><p>在 Mac 下，激活所创建的虚拟环境步骤：</p>
<ol>
<li>cd 到虚拟环境文件夹目录</li>
</ol>
<pre><code class="bash">cd /Users/xxx/Desktop/testvirtuals/virtual1</code></pre>
<ol>
<li>执行命令 source bin/activate，shell 会打印出已激活的虚拟环境名称</li>
</ol>
<pre><code class="bash">$ source bin/activate
(virtual1)</code></pre>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-f0e1aeda8aa76b6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/977/format/webp</p>
<p>带 source 命令</p>
<ol>
<li><p>验证当前确实在已激活的虚拟环境中，执行命令 pip –version 和 pip list</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-6cbe76da12ffc2e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1118/format/webp</p>
<p>每次打印后都会提示(virtual1)，所在环境是虚拟环境</p>
</li>
<li><p>退出虚拟环境，在激活的虚拟环境中，执行命令 deactivate</p>
</li>
</ol>
<pre><code class="ruby">$ deactivate</code></pre>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-96810edb63e6c71e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1018/format/webp</p>
<p>注意，不用带 source 命令</p>
<ol>
<li><p>验证已经退出，执行命令 pip –version 和 pip list</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-acc089c067eaba88.png?imageMogr2/auto-orient/strip|imageView2/2/w/1020/format/webp</p>
<p>结果都是来自系统环境</p>
</li>
<li><p>注意：如果系统是 Windows 的话，则不需要带上 source 命令，直接 cd 进入Scripts脚本文件夹中，然后执行 activate 和 deactivate 脚本即可。与 Mac 不同的是，虚拟环境的 bin 目录下只有 activate 脚本，没有 deactivate 脚本。</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-d1b30e5a43c651cf.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/775/format/webp</p>
<p>Windows 下的虚拟环境 Scripts 文件夹文件目录</p>
</li>
</ol>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-a37973ef28926b56.png?imageMogr2/auto-orient/strip|imageView2/2/w/633/format/webp</p>
<p>Mac 虚拟环境 bin 目录文件</p>
<p><a href="https://virtualenv.pypa.io/en/stable/userguide/" target="_blank" rel="noopener">使用文档</a>中也有说 source 使用原因：</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-2bfe425e8159747b.png?imageMogr2/auto-orient/strip|imageView2/2/w/777/format/webp</p>
<h2 id="4-3-在激活状态下，操作"><a href="#4-3-在激活状态下，操作" class="headerlink" title="4.3 在激活状态下，操作"></a>4.3 在激活状态下，操作</h2><ol>
<li>操作三方块<br> pip install requests</li>
<li>执行 py 文件<br> python xx.py</li>
</ol>
<p>以上操作均作用在虚拟环境中。</p>
<h2 id="4-4-删除虚拟环境"><a href="#4-4-删除虚拟环境" class="headerlink" title="4.4 删除虚拟环境"></a>4.4 删除虚拟环境</h2><ul>
<li>直接删除虚拟环境所在目录即</li>
</ul>
<h2 id="4-5-项目交接"><a href="#4-5-项目交接" class="headerlink" title="4.5 项目交接"></a>4.5 项目交接</h2><p>场景：确保共享的项目能够在其他电脑上正常运行<br> 解决：</p>
<ol>
<li>方案一：</li>
</ol>
<ul>
<li>连同虚拟环境和项目一起拷贝给他人</li>
</ul>
<ol>
<li>方案二：</li>
</ol>
<ul>
<li>在虚拟环境中，冻结依赖需求文本</li>
<li>把项目和依赖需求文本给他人</li>
<li>他人在本地创建一个新的虚拟环境，并根据依赖需求文本安装相关库</li>
</ul>
<p><strong>技能点</strong>：</p>
<ul>
<li>虚拟环境的创建</li>
<li>虚拟环境的激活</li>
<li>操作虚拟环境</li>
<li>冻结项目需求文本 pip freeze &gt; requirements.txt</li>
<li>根据需求文本，安装项目依赖库 pip install -r requirements.txt （在激活的虚拟环境中）</li>
</ul>
<h1 id="5-Pycharm-中使用虚拟环境"><a href="#5-Pycharm-中使用虚拟环境" class="headerlink" title="5 Pycharm 中使用虚拟环境"></a>5 Pycharm 中使用虚拟环境</h1><ol>
<li><p>创建项目</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-96770a324e09b1c8.png?imageMogr2/auto-orient/strip|imageView2/2/w/779/format/webp</p>
</li>
<li><p>在创建项目时，使用虚拟环境</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-f386466e4e33fa57.png?imageMogr2/auto-orient/strip|imageView2/2/w/862/format/webp</p>
</li>
</ol>
<p>创建后，目录结构</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-4438a8e2c308b040.png?imageMogr2/auto-orient/strip|imageView2/2/w/593/format/webp</p>
<ol>
<li><p>在项目偏好设置里可以切换环境和安装需要的库</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-25d73f4640a84b5a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1001/format/webp</p>
</li>
</ol>
<p>总结：<br> IDE 让虚拟环境的使用更加方便，图形化创建和切换，包的管理等。让程序员更关注项目的开发而非各种命令的记忆。</p>
<h1 id="6-虚拟环境进阶使用"><a href="#6-虚拟环境进阶使用" class="headerlink" title="6 虚拟环境进阶使用"></a>6 虚拟环境进阶使用</h1><h2 id="6-1-集中式虚拟环境管理"><a href="#6-1-集中式虚拟环境管理" class="headerlink" title="6.1 集中式虚拟环境管理"></a>6.1 集中式虚拟环境管理</h2><p><a href="https://pypi.org/project/virtualenvwrapper/" target="_blank" rel="noopener">virtualenvwrapper</a><br> <a href="https://virtualenvwrapper.readthedocs.io/en/latest/" target="_blank" rel="noopener">使用文档</a></p>
<ol>
<li>通过virtualenvwrapper创建的虚拟环境都会统一存放到指定位置统一管理</li>
<li>方便在多个虚拟环境间切换</li>
<li>更加方便的去使用 virtualenv</li>
</ol>
<ul>
<li>快速创建虚拟环境并激活</li>
</ul>
<pre><code class="undefined">mkvirtualenv venv1</code></pre>
<ul>
<li>快速在多个虚拟环境中切换</li>
</ul>
<pre><code class="undefined">workon venv2</code></pre>
<ul>
<li>快速关闭虚拟环境</li>
</ul>
<pre><code class="undefined">deactivate</code></pre>
<ul>
<li>快速删除虚拟环境</li>
</ul>
<pre><code class="undefined">rmvirtualenv env1</code></pre>
<ul>
<li>查看所有创建的虚拟环境</li>
</ul>
<pre><code class="undefined">lsvirtualenv</code></pre>
<p><strong>弊端</strong></p>
<ul>
<li>只是对 virtualenv 的使用封装，包的安装及虚拟环境的操作依然是分离的。</li>
<li>并未具备对项目包的依赖管理及需求文本的生成操作封装</li>
</ul>
<h2 id="6-2-更加基于项目的虚拟环境管理"><a href="#6-2-更加基于项目的虚拟环境管理" class="headerlink" title="6.2 更加基于项目的虚拟环境管理"></a>6.2 更加基于项目的虚拟环境管理</h2><h3 id="6-2-1-pipenv-使用优点"><a href="#6-2-1-pipenv-使用优点" class="headerlink" title="6.2.1 pipenv 使用优点"></a>6.2.1 pipenv 使用优点</h3><ol>
<li>推荐使用：<a href="https://pypi.org/project/pipenv/" target="_blank" rel="noopener">pipenv</a>，是  pip + virtualenv 结合体，解决了virtualenvwrapper弊端</li>
<li>会自动帮你创建虚拟环境，以及安装三方库</li>
<li>会自动的记录你的项目依赖的所有三方库</li>
<li>使用 pipfile 和 pipfile.lock取代了 requirements.txt</li>
</ol>
<p><a href="https://pypi.org/project/pipenv/" target="_blank" rel="noopener">使用文档</a><br> <a href="https://pypi.org/project/pipenv/" target="_blank" rel="noopener">使用文档2</a></p>
<p>pipenv 命令使用一览</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-2a8f6aae311ed8f7.png?imageMogr2/auto-orient/strip|imageView2/2/w/1113/format/webp</p>
<blockquote>
<p>pipenv 命令都是参照项目中的 Pipfile 位置和内容操作的，类似 cocoapods 的 pod 命令参照podfile文件操作。</p>
</blockquote>
<h3 id="6-2-2-使用步骤"><a href="#6-2-2-使用步骤" class="headerlink" title="6.2.2 使用步骤"></a>6.2.2 使用步骤</h3><h3 id="6-2-2-1-创建虚拟环境"><a href="#6-2-2-1-创建虚拟环境" class="headerlink" title="6.2.2.1 创建虚拟环境"></a>6.2.2.1 创建虚拟环境</h3><pre><code class="bash">1. cd 到项目文件夹目录下
2. 在该目录下执行命令
pipenv --two # 指定参照Python版本
或
pipenv --three

3. 查看相关信息
查看位置：pipenv --where
查看虚拟环境位置：pipenv --venv
查看解析器信息：pipenv --py</code></pre>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-d7b94c520db1c332.png?imageMogr2/auto-orient/strip|imageView2/2/w/885/format/webp</p>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-91582750ee430c67.png?imageMogr2/auto-orient/strip|imageView2/2/w/469/format/webp</p>
<h3 id="6-2-2-2-激活虚拟环境"><a href="#6-2-2-2-激活虚拟环境" class="headerlink" title="6.2.2.2 激活虚拟环境"></a>6.2.2.2 激活虚拟环境</h3><pre><code class="undefined">pipenv shell</code></pre>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-6a4c448fb9c3d051.png?imageMogr2/auto-orient/strip|imageView2/2/w/1119/format/webp</p>
<h3 id="6-2-2-3-在激活状态下操作"><a href="#6-2-2-3-在激活状态下操作" class="headerlink" title="6.2.2.3 在激活状态下操作"></a>6.2.2.3 在激活状态下操作</h3><ol>
<li>执行 py 文件，python xx.py ，其中 python 指的是虚拟环境 Python版本</li>
<li>安装包</li>
</ol>
<pre><code class="undefined">pipenv install requests</code></pre>
<blockquote>
<p>注意：不要使用 pip install 命令，使用的话虽然可以在虚拟环境中安装对应的包，但是不会更新 PIPfile 和 PIPfile.lock</p>
</blockquote>
<blockquote>
<p>命令：pipenv install [三方库名]<br> 作用：<br> 一、检测当前项目对应的虚拟环境是否存在，不存在则创建。如果当前项目已经存在 Pipfile 和 Pipfile.lock 文件，则参照这两个文件内容创建虚拟环境并安装文件指定的三方库<br> 二、在虚拟环境中安装指定三方库，如果没有指定，则不安装<br> 三、在项目目录下，通过 Pipfile 和 Pipfile.lock 记录当下已经安装的三方库信息</p>
</blockquote>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-691e4b565fd095f3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1127/format/webp</p>
<ol>
<li>查看包的依赖结构</li>
</ol>
<pre><code class="undefined">pipenv graph</code></pre>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-71f4e8995bf218ae.png?imageMogr2/auto-orient/strip|imageView2/2/w/1117/format/webp</p>
<ol>
<li>卸载包</li>
</ol>
<pre><code class="undefined">pipenv uninstall requests</code></pre>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-255f64f0d028c0f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1117/format/webp</p>
<h3 id="6-2-2-4-退出虚拟环境"><a href="#6-2-2-4-退出虚拟环境" class="headerlink" title="6.2.2.4 退出虚拟环境"></a>6.2.2.4 退出虚拟环境</h3><pre><code class="bash">exit
或
直接关闭 shell 窗口</code></pre>
<h3 id="6-2-2-5-删除虚拟环境"><a href="#6-2-2-5-删除虚拟环境" class="headerlink" title="6.2.2.5 删除虚拟环境"></a>6.2.2.5 删除虚拟环境</h3><pre><code class="bash">先 cd 进入 Pipfile 文件目录位置
pipenv --rm</code></pre>
<p>![img](https:////upload-images.jianshu.io/upload_images/748014-0bf378bb4f9a5356.png?imageMogr2/auto-orient/strip|imageView2/2/w/907/format/webp</p>
<h2 id="6-3-项目交接"><a href="#6-3-项目交接" class="headerlink" title="6.3 项目交接"></a>6.3 项目交接</h2><h3 id="6-3-1-上传项目时，应该包含的文件有？"><a href="#6-3-1-上传项目时，应该包含的文件有？" class="headerlink" title="6.3.1 上传项目时，应该包含的文件有？"></a>6.3.1 上传项目时，应该包含的文件有？</h3><p>应该包括文件有：</p>
<ol>
<li>包和模块源码</li>
<li>Pipfile 和 Pipfile.lock</li>
</ol>
<h3 id="6-3-2-拿到共享的项目后如何操作？"><a href="#6-3-2-拿到共享的项目后如何操作？" class="headerlink" title="6.3.2 拿到共享的项目后如何操作？"></a>6.3.2 拿到共享的项目后如何操作？</h3><p>操作步骤：</p>
<ol>
<li>cd 进入获取的项目文件夹目录内</li>
<li>检查项目是否具有Pipfile 和 Pipfile.lock 文件 （此处应该是必须有的，因为是执行上述分享操作的人给你的项目嘛♪(∇*)啦啦）</li>
<li>执行命令：</li>
</ol>
<pre><code class="undefined">pipenv install</code></pre>
]]></content>
  </entry>
  <entry>
    <title>爬图片素材</title>
    <url>/2020/04/01/%E7%88%AC%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import os</span><br><span class="line">import urllib</span><br><span class="line"></span><br><span class="line">headers&#x3D;&#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.130 Safari&#x2F;537.36&#39;&#125;</span><br><span class="line"></span><br><span class="line">response&#x3D;requests.get(&#39;https:&#x2F;&#x2F;www.vmgirls.com&#x2F;12985.html&#39;,headers&#x3D;headers)</span><br><span class="line"># print(response.request.headers)</span><br><span class="line">html&#x3D;response.text</span><br><span class="line"># 文件夹</span><br><span class="line">dir_name&#x3D;re.findall(&#39;&lt;h1 class&#x3D;&quot;post-title h3&quot;&gt;(.*?)&lt;&#x2F;h1&gt;&#39;,html)[-1]</span><br><span class="line"></span><br><span class="line">if not os.path.exists(dir_name):</span><br><span class="line">    os.mkdir(dir_name)</span><br><span class="line"></span><br><span class="line">urls&#x3D;re.findall(&#39;&lt;a href&#x3D;&quot;(.*?)&quot; alt&#x3D;&quot;.*?&quot; title&#x3D;&quot;.*?&quot;&gt;&#39;,html)</span><br><span class="line">print(urls)</span><br><span class="line"></span><br><span class="line">for url in urls:</span><br><span class="line">    file_name&#x3D;url.split(&#39;&#x2F;&#39;)[-1]</span><br><span class="line">    response&#x3D;requests.get(url,headers&#x3D;headers)</span><br><span class="line">    with open(dir_name+&#39;&#x2F;&#39;+file_name,&#39;wb&#39;)as f:</span><br><span class="line">        f.write(response.content)</span><br></pre></td></tr></table></figure>

<p><img src="9F2A3DC5A9D149FE8277BAB068E2205C" alt="image"></p>
]]></content>
  </entry>
  <entry>
    <title>Python中的正则表达式</title>
    <url>/2020/03/30/Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="元字符和语法"><a href="#元字符和语法" class="headerlink" title="元字符和语法"></a>元字符和语法</h1><table>
<thead>
<tr>
<th align="center">实例</th>
<th align="center">匹配串</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a.c</td>
<td align="center">abc</td>
</tr>
<tr>
<td align="center">a\.c</td>
<td align="center">a.c</td>
</tr>
<tr>
<td align="center">a[jq]k</td>
<td align="center">ajk&amp;aqk</td>
</tr>
<tr>
<td align="center">a\dc</td>
<td align="center">a1c</td>
</tr>
<tr>
<td align="center">a\Dc</td>
<td align="center">abc</td>
</tr>
<tr>
<td align="center">a\s</td>
<td align="center">a s</td>
</tr>
<tr>
<td align="center">a*</td>
<td align="center">a&amp;aaaaaaaa….</td>
</tr>
<tr>
<td align="center">a+</td>
<td align="center">aa&amp;aaaa…</td>
</tr>
<tr>
<td align="center">a?</td>
<td align="center">前一个字符0&amp;1次</td>
</tr>
<tr>
<td align="center">a{m}</td>
<td align="center">a后m个a</td>
</tr>
<tr>
<td align="center">{mn}</td>
<td align="center">m到n个前一字符</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">匹配每一行的开头</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">匹配每一行的末尾</td>
</tr>
<tr>
<td align="center">\A&amp;\Z</td>
<td align="center">仅匹配开头&amp;结尾</td>
</tr>
<tr>
<td align="center">## 逻辑与分组</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">…..</th>
<th align="center">…….</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="center">左右任意匹配一个（从左到右）</td>
</tr>
<tr>
<td align="center">a(12|34)c</td>
<td align="center">a34c</td>
</tr>
<tr>
<td align="center">(?#)</td>
<td align="center">忽略#后</td>
</tr>
<tr>
<td align="center">(?!=…)</td>
<td align="center">后面不是..</td>
</tr>
<tr>
<td align="center">(?&lt;=…)</td>
<td align="center">之前是…</td>
</tr>
</tbody></table>
<h2 id="烦人的反斜杠"><a href="#烦人的反斜杠" class="headerlink" title="烦人的反斜杠"></a>烦人的反斜杠</h2><p>原生字符串“ ”直观的解决了问题</p>
<h2 id="RE模块"><a href="#RE模块" class="headerlink" title="RE模块"></a>RE模块</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># encoding: UTF-8</span><br><span class="line">import re</span><br><span class="line"> </span><br><span class="line"># 将正则表达式编译成Pattern对象</span><br><span class="line">pattern &#x3D; re.compile(r&#39;hello&#39;)</span><br><span class="line"> </span><br><span class="line"># 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None</span><br><span class="line">match &#x3D; pattern.match(&#39;hello world!&#39;)</span><br><span class="line"> </span><br><span class="line">if match:</span><br><span class="line">    # 使用Match获得分组信息</span><br><span class="line">    print match.group()</span><br><span class="line"> </span><br><span class="line">### 输出 ###</span><br><span class="line"># hello</span><br></pre></td></tr></table></figure>
<h3 id="re-compile-strPattern-flag"><a href="#re-compile-strPattern-flag" class="headerlink" title="re.compile(strPattern[, flag]):"></a>re.compile(strPattern[, flag]):</h3><p>这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。 第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。<br>可选值有：</p>
<ul>
<li>re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）</li>
<li>M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）</li>
<li>S(DOTALL): 点任意匹配模式，改变’.’的行为</li>
<li>L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定</li>
<li>U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性</li>
<li>X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; re.compile(r&quot;&quot;&quot;\d +  # the integral part</span><br><span class="line">                   \.    # the decimal point</span><br><span class="line">                   \d *  # some fractional digits&quot;&quot;&quot;, re.X)</span><br><span class="line">b &#x3D; re.compile(r&quot;\d+\.\d*&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p>
<p><strong>属性</strong>：</p>
<ul>
<li><strong>string</strong>: 匹配时使用的文本。</li>
<li><strong>re</strong>: 匹配时使用的Pattern对象。</li>
<li><strong>pos</strong>: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</li>
<li><strong>endpos</strong>: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</li>
<li><strong>lastindex</strong>: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。</li>
<li><strong>lastgroup</strong>: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。</li>
</ul>
<p><strong>方法</strong>：</p>
<ul>
<li><p><strong>group</strong>([group1, …]):<br>获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。</p>
</li>
<li><p><strong>groups([default])</strong>:<br>以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。</p>
</li>
<li><p><strong>groupdict</strong>([default]):<br>返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。</p>
</li>
<li><p><strong>start([group])</strong>:<br>返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。</p>
</li>
<li><p><strong>end([group])</strong>:<br>返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。</p>
</li>
<li><p><strong>span([group])</strong>:<br>返回(start(group), end(group))。</p>
</li>
<li><p><strong>expand</strong>(template):<br>将匹配到的分组代入template中然后返回。template中可以使用\id或\g<id>、\g<name>引用分组，但不能使用编号0。\id与\g<id>是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符’0’，只能使用\g&lt;1&gt;0。</p>
</li>
</ul>
<h4 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h4><p>Pattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">p &#x3D; re.compile(r&#39;(\w+) (\w+)(?P&lt;sign&gt;.*)&#39;, re.DOTALL)</span><br><span class="line"> </span><br><span class="line">print &quot;p.pattern:&quot;, p.pattern</span><br><span class="line">print &quot;p.flags:&quot;, p.flags</span><br><span class="line">print &quot;p.groups:&quot;, p.groups</span><br><span class="line">print &quot;p.groupindex:&quot;, p.groupindex</span><br><span class="line"> </span><br><span class="line">### output ###</span><br><span class="line"># p.pattern: (\w+) (\w+)(?P&lt;sign&gt;.*)</span><br><span class="line"># p.flags: 16</span><br><span class="line"># p.groups: 3</span><br><span class="line"># p.groupindex: &#123;&#39;sign&#39;: 3&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是Python对于正则表达式的支持 qwq !!</p>
]]></content>
  </entry>
  <entry>
    <title>python环境变量升级</title>
    <url>/2020/03/27/python%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>默认安装路径：C:\python35</code></pre><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>【在第二个内容框中找到 变量名为Path 的一行，双击<br> Python安装目录追加到变值值中，用 ； 分割</p>
<p> 如：原来的值;C:\python35，切记前面有分号</p>
<p>(备注：默认安装时会自动添加环境变量)</p>
<h1 id="要临时设置环境变量"><a href="#要临时设置环境变量" class="headerlink" title="要临时设置环境变量"></a>要临时设置环境变量</h1><p> 打开命令提示符并使用 set 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\&gt;set PATH&#x3D;C:\Program Files\Python 3.8;%PATH%</span><br><span class="line">C:\&gt;set PYTHONPATH&#x3D;%PYTHONPATH%;C:\My_python_lib</span><br><span class="line">C:\&gt;python要永久修改默认环境变量，请单击“开始”并搜索“编辑环境变量”，或打开“系统属性” Advanced system settings ，然后单击 Environment Variables 按钮。在此对话框中，您可以添加或修改用户和系统变量。要更改系统变量，您需要对计算机进行无限制访问（即管理员权限）。</span><br></pre></td></tr></table></figure>
<p>由该控制台启动的任何应用程序都继承设这些设置。</p>
<h1 id="要永久修改默认环境变量"><a href="#要永久修改默认环境变量" class="headerlink" title="要永久修改默认环境变量"></a>要永久修改默认环境变量</h1><p>  单击“开始”并搜索“编辑环境变量”，或打开“系统属性” Advanced system settings ，然后单击 Environment Variables 按钮。在此对话框中，您可以添加或修改用户和系统变量。要更改系统变量，您需要对计算机进行无限制访问（即管理员权限）。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Windows会将用户变量串联的系统变量 之后 ，这可能会在修改 PATH 时导致意外结果。<br>PYTHONPATH 变量被Python 2和Python 3的所有版本使用，因此除非它只包含与所有已安装的Python版本兼容的代码，否则不要永久配置此变量。</p>
]]></content>
  </entry>
  <entry>
    <title>virtualenv的安装</title>
    <url>/2020/03/27/virtualenv%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>使各应用有“独立”的Python运行环境</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>$ pip3 install virtualen</p>
<h1 id="开始项目"><a href="#开始项目" class="headerlink" title="开始项目"></a>开始项目</h1><h2 id="第一步（创建目录"><a href="#第一步（创建目录" class="headerlink" title="第一步（创建目录)"></a>第一步（创建目录)</h2><p>mkdir myproject<br>cd myproject/</p>
<h2 id="第二步（创建一个独立的Python运行环境，命名为venv：）"><a href="#第二步（创建一个独立的Python运行环境，命名为venv：）" class="headerlink" title="第二步（创建一个独立的Python运行环境，命名为venv：）"></a>第二步（创建一个独立的Python运行环境，命名为venv：）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mac:myproject michael$ virtualenv --no-site-packages venv</span><br><span class="line">Using base prefix &#39;&#x2F;usr&#x2F;local&#x2F;...&#x2F;Python.framework&#x2F;Versions&#x2F;3.4&#39;</span><br><span class="line">New python executable in venv&#x2F;bin&#x2F;python3.4</span><br><span class="line">Also creating executable in venv&#x2F;bin&#x2F;python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure>

<p>命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数–no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。</p>
<p>新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境，可以用source进入该环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mac:myproject michael$ source venv&#x2F;bin&#x2F;activate</span><br><span class="line">(venv)Mac:myproject michael$</span><br></pre></td></tr></table></figure>
<p>有个(venv)前缀，表示当前环境是一个名为venv的Python环境。</p>
<p>在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响。也就是说，venv环境是专门针对myproject这个应用创建的。</p>
<p>退出当前的venv环境，使用deactivate命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(venv)Mac:myproject michael$ deactivate </span><br><span class="line">Mac:myproject michael$</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>网络</title>
    <url>/2020/03/26/%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h1><p>应用层<br>表示层<br>会话层<br>传输层<br>网络层<br>数据链路层<br>物理层</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="tcp-ip"><a href="#tcp-ip" class="headerlink" title="tcp ip"></a>tcp ip</h2><p>TCP/IP协议涵盖了OSI参考模型的第三层、第四层，即网络层、传输层。TCP/IP也不是只有TCP + IP这两种协议，它是协议栈的统称，它还包括 ARP，ICMP，IGMP，UDP，以及让域名访问成为可能的DNS，以及电脑/手机可以自动获取IP地址的DHCP。当然还有形形色色的应用层的协议如 HTTP / SMTP / FTP 等。</p>
<p>《TCP/IP协议》详解卷一，是一本很好的教材，一条消息竟然双向耗费9个包，仅仅是调用一次connect（）建立连接，调用一次 send（），然后程序退出。</p>
<p>TCP建立连接<br>看TCP如何建立连接，建立连接需要三个包的交互，这个应该是connect()完成的。</p>
<p>TCP发送数据<br>然后看到自己的消息内容是一个包，对方没有数据，只有确认ACK，这是两个包，这个由 send () 触发。</p>
<p>TCP释放连接<br>然后系统自动退出，虽然我的程序没有调用什么函数，但是系统自动帮我调用了 close () 函数，于是又触发了TCP 关闭连接，这是四个包。</p>
<p>试用UDP socket 编写聊天程序，直接调用一个函数Sendto() 就可以了（用IP访问），抓包一看，一个消息就是一个包，对方也没有确认，UDP就是加上一个封装头就出去了，不需要建立连接，自然也无需关闭连接。</p>
]]></content>
  </entry>
</search>
