<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python面试题前22道</title>
    <link href="/2020/04/19/Python%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%8D22%E9%81%93/"/>
    <url>/2020/04/19/Python%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%8D22%E9%81%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Python面试题"><a href="#Python面试题" class="headerlink" title="Python面试题"></a>Python面试题</h1><p><strong>1、一行代码实现1–100之和</strong></p><p>利用sum()函数求和</p><blockquote><blockquote><blockquote><p>sum(range(0,101))<br>5050</p></blockquote></blockquote></blockquote><p><strong>2、如何在一个函数内部修改全局变量</strong></p><p>利用global 修改全局变量</p><h5 id="3、列出5个python标准库"><a href="#3、列出5个python标准库" class="headerlink" title="3、列出5个python标准库"></a><strong>3</strong>、列出5个python标准库</h5><p>os：提供了不少与操作系统相关联的函数</p><p>sys: 通常用于命令行参数</p><p>re: 正则匹配</p><p>math: 数学运算</p><p>datetime:处理日期时间</p><h5 id="4、字典如何删除键和合并两个字典"><a href="#4、字典如何删除键和合并两个字典" class="headerlink" title="4、字典如何删除键和合并两个字典"></a>4、字典如何删除键和合并两个字典</h5><p>del和update方法</p><pre><code>del dic[&quot;&quot;]dic.update(dic2)</code></pre><h5 id="5、谈下python的GIL"><a href="#5、谈下python的GIL" class="headerlink" title="5、谈下python的GIL"></a>5、谈下python的GIL</h5><p>GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。</p><p>多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大</p><p>   在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。</p><p>  多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低</p><p>  <strong>“python下想要充分利用多核CPU，就用多进程”</strong></p><h5 id="6、python实现列表去重的方法"><a href="#6、python实现列表去重的方法" class="headerlink" title="6、python实现列表去重的方法"></a>6、python实现列表去重的方法</h5><p>先通过集合去重，在转列表</p><pre><code>a=set(list)##转列表 [x for x in a]</code></pre><h5 id="7、fun-args-kwargs-中的args-kwargs什么意思？"><a href="#7、fun-args-kwargs-中的args-kwargs什么意思？" class="headerlink" title="7、fun(args,*kwargs)中的args,*kwargs什么意思？"></a>7、fun(<em>args,*</em>kwargs)中的<em>args,*</em>kwargs什么意思？</h5><p>这就要从函数的参数说起了。函数在传参时通常分为四种情况：</p><p>普通参数，即在调用函数时必须按照准确的顺序来进行参数传递。</p><p>默认参数，即参数含有默认值，在调用函数时可以进行参数传递，若没有进行参数传递则使用默认值，要注意，默认参数必须在普通参数的右侧（否则解释器无法解析）。</p><p>元组参数，即 *args，参数格式化存储在一个元组中，长度没有限制，必须位于普通参数和默认参数之后。</p><p>字典参数，即 **kwargs，参数格式化存储在一个字典中，必须位于参数列表的最后面。</p><p>普通参数实例如下，在调用函数的时候必须传入参数，否则会抛出 TypeError 异常：</p><p>def fun(name):<br>    print ‘Hello’, name</p><p>fun(‘Python’)</p><p>默认参数必须跟在普通参数之后，不能在普通参数之前，默认参数可以传值，也可以不传，不传值时就采用默认参数：</p><p>def fun(base, rate=0.1):<br>    return base + base*rate</p><p>fun(100)<br>fun(100, 0.2)</p><p>元组参数需要跟在普通参数和默认参数的后面，其最大的特点就是不限制长度：</p><p>def fun(arg1, arg2=’Default’, *args):<br>    print ‘arg1:’, arg1<br>    print ‘arg2:’, arg2<br>    for eacharg in args:<br>        print ‘tuple arg:’, eacharg</p><p>fun(‘Python’)<br>fun(‘Python’, ‘Excellent’)<br>fun(‘Python’, ‘Excellent’, ‘I’, ‘Love’, ‘Python’, 100, ‘Years’)</p><p>最后一次调用的结果为：</p><p>arg1: Python</p><p>arg2: Excellent</p><p>tuple arg: I</p><p>tuple arg: Love</p><p>tuple arg: Python</p><p>tuple arg: 100</p><p>tuple arg: Years</p><p>由此可见，元组的长度是不受限制的。</p><p>字典参数必须跟在其它参数后面，并且长度也是不受限制的：</p><p>def fun(arg1, arg2=’Default’, <em>args, *</em>kwargs):<br>    print ‘arg1:’, arg1<br>    print ‘arg2:’, arg2<br>    for eacharg in args:<br>        print ‘tuple arg:’, eacharg</p><pre><code>for eachkwarg in kwargs.keys():    print &#39;dict arg&#39;, eachkwarg, &#39;:&#39;, kwargs[eachkwarg]</code></pre><p>fun(‘Python’, ‘Excellent’, ‘I’, ‘Love’, language=’Python’, number=100, time=’Years’)</p><p>运行的输出结果为：</p><p>arg1: Python</p><p>arg2: Excellent</p><p>tuple arg: I</p><p>tuple arg: Love</p><p>dict arg number : 100</p><p>dict arg language : Python</p><p>dict arg time : Years</p><p>当我们将普通参数和默认参数都放到元组或者字典参数中时，函数的定义就变为仅仅剩余元组参数和字典参数了：</p><pre><code>def fun(*args, **kwargs):    for eacharg in args:        print &#39;tuple arg:&#39;, eacharg        for eachkwarg in kwargs.keys():    print &#39;dict arg&#39;, eachkwarg, &#39;:&#39;, kwargs[eachkwarg]fun(&#39;Python&#39;, &#39;Excellent&#39;, &#39;I&#39;, &#39;Love&#39;, language=&#39;Python&#39;, number=100, time=&#39;Years&#39;)</code></pre><p>这也是很多源码中对函数的定义。运行结果输出为：</p><p>tuple arg: Python</p><p>tuple arg: Excellent</p><p>tuple arg: I</p><p>tuple arg: Love</p><p>dict arg number : 100</p><p>dict arg language : Python</p><p>dict arg time : Years</p><p>所有参数均可以正确获取。</p><h5 id="8、python2和python3的range（100）的区别"><a href="#8、python2和python3的range（100）的区别" class="headerlink" title="8、python2和python3的range（100）的区别"></a>8、python2和python3的range（100）的区别</h5><p>python2返回列表，python3返回迭代器，节约内存</p><p><strong>9、一句话解释什么样的语言能够用装饰器?</strong></p><p>函数可以作为参数传递的语言，可以使用装饰器</p><p><strong>10、python内建数据类型有哪些</strong></p><p>整型–int</p><p>布尔型–bool</p><p>字符串–str</p><p>列表–list</p><p>元组–tuple</p><p>字典–dict</p><p><strong>11、简述面向对象中<strong>new</strong>和<strong>init</strong>区别</strong></p><ul><li><strong>init</strong>是初始化方法，创建对象后，就立刻被默认调用了，可接收参数</li><li><strong>new</strong>至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别</li><li>new必须要有返回值，返回实例化出来的实例，这点在自己实现new时要特别注意，可以return父类（通过super(当前类名, cls)）new出来的实例，或者直接是object的new__出来的实例</li><li>3、<strong>init</strong>有一个参数self，就是这个<strong>new</strong>返回的实例，<strong>init</strong>在<strong>new</strong>的基础上可以完成一些其它初始化的动作，<strong>init</strong>不需要返回值</li><li>4、如果<strong>new</strong>创建的是当前类的实例，会自动调用<strong>init</strong>函数，通过return语句里面调用的<strong>new</strong>函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的<strong>init</strong>函数，也不会调用其他类的<strong>init</strong>函数。**</li></ul><h5 id="12、简述with方法打开处理文件帮我我们做了什么？"><a href="#12、简述with方法打开处理文件帮我我们做了什么？" class="headerlink" title="12、简述with方法打开处理文件帮我我们做了什么？"></a>12、简述with方法打开处理文件帮我我们做了什么？</h5><p>打开文件在进行读写的时候可能会出现一些异常状况，如果按照常规的f.open写法，我们需要try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要执行finally f.close()关闭文件，with方法帮我们实现了finally中f.close</p><h5 id="13、列表-1-2-3-4-5-请使用map-函数输出-1-4-9-16-25-，并使用列表推导式提取出大于10的数，最终输出-16-25"><a href="#13、列表-1-2-3-4-5-请使用map-函数输出-1-4-9-16-25-，并使用列表推导式提取出大于10的数，最终输出-16-25" class="headerlink" title="13、列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]"></a><strong>13</strong>、列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]</h5><p>map（）函数第一个参数是fun，第二个参数是一般是list，第三个参数可以写list，也可以不写，根据需求</p><pre><code>list=[1,2,3,4,5,6]def fn(x):  return x**2  res=map(fn,list)  res=[i for i in res if i&gt;10]  print(res)</code></pre><h5 id="14、python中生成随机整数、随机小数、0–1之间小数方法"><a href="#14、python中生成随机整数、随机小数、0–1之间小数方法" class="headerlink" title="14、python中生成随机整数、随机小数、0–1之间小数方法"></a>14、python中生成随机整数、随机小数、0–1之间小数方法</h5><p>随机整数：random.randint(a,b),生成区间内的整数</p><p>随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数</p><p>0-1随机小数：random.random(),括号中不传参</p><h5 id="15、避免转义给字符串加哪个字母表示原始字符串？"><a href="#15、避免转义给字符串加哪个字母表示原始字符串？" class="headerlink" title="15、避免转义给字符串加哪个字母表示原始字符串？"></a>15、避免转义给字符串加哪个字母表示原始字符串？</h5><p>r , 表示需要原始字符串，不转义特殊字符</p><h5 id="16、-lt-div-class-quot-nam-quot-gt-中国-lt-div-gt-，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的"><a href="#16、-lt-div-class-quot-nam-quot-gt-中国-lt-div-gt-，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的" class="headerlink" title="16、&lt;div class=&quot;nam&quot;&gt;中国&lt;/div&gt;，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的"></a>16、<strong><em><code>&lt;div class=&quot;nam&quot;&gt;中国&lt;/div&gt;</code></em></strong>，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的</h5><pre><code>res=re.findall(r&#39;&lt;div class=&quot;.*&quot;&gt; (.*?)&lt;/div&gt;’,str)</code></pre><h5 id="17、python中断言方法举例"><a href="#17、python中断言方法举例" class="headerlink" title="17、python中断言方法举例"></a>17、python中断言方法举例</h5><p>assert（）方法，断言成功，则程序继续执行，断言失败，则程序报错</p><h5 id="18、数据表student有id-name-score-city字段，其中name中的名字可有重复，需要消除重复行-请写sql语句"><a href="#18、数据表student有id-name-score-city字段，其中name中的名字可有重复，需要消除重复行-请写sql语句" class="headerlink" title="18、数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句"></a>18、数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句</h5><p>select distinct name from student</p><p><strong>19、10个Linux常用命令</strong></p><p>ls pwd cd touch rm mkdir tree cp mv cat more grep echo</p><p><strong>20、python2和python3区别？列举5个</strong></p><ul><li><p>Python3 使用 print 必须要以小括号包裹打印内容，比如 print(‘hi’)</p><p>Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print ‘hi’</p></li><li><p>python2 range(1,10)返回列表，python3中返回迭代器，节约内存</p></li><li><p>python2中使用ascii编码，python中使用utf-8编码</p></li><li><p>python2中unicode表示字符串序列，str表示字节序列</p><p>python3中str表示字符串序列，byte表示字节序列</p></li><li><p>python2中为正常显示中文，引入coding声明，python3中不需要</p></li><li><p>python2中是raw_input()函数，python3中是input()函数</p></li></ul><p><strong>21、列出python中可变数据类型和不可变数据类型，并简述原理</strong></p><p>不可变数据类型：数值型、字符串型string和元组tuple</p><p>  不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址），如下图用id()方法可以打印对象的id</p><p>可变数据类型：列表list和字典dict；</p><p>  允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p><p><strong>22、s = “ajldjlajfdljfddd”，去重并从小到大排序输出”adfjl”</strong></p><p>set去重，去重转成list,利用sort方法排序，reeverse=False是从小到大排</p><p>list是不 变数据类型，s.sort时候没有返回值，所以注释的代码写法不正确</p><pre><code>s = &quot;ajldjlajfdljfddd&quot;S = SET(S)s=list(s)s.sort(reverse=False)res=&quot;&quot;.join(s)rint(res)</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>爬虫的二级代理</title>
    <link href="/2020/04/19/%E7%88%AC%E8%99%AB%E7%9A%84%E4%BA%8C%E7%BA%A7%E4%BB%A3%E7%90%86/"/>
    <url>/2020/04/19/%E7%88%AC%E8%99%AB%E7%9A%84%E4%BA%8C%E7%BA%A7%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理服务器工作原理<br>代理服务器工作原理：</p><p>1、客户端 A 向代理<br>代理服务器工作原理<br>代理服务器工作原理：</p><p>1、客户端 A 向代理服务器发出访问 Internet 的请求 。<br>2、代理服务器接受请求后，首先与访问控制列表中的访问规则相匹配，如果满足规则，则在缓存中查找是否有需要的资源信息。<br>3、如果缓存中存在客户端 A 的请求信息，那么将此信息返回给客户端 A ; 如果没有代理服务器将代替客户端去向 Internet 请求指定的信息。<br>4、Internet 上的主机将请求的信息发送到代理服务器，代理服务器会将信息存入缓存中。<br>5、代理服务器将 Internet 上主机的返回信息传给客户端 A 。<br>6、当客户端 B 也请求相同的信息时。<br>7、代理服务器也会接受请求后，与访问控制列表中的规则相匹配。<br>8、如果满足规则，代理服务器将会把缓存中的信息直接传给客户端 B 。</p><p>代理分类<br>正向代理（控制内网访问互联网）</p><p>反向代理（控制外网访问内网）</p><p>透明代理（不加密的正向代理）</p><p>正向代理<br>代理内部主机上网,共享上网，缓存，控制内网用户上网行为等功能（客户端需要设置代理服务器的IP和代理端口）</p><p>正向代理分析图：<br>        外网<br>         |<br>        modem<br>         |<br>        路由器(dhcp,snat共享上网，上网行为控制，限速等)<br>         |<br>         |<br>     squid正向代理(共享上网，静态页面缓存加速，内网用户四七层上网行为控制，限速等)<br>         |<br>         |<br>    |———————-|<br> 上网用户一            上网用户二</p><pre><code>        公网         ｜         ｜            br0    172.16.13.250        squid 服务器         virbr1    192.168.100.1                    |         |         |            内网用户VM1                             eth0(virbr1)                    192.168.100.128</code></pre><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>从外部网络访问内部服务器，与正向方向相反，主要用于网站架构的缓存加速或CDN</p><pre><code>        client          |          |        反向代理 (缓存加速，七层切分，负载均衡，会话保持等)          ｜          ｜              web</code></pre><h3 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h3><p>和正向代理的功能完全一致（客户端不需要设置代理服务器的IP和代理端口，对用户是透明的）</p><p>参考资料<br><a href="https://www.cnblogs.com/yanjieli/p/7507456.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanjieli/p/7507456.html</a></p><p>Squid<br>概念<br>Squid 是一款缓存代理服务器软件，广泛用于网站的负载均衡架构中，常见的缓存服务器还有varnish、ATS等。</p><p>正向代理服务器可满足内网仅有一台服务器可以上网，而要供内网所有机器上网的需求，也可以用于爬虫的代理访问。在实践中我将Squid作为爬虫代理服务器，实现了多 IP 切换的功能。</p><p>安装<br>yum install -y squid<br>1<br>配置说明<br>配置鉴权<br>yum install httpd</p><h6 id="然后执行如下命令进行生成-用户名和密码，这里的示例为生成一个账号：hello"><a href="#然后执行如下命令进行生成-用户名和密码，这里的示例为生成一个账号：hello" class="headerlink" title="然后执行如下命令进行生成 用户名和密码，这里的示例为生成一个账号：hello"></a>然后执行如下命令进行生成 用户名和密码，这里的示例为生成一个账号：hello</h6><h6 id="执行该命令之后，根据提示输入设置密码"><a href="#执行该命令之后，根据提示输入设置密码" class="headerlink" title="执行该命令之后，根据提示输入设置密码"></a>执行该命令之后，根据提示输入设置密码</h6><p>htpasswd -c /etc/squid/passwd hello</p><p>配置文件<br><code>（/etd/squid/squid.conf）</code></p><p><code>acl all src 0.0.0.0/0.0.0.0     #允许所有IP访问</code><br><code>acl manager proto http        #manager url协议为http</code><br><code>acl localhost src 127.0.0.1/255.255.255.255 #允午本机IP</code><br><code>acl to_localhost dst 127.0.0.1         #允午目的地址为本机IP</code><br><code>acl CONNECT method CONNECT     #请求方法以CONNECT</code></p><p><code>#http_access allow all         #允许所有人使用该代理.</code></p><p><code>#http_reply_access allow all         #允许所有客户端使用该代理</code></p><p><code>acl Safe_ports port 80     # 允许安全更新的端口为80</code><br><code>acl Safe_ports port 443    #允许安全更新的端口为443</code><br><code>acl localnet src 10.195.249.225   #</code><br><code>acl localnet src 10.195.236.141   #</code></p><p><code>http_access allow localnet      #</code><br><code>http_access deny !Safe_ports      #</code></p><p>acl OverConnLimit maxconn 16    #限制每个IP最大允许16个连接，防止攻击</p><p>http_access deny OverConnLimit</p><p>icp_access deny all             #禁止从邻居服务器缓冲内发送和接收ICP请求.<br>miss_access allow all         #允许直接更新请求<br>ident_lookup_access deny all                 #禁止lookup检查DNS<br>http_port 8080 transparent                 #指定Squid监听浏览器客户请求的端口号。</p><p>hierarchy_stoplist cgi-bin ?         #用来强制某些特定的对象不被缓存，主要是处于安全的目的。</p><p>acl QUERY urlpath_regex cgi-bin ?</p><p>cache deny QUERY</p><p>cache_mem 1 GB     #这是一个优化选项，增加该内存值有利于缓存。应该注意的是：</p><pre><code>       \#一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1G</code></pre><p>fqdncache_size 1024    #FQDN 高速缓存大小</p><p>maximum_object_size_in_memory 2 MB     #允许最大的文件载入内存</p><p>memory_replacement_policy heap LFUDA  #动态使用最小的，移出内存cache</p><p>cache_replacement_policy heap LFUDA     #动态使用最小的，移出硬盘cache</p><p>cache_dir ufs /home/cache 5000 32 512 #高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，</p><p>#32个一级目录，512个二级目录</p><p>max_open_disk_fds 0                 #允许最大打开文件数量,0 无限制</p><p>minimum_object_size 1 KB             #允午最小文件请求体大小</p><p>maximum_object_size 20 MB         #允午最大文件请求体大小</p><p>cache_swap_low 90              #最小允许使用swap 90%</p><p>cache_swap_high 95              #最多允许使用swap 95%</p><p>ipcache_size 2048                # IP 地址高速缓存大小 2M<br>ipcache_low 90                #最小允许ipcache使用swap 90%<br>ipcache_high 95                 #最大允许ipcache使用swap 90%</p><p>access_log /var/log/squid/access.log squid     #定义日志存放记录<br>cache_log /var/log/squid/cache.log squid<br>cache_store_log none             #禁止store日志</p><p>emulate_httpd_log on     #将使Squid仿照Web服务器的格式创建访问记录。如果希望使用</p><pre><code>            \#Web访问记录分析程序，就需要设置这个参数。</code></pre><p>refresh_pattern . 0 20% 4320 override-expire override-lastmod reload-into-ims ignore-reload  #更新cache规则</p><p>acl buggy_server url_regex ^http://…. http://      #只允许http的请求broken_posts allow buggy_server</p><p>acl apache rep_header Server ^Apache         #允许apache的编码</p><p>broken_vary_encoding allow apache</p><p>request_entities off                     #禁止非http的标分准请求，防止攻击<br>header_access header allow all             #允许所有的http报头<br>relaxed_header_parser on                 #不严格分析http报头.<br>client_lifetime 120 minute                 #最大客户连接时间 120分钟<br>cache_mgr <a href="mailto:sky@test.com">sky@test.com</a>             #指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。<br>cache_effective_user squid             #这里以用户squid的身份Squid服务器<br>cache_effective_group squid</p><p>icp_port 0            #指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。<br>           #这里设置为0是因为这里配置Squid为内部Web服务器的加速器，<br>           #所以不需要使用邻居服务器的缓冲。0是禁用</p><p># cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1</p><p>cache_peer 127.0.0.1 parent 80 0 no-query default multicast-responder no-netdb-exchange<br>cache_peer_domain 127.0.0.1<br>hostname_aliases 127.0.0.1</p><p>error_directory /usr/share/squid/errors/Simplify_Chinese     #定义错误路径</p><p>always_direct allow all         # cache丢失或不存在是允许所有请求直接转发到原始服务器<br>ignore_unknown_nameservers on     #开反DNS查询，当域名地址不相同时候，禁止访问<br>coredump_dir  /var/log/squid         #定义dump的目录<br>max_filedesc 2048        #最大打开的文件描述</p><p>half_closed_clients off     #使Squid在当read不再返回数据时立即关闭客户端的连接。</p><pre><code>            \#有时read不再返回数据是由于某些客户关闭TCP的发送数据            \#而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。</code></pre><p>squid在做爬虫代理时候，我们只需要做到一个squid代理，然后对其他代理做转发轮询，如何使用squid做代理并</p><p>自动转发轮询？</p><p>加上这行代码：</p><p>cache_peer 120.xx.xx.32 parent 80 0 no-query weighted-round-robin weight=2 connect-fail-limit=2 allow-miss max-conn=5 name=proxy-90<br>1<br>注意，当120.xx.xx.32 是相同 但是端口不同的时候，必须设置不同的name，否则会报错cache_peer 120.xx.xx.32 specified twice 这时候及得设置不同的name。</p><p>配置关键字含义<br>语法是这样的 cache_peer Web服务器地址 服务器类型 http端口 icp端口 [可选项], 可选项包括：</p><p>proxy-only：指明从peer得到的数据在本地不进行缓存，缺省地，squid是要缓存这部分数据的；<br>weight=n：用于你有多个peer的情况，这时如果多于一个以上的peer拥有你请求的数据时，squid通过计算每个peer的ICP响应时间来 决定其weight的值，然后squid向其中拥有最大weight的peer发出ICP请求。也即weight值越大，其优先级越高。当然你也可以手工 指定其weight值；<br>no-query：不向该peer发送ICP请求。如果该peer不可用时，可以使用该选项；<br>Default：有点象路由表中的缺省路由，该peer将被用作最后的尝试手段。当你只有一个父代理服务器并且其不支持ICP协议时，可以使用default和no-query选项让所有请求都发送到该父代理服务器；<br>login=user:password：当你的父代理服务器要求用户认证时可以使用该选项来进行认证。<br>更新完成后保存重启squid，就会发现 squid 已经正常可用了。<br>访问控制<br>squid的acl（access control list)访问控制（下面列举一些常见的控制）</p><p>acl denyip src  192.168.100.128/32     –拒绝内网的192.168.100.128/32上网<br>http_access deny denyip</p><p>acl denyip src 192.168.100.128-192.168.100.132/255.255.255.255<br>http_access deny denyip</p><p>acl vip  arp  00:0C:29:79:0C:1A<br>http_access allow  vip </p><p>acl  baddsturl2  dst   220.11.22.33  –不能访问这个外网IP的网站<br>http_access deny baddsturl2</p><p>acl  baddsturl  dstdomain -i  <a href="http://www.163.com" target="_blank" rel="noopener">www.163.com</a>  –不能访问<a href="http://www.163.com和WWW.163.COM；-i参数定义大小写都匹配；" target="_blank" rel="noopener">www.163.com和WWW.163.COM；-i参数定义大小写都匹配；</a>  但是可以访问war.163.com或sports.163.com<br>http_access deny baddsturl</p><p>acl  baddsturl  dstdom_regex -i  163    –这是把163以下的所有域名都禁止  ，但直接使用IP仍然是可以访问的<br>http_access deny   baddsturl</p><p>acl  baddsturl  dstdom_regex “/etc/squid/baddsturl”  –如果网址太多，可以写成一个文件，然后在这个文件里一行一个网站写上你要禁止的<br>http_access deny baddsturl</p><p>acl baddsturl3  url_regex  -i  baidu   –拒绝访问url里有baidu这个关键字的网站<br>http_access deny baddsturl3</p><p>acl badfile  urlpath_regex -i .mp3$ .rmvb$ .exe$ .zip$ .mp4$ .avi$  .rar$<br>http_access deny badfile    –禁止下载带有定义后缀名的文件</p><p>acl badipclient2  src 192.168.100.0/255.255.255.0<br>acl worktime time  MTWHF 9:00-17:00<br>http_access deny badipclient2 worktime  –拒绝192.168.100.0网段工作时间不能上网</p><p>acl badipclient3  src 192.168.100.128<br>acl conn5  maxconn  5<br>http_access deny badipclient3 conn5    –最大连接数为5</p><p><a href="https://www.cnblogs.com/wangxiaoqiangs/p/5796597.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangxiaoqiangs/p/5796597.html</a></p><p>初始化<br>修改完配置文件之后保存，然后输入以下命令进行初始化 squid</p><p>squid -z<br>1<br>2<br>3<br>问题<br>TCP_MISS/503<br>发现日志中有如下的内容</p><p>1587003941.248      0 172.25.0.1 TCP_MISS/503 4362 GET <a href="http://gtj.hangzhou.gov.cn/col/col1363087/index.html" target="_blank" rel="noopener">http://gtj.hangzhou.gov.cn/col/col1363087/index.html</a> - HIER_NONE/- text/html<br>1587003942.505      0 172.25.0.1 TCP_MISS/503 4362 GET <a href="http://gtj.hangzhou.gov.cn/col/col1363087/index.html" target="_blank" rel="noopener">http://gtj.hangzhou.gov.cn/col/col1363087/index.html</a> - HIER_NONE/- text/html<br>1587003943.779    301 172.25.0.1 TCP_MISS/200 388 GET <a href="http://httpbin.org/ip" target="_blank" rel="noopener">http://httpbin.org/ip</a> - HIER_DIRECT/34.230.193.231 application/json<br>1587003943.899      0 172.25.0.1 TCP_MISS/503 4357 GET <a href="http://gtj.hangzhou.gov.cn/col/col1363087/index.html" target="_blank" rel="noopener">http://gtj.hangzhou.gov.cn/col/col1363087/index.html</a> - HIER_NONE/- text/html<br>1587003945.333      0 172.25.0.1 TCP_MISS/503 4362 GET <a href="http://gtj.hangzhou.gov.cn/col/col1363087/index.html" target="_blank" rel="noopener">http://gtj.hangzhou.gov.cn/col/col1363087/index.html</a> - HIER_NONE/- text/html</p><p>查看到一个关键字TCP_MISS/503</p><p>谷歌之，找到这篇文章：<a href="https://forums.freebsd.org/threads/34184/" target="_blank" rel="noopener">https://forums.freebsd.org/threads/34184/</a></p><p>解决：</p><p>原来是IPv6不支持，按照里面的提示，在/etc/squid/squid.conf里面配置一个dns_v4_first on</p><p>再次尝试的时候可以了！</p><p>如果还是不行的话，直接修改系统的配置</p><p>修改 /etc/sysconfig/network:<br>设置 NETWORKING_IPV6=no</p><p>(最好reboot重启一次)</p><p>参考资料<br><a href="http://cn.linux.vbird.org/linux_server/0420squid.php#server_default" target="_blank" rel="noopener">http://cn.linux.vbird.org/linux_server/0420squid.php#server_default</a></p><p>代理池<br><a href="https://github.com/AaronJny/open_proxy_pool" target="_blank" rel="noopener">https://github.com/AaronJny/open_proxy_pool</a></p><p>配置文件更新程序<br><a href="https://github.com/xNathan/squid_proxy_pool" target="_blank" rel="noopener">https://github.com/xNathan/squid_proxy_pool</a></p><p>上述项目的文档说明</p><p><a href="https://xnathan.com/2017/03/01/squid-anony-proxy/" target="_blank" rel="noopener">https://xnathan.com/2017/03/01/squid-anony-proxy/</a></p><p><a href="https://xnathan.com/2017/02/28/squid-proxy/" target="_blank" rel="noopener">https://xnathan.com/2017/02/28/squid-proxy/</a></p><p><a href="https://xnathan.com/2017/03/02/squid-proxy-pool/" target="_blank" rel="noopener">https://xnathan.com/2017/03/02/squid-proxy-pool/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql的使用</title>
    <link href="/2020/04/18/mysql%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/04/18/mysql%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>mysql 是一门关系型数据库, 不同于mongoDB 来说. mysql 需要给不同的表之间建立相互联系,以便确定完整性约束. 这里我们看看Mysql中常用的基本概念就差不多了.</p><h2 id="mysql常用术语"><a href="#mysql常用术语" class="headerlink" title="mysql常用术语"></a>mysql常用术语</h2><ul><li>冗余: 用来表示存储两倍的数据, 但会使数据访问更快. 相当于redis</li><li>主键: 用来执行每个表的关键性数据, 并且,每个表中只有一个主键.</li><li>外键: 这应该是mysql的关键, 使用外键来关联不同表.</li><li>复合键: 将多个键组合一起来作为索引值. 一般用于复合索引</li><li>索引:借用一组值, 来对表进行排序. 可以比作书的目录.</li><li>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体</li></ul><h2 id="mysql之初命令"><a href="#mysql之初命令" class="headerlink" title="mysql之初命令"></a>mysql之初命令</h2><p>在MAC 上下载mysql 很简单. 直接使用homebrew 即可. 他会帮你把mysql的所有其他东西都完全的安装好. 然后, 就是简单的开关操作.</p><ul><li>开启mysql: mysql.server start</li><li>关闭mysql: mysql.server stop</li><li>打开交互命令: mysql</li></ul><p>OK, 这样就已经满足前期你对mysql的基本要求 如果你想,将你的mysql上锁, 即, 添加登录密码的话, 就可以使用:</p><pre><code class="text">mysqladmin -u root password &quot;new_password&quot;;</code></pre><p>如果你想设置为开启自启的话,可以使用:</p><pre><code class="text">// MACln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents</code></pre><p>其他的自行google把.</p><h2 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h2><p>上述已经提到了, 使用mysql即可连接到数据库. 当你使用mysql进行连接的时候, 这并不是完整意义上的连接, 因为当多人协作的时候,往往一个数据库, 会有很多users进行连接, 而这mysql只是数据库给的一个匿名用户, 如果是单机版的Mysql这样使用当然是最方便的。 另外, 你还可以使用</p><pre><code class="text">mysql -h host -u user -p// 接着输入你的密码</code></pre><p>这里就是比较高级的。 在指定的hostname上使用指定的user进行连接. 有童鞋可能会问了, host和user到底是什么呢？ e… 你可以输入echo $HOST和echo $USER来查看. 当然, 这种方式是最高级的, 也最有可能会遇到这样的problem</p><pre><code class="text"> ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)</code></pre><p>这句话的意思就是, 亲, 你的mysql还没运行呢~</p><p>接着, 我们来看一下稍微简单的调用.你的HOST实际是可以忽略的, 如果你不是远程登录的话. 接着就可以使用一下的命令:</p><pre><code class="text">mysql -u user -p</code></pre><p>其实俺最常用的就是mysql 方便干脆, 不过有时候需要user的时候,还会使用一下mysql -u user -p这样的参数. 如果你想查看你Mysql中,有多少USER的话, 就可以使用, SELECT USER();进行查看.</p><p>如果你在电脑里面有其他的用户需要添加时, 这就需要你进行手动添加用户.</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>在Mysql中添加用户,其实也非常简单, 只需要使用CREATE USER 和 GRANT就可以了。 我们这里创建一个普通用户-jimmy. 然后赋予它一下简单的权限</p><pre><code class="text">CREATE USER &#39;jimmy&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;your_password&#39;;// 创建一个jimmy的用户, 并且, 他的密码为,your_password&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP    -&gt; ON *.*   -&gt; TO &#39;jimmy&#39;@&#39;localhost&#39;;// 赋予jimmy 一些基本的权限, 让他去访问某些执行的数据库, 上文中的`*.*`(注意这不是颜文字, 这表示所有的数据库) 就可以写为你允许该用户访问的数据库的name, 比如, 你可以改为`bank`,`tencent`... 等等</code></pre><p>这样, 你就可以使用mysql -u xxx -p 进行指定用户的登录了. 如果,你想创建一个管理员账户的话, 代码就更简单了。</p><pre><code class="text">CREATE USER &#39;admin&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;your_ps&#39;;// 创建一个管理员账户GRANT ALL PRIVILEGES ON *.* TO &#39;admin&#39;@&#39;localhost&#39; WITH GRANT OPTION;// ok</code></pre><p>如果你想检查, 你创建的用户的权限对不对时, 可以使用.</p><pre><code class="text">SHOW GRANTS FOR &#39;admin&#39;@&#39;localhost&#39;;</code></pre><p>进行查看. 接下来, 假设出现很多bugs. md… 密码写错了,怎么办？ 用户创建错了,怎么办？ 这些,mysql 都已经提供了一些相关的办法.</p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>这里有很多种方法, 简单介绍两种. 一种是使用SET,一种是使用ALERT(v5.7.6).</p><p>SET 修改密码应该算是比较常用的. 使用SET直接修改密码即可. 格式为:</p><pre><code class="text">SET PASSWORD FOR &#39;jimmy&#39;@&#39;localhost&#39; = PASSWORD(&#39;your_ps&#39;);</code></pre><p>上面那种方法,适用于root的用户进行修改, 如果你想修改自己的密码的话,就更简单了. 直接使用.</p><pre><code class="text">SET PASSWORD = PASSWORD(&#39;your_ps&#39;);</code></pre><p>来看一下ALERT的相关语法吧.</p><pre><code class="text">ALERT USER &#39;jimmy&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;your_ps&#39;;</code></pre><p>如果你不想输,‘jimmy’@’localhost 这一串的话, 可以直接使用USER()进行代替.</p><pre><code class="text">ALERT USER USER() IDENTIFIED BY &#39;your_ps&#39;;</code></pre><p>另外, 如果你只想在shell 中直接修改的话,可以直接使用</p><pre><code class="text">mysqladmin -u user_name -h host_name password &quot;new_password&quot;</code></pre><p>直接修改即可.</p><p>如果你连用户都创建错了。 那该怎么办呢？ 删呗.</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>在删之前,你可以看看,mysql中,有多少其他的用户. 一般，mysql创建新用户后, 都会把用户信息放到mysql.user中去.我们来检查一下吧.</p><pre><code class="text">`SELECT User FROM mysql.user</code></pre><p>选择你想要删除的用户名.直接drop就行了.</p><pre><code class="text">DROP USER &#39;jimmy&#39;@&#39;localhost&#39;;</code></pre><h2 id="语句格式"><a href="#语句格式" class="headerlink" title="语句格式"></a>语句格式</h2><p>在sql中, 每条语句都是以;(semicolon)结尾。这里简单演示一下, 如果你想查看mysql的版本号， 或者日期时间的话，可以使用.</p><pre><code class="text">SELECT VERSION(),CURRENT_DATE;// 返回数据+-----------+--------------+| version() | current_date |+-----------+--------------+| 5.7.11    | 2016-07-02   |+-----------+--------------+1 row in set (0.00 sec)</code></pre><p>另外, 在mysql中, 大小写是不区分的. 如果你更熟悉小写的话,就可以使用。</p><pre><code class="text">select version(),current_date;</code></pre><p>这完全没有太大的影响。 另外,sql语句可以在一行中书写, 例如:</p><pre><code class="text">select version(); select now(); select current_date;</code></pre><p>这3条语句都会执行一次。 由于,mysql是根据semicolon来决定语句的结束, 所以, 你书写语句的方式, 可以这样写.</p><pre><code class="text">&gt; select     -&gt; ,    -&gt; current_date;</code></pre><p>如果你换行之后发现自己打错了, 那该怎么办呢？ 简单,输入/c即可.</p><h2 id="数据库之初操作"><a href="#数据库之初操作" class="headerlink" title="数据库之初操作"></a>数据库之初操作</h2><p>进入数据库后, 第一件事, 应该看看, 这里面有哪些已经创建好的用户.</p><pre><code class="text">show databases;// 你有可能会发现有如下的信息；+----------+| Database |+----------+| mysql    || test     || tmp      |+----------+</code></pre><p>然后, 你可以选择其一并进行相关操作.</p><pre><code class="text">USE test</code></pre><p>当你已经进入数据库, 但突然忘记了,自己是哪个用户,哪个数据库. so how to do? 上面已经介绍了,查找用户, 可以直接使用SELECT USER(); 那查找数据库同理就应该为.</p><pre><code class="text">SELECT DATABASE();</code></pre><p>如果, 你没有相关的db的话, 那就需要你手动进行创建了.</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>使用方法很简单:</p><pre><code class="text">CREATE DATABASE db_name;// 这里的db_name 是大小写敏感的,需要注意一下.</code></pre><p>之后, 你就需要手动进行选择你需要的数据库. 还是上面那个命令. USE db_name; 当然， 如果你嫌登录之后再USE 有点麻烦, 你可以直接使用.</p><pre><code class="text">mysql -u user -p db_name</code></pre><p>进行相关登录. ok, 之后,就是数据表里的事了.</p><h3 id="数据表相关"><a href="#数据表相关" class="headerlink" title="数据表相关"></a>数据表相关</h3><p>Table和Database的初阶段准备其实没太大的差别。 同样就是, 创建,进入,over. 你可以先检查一下,你的数据库中有没有已经建好的表.</p><pre><code class="text">SHOW TABLES;</code></pre><p>如果没有的话, 你可以随便建一个表. 比如, 你现在创建一个person的表, 里面的字段有name,birth.</p><pre><code class="text">CREATE TABLE person(name VARCHAR(20),birth DATE);</code></pre><p>这样你就成功的创建了一个表,接着, 你可以看看关于你的表的相关描述.</p><pre><code class="text">DESCRIBE person;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GB28181的协议栈功能</title>
    <link href="/2020/04/18/GB28181%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8A%9F%E8%83%BD/"/>
    <url>/2020/04/18/GB28181%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>GB28181的协议栈功能。</p><pre><code>         GB/T-28181协议其实就是在国际上通用的SIP协议进行私有化定制，流媒体方面就是在国际最流行的编码上进行封装（当然也有我们国家的编码标准SVAC）。         既然是国际上通用协议，那肯定就可以借助开源组织的力量了，要知道这是全球最大的软件组织，几乎所有的程序员都为之敬佩！开源组织给了推进计算机技术发展的很好良方。SIP协议实现完全可以用osip来作为基础协议栈（至少我看到绝大多数厂家是如此实现，海康、大华。。。。），使用开源没什么不好的，至少我们知道他们是稳定的，可靠的，会一直维护的。       我采用的是libosip+libexosip+libxml来实现IPC和平台协议功能，前面两者负责sip协议的实现，libxml用来封装和解析实体信令。通过3~4年的市场应用感觉挺稳定的。       流媒体方面：从编码中获取的h.264+g711的视音频帧，进行PS媒体协议封装（自己写的PS封装协议），再经过RTP传输协议（自己实现）发送至平台。       平台对收到的RTP流媒体进行解RTP,解PS，再进行h.264+g711的解码。</code></pre><p>  GB28181协议已经慢慢的进行了规范完善，现在大的趋势也已经是这样，虽然以前有很多的私有协议平台，但新建的平安城市等政府都需要能支持GB28181的互联互通，GB28181协议还有互联功能，这个功能比ONVIF好很多，因为可以进行大面积的组网，可以有上下级平台的区分，这一点是ONVIF不能做到的。</p><pre><code>       ONVIF协议其实也有很多不足，如对事件的具体定义，如对视频分析的定义都是模糊的。用户开发自己的需要自己定义，而且没有对流媒体的方面的定义，因为媒体是通过RTSP协议进行的。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shell命令</title>
    <link href="/2020/04/18/shell%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/04/18/shell%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>文件、目录操作命令<br>1、ls命令</p><p>功能：显示文件和目录的信息</p><p>ls　以默认方式显示当前目录文件列表</p><p>ls -a 显示所有文件包括隐藏文件</p><p>ls -l 显示文件属性，包括大小，日期，符号连接，是否可读写及是否可执行</p><p>ls -lh 显示文件的大小，以容易理解的格式印出文件大小 (例如 1K 234M2G)</p><p>ls -lt 显示文件，按照修改时间排序</p><p>2、cd命令</p><p>功能：改名目录</p><p>cd dir　切换到当前目录下的dir目录</p><p>cd /　切换到根目录</p><p>cd ..　切换到到上一级目录</p><p>cd ../..　切换到上二级目录</p><p>cd ~　切换到用户目录，比如是root用户，则切换到/root下</p><p>3、cp命令</p><p>功能：copy文件</p><p>cp source target　将文件source复制为target</p><p>cp /root /source.　将/root下的文件source复制到当前目录</p><p>cp –av soure_dir target_dir　将整个目录复制，两目录完全一样</p><p>4、rm命令</p><p>功能：删除文件或目录</p><p>rm file　删除某一个文件</p><p>rm -f file 删除时候不进行提示。可以于r参数配合使用</p><p>rm -rf dir　删除当前目录下叫dir的整个目录</p><p>5、mv命令</p><p>功能：将文件移动走，或者改名，在uinx下面没有改名的命令，如果想改名，可以使用该命令</p><p>mv source target　将文件source更名为target</p><p>6、diff</p><p>功能：比较文件内容</p><p>diff dir1 dir2　比较目录1与目录2的文件列表是否相同，但不比较文件的实际内容，不同则列出</p><p>diff file1<br>file2　比较文件1与文件2的内容是否相同，如果是文本格式的文件，则将不相同的内容显示，如果是二进制代码则只表示两个文件是不同的</p><p>comm file1 file2　比较文件，显示两个文件不相同的内容</p><p>7、ln命令</p><p>功能：建立链接。windows的快捷方式就是根据链接的原理来做的</p><p>ln source_path target_path 硬连接</p><p>ln -s source_path target_path 软连接</p><p>查看文件内容命令<br>1、cat命令</p><p>显示文件的内容，和DOS的type相同</p><p>cat file</p><p>2、more命令</p><p>功能：分页显示命令</p><p>more　file</p><p>more命令也可以通过管道符(|)与其他的命令一起使用,例如：</p><p>ps ux|more</p><p>ls|more</p><p>3、tail 命令</p><p>功能：显示文件的最后几行</p><p>tail -n 100 aaa.txt 显示文件aaa.txt文件的最后100行</p><p>4、vi命令</p><p>vi file　编辑文件file</p><p>vi 原基本使用及命令：</p><p>输入命令的方式为先按[ESC]键，然后输入:w(写入文件),:w!(不询问方式写入文件）,:wq保存并退出,:q退出,q!不保存退出</p><p>5、touch命令</p><p>功能：创建一个空文件</p><p>touch aaa.txt 创建一个空文件，文件名为aaa.txt</p><p>基本系统命令<br>1、man命令</p><p>功能：查看某个命令的帮助，如果你不知道某个命令的用法不懂，可以问他，他知道就回告诉你</p><p>例如：</p><p>man ls 显示ls命令的帮助内容</p><p>2、w命令</p><p>功能：显示登录用户的详细信息</p><p>例如：</p><p>Sarge:~# w</p><p>22:06:51 up 43 min, 1 user, load average: 0.00, 0.00, 0.00</p><p>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</p><p>zhoulj pts/0 10.140.0.109 21:24 0.00s 0.85s 0.09s sshd:<br>zhoulj [priv]</p><p>3、who命令</p><p>功能：显示登录用户</p><p>例如：</p><p>Sarge:~# who</p><p>zhoulj pts/0 Mar 13 21:24 (10.140.0.109)</p><p>4、last命令</p><p>功能：查看最近那些用户登录系统</p><p>例如：</p><p>Sarge:~# last</p><p>zhoulj pts/0 10.140.0.109 Mon Mar 13 21:24 still logged in</p><p>reboot system boot 2.6.8-2-386 Mon Mar 13 21:23 (00:43)</p><p>zhoulj pts/0 10.140.0.105 Sun Mar 12 22:51 - down (00:00)</p><p>zhoulj pts/0 10.140.0.105 Sun Mar 12 22:51 - 22:51 (00:00)</p><p>root tty1 Sun Mar 12 22:50 - down (00:01)</p><p>root tty1 Sun Mar 12 22:46 - 22:48 (00:02)</p><p>root tty1 Sun Mar 12 22:43 - 22:46 (00:02)</p><p>reboot system boot 2.6.8-2-386 Mon Mar 13 06:34 (-7:-41)</p><p>wtmp begins Mon Mar 13 06:34:11 2006</p><p>5、date命令</p><p>功能：系统日期设定</p><p>date　显示当前日期时间</p><p>date -s 20:30:30　设置系统时间为20:30:30</p><p>date -s 2002-3-5　设置系统时期为2003-3-5</p><p>date -s “060520 06:00:00”　设置系统时期为2006年5月20日6点整。</p><p>6、clock命令</p><p>功能：时钟设置</p><p>clock –r　对系统Bios中读取时间参数</p><p>clock –w　将系统时间(如由date设置的时间)写入Bios</p><p>7、uname命令</p><p>功能：查看系统版本</p><p>uname -R　显示操作系统内核的version</p><p>例如：</p><p>Sarge:~# uname -a</p><p>Linux Sarge 2.6.8-2-386 #1 Tue Aug 16 12:46:35 UTC 2005 i686 GNU/Linux</p><p>8、关闭和重新启动系统命令</p><p>reboot　 重新启动计算机</p><p>shutdown -r now 重新启动计算机，停止服务后重新启动计算机</p><p>shutdown -h now 关闭计算机，停止服务后再关闭系统</p><p>halt 关闭计算机</p><p>一般用shutdown -r now,在重启系统是，关闭相关服务，shutdown -h now也是如此。</p><p>9、su命令</p><p>功能：切换用户</p><p>su - 切换到root用户</p><p>su - zhoulj 切换到zhoulj用户，</p><p>注意：- ，他很关键，使用-，将使用用户的环境变量</p><p>四、监视系统状态命令</p><p>1、top命令</p><p>功能：查看系统cpu、内存等使用情况</p><p>2、free命令</p><p>功能：查看内存和swap分区使用情况</p><p>例如：</p><p>Sarge:~# free -tm</p><pre><code>        total       used       free     shared    buffers     cached</code></pre><p>1<br>Mem: 187 42 145 0 6 16</p><p>-/+ buffers/cache: 19 167</p><p>Swap: 243 0 243</p><p>Total: 430 42 388</p><p>3、uptime</p><p>功能：现在的时间 ，系统开机运转到现在经过的时间，连线的使用者数量，最近一分钟，五分钟和十五分钟的系统负载</p><p>例如：</p><p>Sarge:~# uptime</p><p>21:54:46 up 31 min, 1 user, load average: 0.00, 0.00, 0.00</p><p>4、vmstat命令</p><p>功能：监视虚拟内存使用情况</p><p>例如：</p><p>Sarge:~# vmstat</p><p>procs memory swap io system<br>cpu</p><p>r b swpd free buff cache si so bi bo in cs us<br>sy id wa</p><p>1 0 0 63704 8100 32272 0 0 8 3 103 17 0<br>1 98 1</p><p>5、ps命令</p><p>功能：显示进程信息</p><p>ps ux 显示当前用户的进程</p><p>ps uxwww 显示当前用户的进程的详细信息</p><p>ps aux 显示所有用户的进程</p><p>ps ef 显示系统所有进程信息</p><p>6、kill命令</p><p>功能：干掉某个进程，进程号可以通过ps命令得到</p><p>kill -9 1001　将进程编号为1001的程序干掉</p><p>kill all -9 apache　将所有名字为apapche的程序杀死，kill不是万能的，对僵死的程序则无效。</p><p>五、磁盘操作命令</p><p>1、df命令</p><p>功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>参数 功能</p><p>-a 列出全部目录</p><p>-Ta 列出全部目录，并且显示文件类型</p><p>-B 显示块信息</p><p>-i 以i节点列出全部目录</p><p>-h 按照日常习惯显示（如：1K、100M、20G）</p><p>-x [filesystype] 不显示[filesystype]</p><p>例如：</p><p>Sarge:~# df -Th</p><p>Filesystem Type Size Used Avail Use% Mounted on</p><p>/dev/sda1 ext3 265M 64M 187M 26% /</p><p>tmpfs tmpfs 94M 0 94M 0% /dev/shm</p><p>/dev/sda6 ext3 714M 8.1M 667M 2% /home</p><p>/dev/sda8 ext3 956M 215M 691M 24% /usr</p><p>/dev/sda7 ext3 714M 57M 619M 9% /var</p><p>2、du命令</p><p>功能：检测一个目录和（递归地）所有它的子目录中的文件占用的磁盘空间。</p><p>参数 功能</p><p>-s [dirName] 显示目录占用总空间</p><p>-sk [dirName] 显示目录占用总空间，以k为单位</p><p>-sb [dirName] 显示目录占用总空间，以b为单位</p><p>-sm [dirName] 显示目录占用总空间，以m为单位</p><p>-sc [dirName] 显示目录占用总空间，加上目录统计</p><p>-sh [dirName] 只统计目录大小</p><p>例如：</p><p>Sarge:~# du -sh /etc</p><p>1.3M /etc</p><p>3、mount命令</p><p>功能：使用mount命令就可在Linux中挂载各种文件系统。</p><p>格式：mount -t 设备名 挂载点</p><p>（1）、mount /dev/sda1 /mnt/filetest</p><p>mount -t vfat /dev/hda /mnt/fatfile</p><p>mount -t ntfs /dev/hda /mnt/ntfsfile</p><p>mount -t iso9660 /dev/cdrom /mnt/cdrom</p><p>mount -o 设备名 挂载点</p><p>（2）、使用usb设备</p><p>modprobe usb-storage</p><p>mkdir /mnt/usb</p><p>mount -t auto /dev/sdx1 /mnt/usb</p><p>umount /mnt/usb</p><p>4、mkswap命令</p><p>功能：使用mkswap命令可以创建swap空间，如：</p><p>debian:~# mkswap -c /dev/hda4</p><p>debian:~# swapon /dev/hda4 #启用新创建的swap空间，停用可使用swapoff命令</p><p>5、fdisk命令</p><p>功能：对磁盘进行分区</p><p>fdisk /dev/xxx 格式化xxx设备(xxx是指磁盘驱动器的名字，例如hdb，sdc)</p><p>fdisk -l 显示磁盘的分区表</p><p>6、mkfs命令</p><p>功能：格式化文件系统，可以指定文件系统的类型，如ext2、ext3、fat、ntfs等</p><p>格式1：mkfs.ext3 options /dev/xxx</p><p>格式2：mkfs -t ext2 options /dev/xxx</p><p>参数 功能</p><p>-b 块大小</p><p>-i 节点大写</p><p>-m 预留管理空间大小</p><p>例如：</p><p>debian:~#mkfs.ext3 /dev/sdb1</p><p>7、e2fsck命令</p><p>功能：磁盘检测</p><p>e2fsck /dev/hda1　检查/dev/hda1是否有文件系统错误，提示修复方式</p><p>e2fsck -p /dev/hda1　检查/dev/hda1是否有错误，如果有则自动修复</p><p>e2fsck -y /dev/hda1　检查错误，所有提问均于yes方式执行</p><p>e2fsck -c /dev/hda1　检查磁盘是否有坏区</p><p>8、tune2fs命令</p><p>功能：调整ext2/ext3文件的参数</p><p>参数 功能</p><p>-l 查看文件系统信息</p><p>-c 设置强制自检的挂载次数</p><p>-i 设置强制自检的间隔时间，单位天</p><p>-m 保留块的百分比</p><p>-j 将ext2文件系统转换成ext3格式</p><p>Sarge:~# tune2fs -l /dev/sda1</p><p>9、dd命令</p><p>功能：功能：把指定的输入文件拷贝到指定的输出文件中，并且在拷贝过程中可以进行格式转换。</p><p>跟DOS下的diskcopy命令的作用类似。</p><p>dd if=/dev/fd0 of=floppy.img　将软盘的内容复制成一个镜像</p><p>dd if=floppy.img of=/dev/fd0　将一个镜像的内容复制到软盘，做驱动盘的时候经常用。</p><p>用户和组相关命令<br>1、groupadd命令</p><p>功能：添加组</p><p>groupadd test1 添加test1组</p><p>groupadd -g 1111 test2 添加test2组，组id为1111</p><p>2、useradd命令</p><p>功能：添加用户</p><p>useradd user1 添加用户user1，home为/home/user1，组为user1</p><p>useradd -g test1 -m -d /home/test1 test1<br>添加用户test1，home为/home/test1，组为test1</p><p>user list　显示已登陆的用户列表</p><p>3、passwd命令</p><p>功能：更改用户密码</p><p>passwd user1　修改用户user1的密码</p><p>passwd -d root　将root用户的密码删除</p><p>4、userdel命令</p><p>功能：删除用户</p><p>userdel user1　删除user1用户</p><p>5、chown命令</p><p>功能：改变文件或目录的所有者</p><p>chown user1 /dir　将/dir目录设置为user1所有</p><p>chown -R user1.user1<br>/dir　将/dir目录下所有文件和目录，设置为user1所有,组为user1。-R递归到下面的每个文件和目录</p><p>6、chgrp命令</p><p>功能：改变文件或目录的所有组</p><p>chgrp user1 /dir　将/dir目录设置为user1所有</p><p>7、chmod命令</p><p>功能：改变用户的权限</p><p>chmod a+x file　将file文件设置为可执行，脚本类文件一定要这样设置一个，否则得用bash file才能执行</p><p>chmod 666 file　将文件file设置为可读写</p><p>chmod 750 file 将文件file设置为，所有者为完全权限，同组可以读和执行，其他无权限</p><p>8、id命令</p><p>功能：显示用户的信息，包括uid、gid等</p><p>Sarge:~# id zhoulj</p><p>uid=500(zhoulj) gid=500(zhoulj) groups=500(zhoulj)</p><p>9、finger命令</p><p>功能：显示用的信息</p><p>注意：debian下没有该命令。</p><p>Sarge:~# finger zhoulj</p><p>Login: zhoulj Name:</p><p>Directory: /home/zhoulj Shell: /bin/bash</p><p>On since Sun May 21 07:59 (CST) on pts/0 from 192.168.1.4</p><p>No mail.</p><p>No Plan.</p><p>压缩命令<br>1、gzip格式命令</p><p>功能：压缩文件，gz格式的</p><p>注意：生成的文件会把源文件覆盖</p><p>gzip -v 压缩文件，并且显示进度</p><p>-d 解压缩</p><p>gnuzip -f 解压缩</p><p>例如：</p><p>Sarge:~# gzip a.sh</p><p>Sarge:~#ll</p><p>-rwxr-xr-x 1 root root 71 12月 18 21:08 a.sh.gz</p><p>Sarge:~# gzip -d a.sh.gz</p><p>Sarge:~#ll</p><p>-rwxr-xr-x 1 root root 48 12月 18 21:08 a.sh</p><p>2、zip格式命令</p><p>功能：压缩和解压缩zip命令</p><p>zip</p><p>unzip</p><p>例如：</p><p>Sarge:~# zip a.sh.zip a.sh</p><p>adding: a.sh (stored 0%)</p><p>Sarge:~# ll</p><p>-rw-r–r– 1 root root 188 5月 21 10:37 a.sh.zip</p><p>Sarge:~# unzip a.sh.zip</p><p>Archive: a.sh.zip</p><p>replace a.sh? [y]es, [n]o, [A]ll, [N]one, [r]ename: r</p><p>new name: a1.sh</p><p>extracting: a1.sh</p><p>Sarge:~ # ll</p><p>-rwxr-xr-x 1 root root 48 12月 18 21:08 a1.sh</p><p>3、bzip2根式命令</p><p>功能：bzip2格式压缩命令，</p><p>注意：生成的文件会把源文件覆盖</p><p>bzip2</p><p>bunzip2</p><p>例如：</p><p>Sarge:~ # bzip2 a.sh</p><p>Sarge:~# ll</p><p>-rwxr-xr-x 1 root root 85 12月 18 21:08 a.sh.bz2</p><p>Sarge:~ # bunzip2 a.sh.bz2</p><p>Sarge:~# ll</p><p>-rwxr-xr-x 1 root root 48 12月 18 21:08 a.sh</p><p>4、tar命令</p><p>功能：归档、压缩等，比较重要，会经常使用。</p><p>-cvf 压缩文件或目录</p><p>-xvf 解压缩文件或目录</p><p>-zcvf 压缩文件或，格式tar.gz</p><p>-zxvf 解压缩文件或，格式tar.gz</p><p>-zcvf 压缩文件或，格式tgz</p><p>-zxvf 解压缩文件或，格式tgz</p><p>举例:</p><p>Sarge:~ # tar cvf abc.tar *.sh</p><p>Sarge:~# tar xvf abc.tar</p><p>Sarge:~# tar czvf abc.tar.gz *.sh</p><p>Sarge:~# ll</p><p>-rw-r–r– 1 root root 20480 5月 21 10:50 abc.tar</p><p>-rw-r–r– 1 root root 1223 5月 21 10:53 abc.tar.gz</p><p>Sarge:~# tar xzvf abc.tar.gz</p><p>网络相关命令<br>1、ifconfig命令</p><p>功能：显示修改网卡的信息</p><p>ifconfig 显示网络信息</p><p>ifconfig eth0 显示eth0网络信息</p><p>修改网络信息：</p><p>ifconfig eth0 192.168.1.1 netmask 255.255.255.0<br>设置网卡1的地址192.168.1.1，掩码为255.255.255.0</p><p>ifconfig eth0:1 192.168.1.2　 捆绑网卡1的第二个地址为192.168.1.2</p><p>ifconfig eth0:x 192.168.1.n　 捆绑网卡1的第n个地址为192.168.1.n</p><p>例如：</p><p>Sarge:~# ifconfig eth0:1 192.168.1.11</p><p>Sarge:~ # ifconfig</p><p>eth0 Link encap:Ethernet HWaddr 00:0C:29:06:9C:24</p><pre><code>  inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1  RX packets:4220 errors:0 dropped:0 overruns:0 frame:0  TX packets:3586 errors:0 dropped:0 overruns:0 carrier:0  collisions:0 txqueuelen:1000  RX bytes:342493 (334.4 Kb)  TX bytes:469020 (458.0 Kb)  Interrupt:9 Base address:0x1400</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>eth0:1 Link encap:Ethernet HWaddr 00:0C:29:06:9C:24</p><pre><code>  inet addr:192.168.1.11  Bcast:192.168.1.255  Mask:255.255.255.0  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1  Interrupt:9 Base address:0x1400</code></pre><p>1<br>2<br>3<br>4<br>5<br>2、route命令</p><p>功能：显示当前路由设置情况</p><p>route 显示当前路由设置情况，比较慢一般不用。</p><p>route add -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254 添加静态路由</p><p>route del -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254 添加静态路由</p><p>route add default gw 192.168.1.1 metric1　 设置192.168.1.1为默认的路由</p><p>route del default　 将默认的路由删除</p><p>举例：</p><p>Sarge:~# route add -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254</p><p>Sarge:~# netstat -nr</p><p>Kernel IP routing table</p><p>Destination Gateway Genmask Flags MSS Window<br>irtt Iface</p><p>192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0</p><p>10.0.0.0 192.168.1.254 255.255.0.0 UG 0 0 0 eth0</p><p>169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0</p><p>0.0.0.0 192.168.1.254 0.0.0.0 UG 0 0 0 eth0</p><p>Sarge:~# route del -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254</p><p>Sarge:~# netstat -nr</p><p>Kernel IP routing table</p><p>Destination Gateway Genmask Flags MSS Window<br>irtt Iface</p><p>192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0</p><p>169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0</p><p>0.0.0.0 192.168.1.254 0.0.0.0 UG 0 0 0 eth0</p><p>3、netstat命令</p><p>功能：显示网络状态</p><p>netstat -an 查看网络端口信息</p><p>netstat -nr 查看路由表信息，比route快多了，</p><p>4、启动网络的命令</p><p>redhat族的命令:</p><p>/etc/init.d/network</p><p>debian命令:</p><p>/etc/init.d/networking</p><p>例如：</p><p>/etc/init.d/network stop 停止网络，</p><p>/etc/init.d/network start 启动网络，</p><p>5、手工修改网络配置</p><p>(1)、debian系统</p><p>配置文件位置为：/etc/network/interfaces</p><p>Sarge:~# The loopback network interface</p><p>auto lo</p><p>iface lo inet loopback</p><p>Sarge:~# The primary network interface</p><p>auto eth0 eth1</p><p>iface eth0 inet static</p><pre><code>address 10.4.5.6netmask 255.255.255.0network 10.4.5.0broadcast 10.4.5.255</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>iface eth1 inet static</p><pre><code>address 219.25.5.60netmask 255.255.255.192network 219.25.5.0broadcast 219.25.5.63gateway 219.25.5.30</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>修改后保存配置后，运行</p><p>/etc/init.d/networking restart</p><p>网络配置就改变了</p><p>(2)、redhat系统</p><p>配置文件位置为：/etc/sysconfig/network-scripts/ifcfg-eth0</p><p>DEVICE=eth0</p><p>BOOTPROTO=static</p><p>BROADCAST=192.168.1.255</p><p>IPADDR=192.168.1.5</p><p>NETMASK=255.255.255.0</p><p>NETWORK=192.168.1.0</p><p>GATEWAY=192.168.1.254</p><p>ONBOOT=yes</p><p>TYPE=Ethernet</p><p>修改后保存配置后，运行</p><p>/etc/init.d/network restart</p><p>或者</p><p>service network restart</p><p>网络配置就改变了。</p><p>默认DNS的文件的位置为：/etc/resolv.conf</p><p>Sarge:~#cat /etc/resolv.conf</p><p>search test.com.cn</p><p>nameserver 192.168.1.11</p><p>6、网络排错</p><p>(1)、ping命令</p><p>功能：不说了，不知道就用干这行了。</p><p>ping</p><p>(2)、traceroute命令</p><p>功能：路由跟踪</p><p>traceroute</p><p>traceroute 207.68.173.7</p><p>(3)、nslookup命令</p><p>功能：域名解析排错</p><p>例如：</p><p>$ nslookup</p><p>Note: nslookup is deprecated and may be removed from future releases.</p><p>Consider using the dig’ orhost’ programs instead. Run nslookup<br>with</p><p>the `-sil[ent]’ option to prevent this message from appearing.</p><p>Server: 192.168.1.11</p><p>Address: 192.168.1.11#53</p><p>Non-authoritative answer:</p><p>Name:</p><p>Address: 202.118.66.66</p><p>server 202.118.66.6</p><p>Default server: 202.118.66.6</p><p>Address: 202.118.66.6#53</p><p>Server: 202.118.66.6</p><p>Address: 202.118.66.6#53</p><p>Non-authoritative answer: canonical name =</p><p>Name:</p><p>Address: 202.108.22.5</p><p>其他命令<br>1、ssh命令</p><p>功能：远程登陆到其他UNIX主机</p><p>ssh -l user1 192.168.1.2 使用用户名user1登陆到192.168.1.2</p><p>ssh</p><p>使用用户名user1登陆到192.168.1.2</p><p>2、scp命令</p><p>功能：安全copy</p><p>例如：</p><p>scp abc.tar.gz</p><p>:~ 将本地的abc.tar.gz 复制到 192.168.1.5的user1用户的根(/home/user1)下。</p><p>3、telnet命令</p><p>功能：登陆到远程主机</p><p>例如：</p><p>telnet 192.168.1.5</p><p>3、find</p><p>   find pathname -options [-print -exec -ok]<br>   让我们来看看该命令的参数：<br>   pathname find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。<br>   -print find命令将匹配的文件输出到标准输出。<br>   -exec find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {} ;，注意{}和\；之间的空格，同时两个{}之间没有空格,<br>   注意一定有分号结尾。<br>   0) -ok 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行<br>   find . -name “datafile” -ctime -1 -exec ls -l {} ; 找到文件名为datafile<em>, 同时创建实际为1天之内的文件, 然后显示他们的明细.<br>   find . -name “datafile” -ctime -1 -exec rm -f {} ; 找到文件名为datafile</em>, 同时创建实际为1天之内的文件, 然后删除他们.</p><p>   find . -name “datafile” -ctime -1 -ok ls -l {} ; 这两个例子和上面的唯一区别就是-ok会在每个文件被执行命令时提示用户, 更加安全.<br>   find . -name “datafile” -ctime -1 -ok rm -f {} ; </p><p>   1) find . -name   基于文件名查找,但是文件名的大小写敏感.<br>   find . -name “datafile*”</p><p>   2) find . -iname  基于文件名查找,但是文件名的大小写不敏感.<br>   find . -iname “datafile*”</p><p>   3) find . -maxdepth 2 -name fred 找出文件名为fred,其中find搜索的目录深度为2(距当前目录), 其中当前目录被视为第一层.</p><p>   4) find . -perm 644 -maxdepth 3 -name “datafile*”  (表示权限为644的, 搜索的目录深度为3, 名字为datafile*的文件)</p><p>   5) find . -path “./rw” -prune -o -name “datafile*” 列出所有不在./rw及其子目录下文件名为datafile<em>的文件。<br>   find . -path “./dir</em>“ 列出所有符合dir<em>的目录及其目录的文件.<br>   find . ( -path “./d1” -o -path “./d2” ) -prune -o -name “datafile</em>“ 列出所有不在./d1和d2及其子目录下文件名为datafile*的文件。</p><p>   6) find . -user ydev 找出所有属主用户为ydev的文件。<br>   find . ! -user ydev 找出所有属主用户不为ydev的文件， 注意!和-user之间的空格。</p><p>   7) find . -nouser    找出所有没有属主用户的文件，换句话就是，主用户可能已经被删除。</p><p>   8) find . -group ydev 找出所有属主用户组为ydev的文件。</p><p>   9) find . -nogroup    找出所有没有属主用户组的文件，换句话就是，主用户组可能已经被删除。</p><p>   10) find . -mtime -3[+3] 找出修改数据时间在3日之内[之外]的文件。<br>   find . -mmin  -3[+3] 找出修改数据时间在3分钟之内[之外]的文件。<br>   find . -atime -3[+3] 找出访问时间在3日之内[之外]的文件。<br>   find . -amin  -3[+3] 找出访问时间在3分钟之内[之外]的文件。<br>   find . -ctime -3[+3] 找出修改状态时间在3日之内[之外]的文件。<br>   find . -cmin  -3[+3] 找出修改状态时间在3分钟之内[之外]的文件。</p><p>   11) find . -newer eldest_file ! -newer newest_file 找出文件的更改时间 between eldest_file and newest_file。<br>   find . -newer file     找出所有比file的更改时间更新的文件<br>   find . ! -newer file 找出所有比file的更改时间更老的文件</p><p>   12) find . -type d    找出文件类型为目录的文件。<br>   find . ! -type d  找出文件类型为非目录的文件。<br>   b - 块设备文件。<br>   d - 目录。<br>   c - 字符设备文件。<br>   p - 管道文件。<br>   l - 符号链接文件。<br>   f - 普通文件。</p><p>   13) find . -size [+/-]100[c/k/M/G] 表示文件的长度为等于[大于/小于]100块[字节/k/M/G]的文件。</p><p>   14) find . -empty 查找所有的空文件或者空目录.</p><p>   15) find . -type f | xargs grep “ABC”<br>   使用xargs和-exec的区别是, -exec可能会为每个搜索出的file,启动一个新的进程执行-exec的操作, 而xargs都是在一个进程内完成, 效率更高.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo命令</title>
    <link href="/2020/04/17/hexo%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/04/17/hexo%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><pre><code>$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre><code>$ hexo new &quot;post title with whitespace&quot;</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre><code>hexo new page --path about/me &quot;About me&quot;</code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre><code>hexo new page --path about/me</code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><pre><code>$ hexo generate</code></pre><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><pre><code>$ hexo g</code></pre><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><pre><code>$ hexo publish [layout] &lt;filename&gt;</code></pre><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><pre><code>$ hexo server</code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><pre><code>$ hexo deploy</code></pre><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><pre><code>$ hexo d</code></pre><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><pre><code>$ hexo render &lt;file1&gt; [file2] ...</code></pre><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><pre><code>$ hexo migrate &lt;type&gt;</code></pre><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration" target="_blank" rel="noopener">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><pre><code>$ hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><pre><code>$ hexo list &lt;type&gt;</code></pre><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><pre><code>$ hexo version</code></pre><p>显示 Hexo 版本。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><pre><code>$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><pre><code>$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new" target="_blank" rel="noopener">提交调试信息到 GitHub</a>。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><pre><code>$ hexo --silent</code></pre><p>隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><pre><code># 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><pre><code># 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><pre><code>$ hexo --draft</code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><pre><code>$ hexo --cwd /path/to/cwd</code></pre><p>自定义当前工作目录（Current working directory）的路径。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最新(2020)virtualenv的一些命令</title>
    <link href="/2020/04/16/%E6%9C%80%E6%96%B0(2020)virtualenv%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/04/16/%E6%9C%80%E6%96%B0(2020)virtualenv%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="最新-2020-virtualenv的一些命令"><a href="#最新-2020-virtualenv的一些命令" class="headerlink" title="最新(2020)virtualenv的一些命令"></a>最新(2020)virtualenv的一些命令</h1><p>which python3 查看python目录</p><p><a href="http://www.wailian.work/album/xUiBn/?sort=date_desc&amp;pagev=1" target="_blank" rel="noopener">http://www.wailian.work/album/xUiBn/?sort=date_desc&amp;pagev=1</a></p><p>virtualenv venv2 -p python3 安装指定版本</p><p>source bin/active 进入虚拟环境(已经更改了入口,现已不适用)</p><h2 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h2><p>在Windows上 virtualenv 创建了batch file</p><pre><code>\env\Scripts\activate.bat</code></pre><p>启动脚本在脚本文件夹</p><pre><code>\path\to\env\Scripts\activate</code></pre><p>如:</p><pre><code>C:\Users\&#39;Username&#39;\venv\Scripts\activate.bat</code></pre><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>虚拟环境是一个包含二进制程序和 shell 脚本的目录。二进制程序包含执行脚本的 <em>python</em> 和安装其它模块的 <em>pip</em>。脚本包括激活环境的脚本，<a href="https://wiki.archlinux.org/index.php/Bash" target="_blank" rel="noopener">bash</a>, csh 和<a href="https://wiki.archlinux.org/index.php/Fish" target="_blank" rel="noopener">fish</a> 个有一个。这个虚拟环境模拟了一个完整的 <a href="https://wiki.archlinux.org/index.php/Python" target="_blank" rel="noopener">Python</a> 执行环境和需要的模块，将程序运行的环境与系统其它部分隔离开来。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://wiki.archlinux.org/index.php/Python" target="_blank" rel="noopener">Python</a> 从 3.3 开始包含了 <em>venv</em> 程序，无需单独安装。 如果使用的是老版本的 Python, 需要额外<a href="https://wiki.archlinux.org/index.php/安装" target="_blank" rel="noopener">安装</a> <em>virtualenv</em>。</p><ul><li>Python 3.3+: <a href="https://www.archlinux.org/packages/?name=python" target="_blank" rel="noopener">python</a></li><li>Python 3: <a href="https://www.archlinux.org/packages/?name=python-virtualenv" target="_blank" rel="noopener">python-virtualenv</a></li><li>Python 2: <a href="https://www.archlinux.org/packages/?name=python2-virtualenv" target="_blank" rel="noopener">python2-virtualenv</a></li></ul><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>使用<em>venv</em> 或 <em>virtualenv</em> 在项目目录创建虚拟环境，请将 venv 目录加入版本控制系统，这样只要执行 <code>pip freeze</code> 就可以重建虚拟环境。</p><h4 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h4><p><strong>Note:</strong> 此方法代替了从 <a href="https://www.archlinux.org/packages/?name=python" target="_blank" rel="noopener">python</a> 3.6 就不建议使用的 <em>pyvenv</em>。</p><p><a href="https://www.archlinux.org/packages/?name=python" target="_blank" rel="noopener">python</a> 软件包从 3.3 开始就提供了此工具:</p><pre><code>$ python -m venv venv</code></pre><h4 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h4><p>Python 3 使用 <a href="https://www.archlinux.org/packages/?name=python-virtualenv" target="_blank" rel="noopener">python-virtualenv</a> 提供的 <em>virtualenv</em>。</p><pre><code>$ virtualenv venv</code></pre><p>Python 2 使用 <a href="https://www.archlinux.org/packages/?name=python2-virtualenv" target="_blank" rel="noopener">python2-virtualenv</a> 提供的 <em>virtualenv2</em>。</p><pre><code>$ virtualenv2 venv</code></pre><h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>要激活虚拟环境(这里假设使用的是 bash):</p><pre><code>$ source venv/bin/activate(venv) $</code></pre><p>一旦进入虚拟环境，就可以通过 <em>pip</em> 安装软件包，并正常执行脚本。</p><p>要退出寻环境，执行 <code>bin/activate</code> 下的:</p><pre><code>(venv) $ deactivate</code></pre><h2 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h2><p>二进制的版本由使用的虚拟环境工具决定。使用 Python 2 工具创建的虚拟环境中，<em>python</em> 命令指向 <code>bin/python2.7</code>，<em>venv</em> 创建的环境中， python 指向 <code>bin/python3.6</code>.</p><p><em>venv</em> 和 <em>virtualenv</em> 差别在于 venv 默认使用系统的 Python 程序:</p><pre><code>$ ls -l venv/bin/python3.6lrwxrwxrwx 1 foo foo 7 Jun  3 19:57 venv/bin/python3.6 -&gt; /usr/bin/python3</code></pre><p>而 <em>virtualenv</em> 工具使用环境目录中的 Python 程序:</p><pre><code>$ ls -l virtualenv/bin/python3.6lrwxrwxrwx 1 foo foo 7 Jun  3 19:58 virtualenv/bin/python3.6 -&gt; python3</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python虚拟环境(创建激活操作删除-virtualenv、Pycharm、virtualenvwrapper、pipenv)</title>
    <link href="/2020/04/16/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83(%E5%88%9B%E5%BB%BA%E6%BF%80%E6%B4%BB%E6%93%8D%E4%BD%9C%E5%88%A0%E9%99%A4-virtualenv%E3%80%81Pycharm%E3%80%81virtualenvwrapper%E3%80%81pipenv)/"/>
    <url>/2020/04/16/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83(%E5%88%9B%E5%BB%BA%E6%BF%80%E6%B4%BB%E6%93%8D%E4%BD%9C%E5%88%A0%E9%99%A4-virtualenv%E3%80%81Pycharm%E3%80%81virtualenvwrapper%E3%80%81pipenv)/</url>
    
    <content type="html"><![CDATA[<h1 id="Python基础42-虚拟环境-创建-激活-操作-删除-virtualenv、Pycharm、virtualenvwrapper、pipenv"><a href="#Python基础42-虚拟环境-创建-激活-操作-删除-virtualenv、Pycharm、virtualenvwrapper、pipenv" class="headerlink" title="Python基础42-虚拟环境(创建/激活/操作/删除-virtualenv、Pycharm、virtualenvwrapper、pipenv)"></a>Python基础42-虚拟环境(创建/激活/操作/删除-virtualenv、Pycharm、virtualenvwrapper、pipenv)</h1><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><ul><li>一个独立的局部的 Python 环境</li><li>完全模拟系统全局 Python 环境的使用，如安装、卸载包到逻辑操作等</li></ul><h1 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h1><ul><li>让项目运行在一个独立的局部的 Python 环境中，使采用不同环境的项目互不干扰。</li></ul><h1 id="3-安装虚拟环境"><a href="#3-安装虚拟环境" class="headerlink" title="3 安装虚拟环境"></a>3 安装虚拟环境</h1><ul><li>virtualenv，就是一个三方包</li><li>安装命令，pip install virtualenv</li><li>使用文档，<a href="https://virtualenv.pypa.io/en/stable/userguide/" target="_blank" rel="noopener">https://virtualenv.pypa.io/en/stable/userguide/</a></li></ul><p>安装过程中，如果出现如下 error 信息是，可以尝试切换源重新下载</p><pre><code class="csharp">$ pip install virtualenv -i https://pypi.python.org/simple/                  Looking in indexes: https://pypi.python.org/simple/Collecting virtualenv  Downloading https://files.pythonhosted.org/packages/b6/30/96a02b2287098b23b875bc8c2f58071c35d2efe84f747b64d523721dc2b5/virtualenv-16.0.0-py2.py3-none-any.whl (1.9MB)    4% |█▌                              | 92kB 2.7kB/s eta 0:11:08Exception:Traceback (most recent call last): ....pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=&#39;files.pythonhosted.org&#39;, port=443): Read timed out.</code></pre><p>清华源，可以</p><pre><code class="cpp">$ pip install virtualenv -i https://pypi.tuna.tsinghua.edu.cn/simple/      Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple/Collecting virtualenv  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/ed/ea/e20b5cbebf45d3096e8138ab74eda139595d827677f38e9dd543e6015bdf/virtualenv-15.2.0-py2.py3-none-any.whl (2.6MB)    100% |████████████████████████████████| 2.6MB 4.1MB/sInstalling collected packages: virtualenvSuccessfully installed virtualenv-15.2.0</code></pre><h1 id="4-使用虚拟环境"><a href="#4-使用虚拟环境" class="headerlink" title="4 使用虚拟环境"></a>4 使用虚拟环境</h1><h2 id="4-1-创建一个局部的隔离的虚拟环境"><a href="#4-1-创建一个局部的隔离的虚拟环境" class="headerlink" title="4.1 创建一个局部的隔离的虚拟环境"></a>4.1 创建一个局部的隔离的虚拟环境</h2><h3 id="4-1-1-创建命令：virtualenv-虚拟环境名称"><a href="#4-1-1-创建命令：virtualenv-虚拟环境名称" class="headerlink" title="4.1.1 创建命令：virtualenv 虚拟环境名称"></a>4.1.1 创建命令：virtualenv 虚拟环境名称</h3><pre><code class="undefined">virtualenv ENV</code></pre><ul><li>cd 到存放虚拟环境的的地址</li><li>执行命令virtualenv ENV，创建名为ENV 的虚拟环境</li></ul><pre><code class="bash">% cd /Users/xxx/Desktop/testvirtuals                    % virtualenv virtual1                   Using base prefix &#39;/usr/local/Cellar/python3/3.6.4_1/Frameworks/Python.framework/Versions/3.6&#39;New python executable in /Users/xxx/Desktop/testvirtuals/virtual1/bin/python3.6Also creating executable in /Users/xxx/Desktop/testvirtuals/virtual1/bin/pythonInstalling setuptools, pip, wheel...done.</code></pre><p>创建虚拟环境结果</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-6999784eb34dd793.png?imageMogr2/auto-orient/strip|imageView2/2/w/818/format/webp</p><p>注意：</p><ul><li><code>Using base prefix</code> 使用的是3.6版本环境，原因是 virtualenv 安装位置就在3.6下，所以默认使用的是其安装位置版本的 Python 环境</li><li>虚拟环境文件包括：Python解析器，包管理工具(setuptools, pip, wheel)，三方包等</li><li>即使创建的 bin 脚本命令集含有 python 和 python3两个脚本，实际它们的版本都是3.6，这个防止使用者理解不足导致已为使用 python 命令时是使用 Python2.x 版本。</li></ul><pre><code class="jsx">% /Users/xxx/Desktop/testvirtuals/virtual1/bin/python3 --versionPython 3.6.4% /Users/xxx/Desktop/testvirtuals/virtual1/bin/python --versionPython 3.6.4</code></pre><h3 id="4-1-2-指定-Python-版本创建虚拟环境"><a href="#4-1-2-指定-Python-版本创建虚拟环境" class="headerlink" title="4.1.2 指定 Python 版本创建虚拟环境"></a>4.1.2 指定 Python 版本创建虚拟环境</h3><p>可选参数：-p<br> 指定 Python2.x 版本创建虚拟环境</p><pre><code class="bash">virtualenv -p /usr/local/bin/python2.7 testvirtual2</code></pre><p>执行效果</p><pre><code class="bash">$ virtualenv -p /usr/local/bin/python2.7 ENVRunning virtualenv with interpreter /usr/local/bin/python2.7New python executable in /Users/minyu_leung/Desktop/virtual2/ENV/bin/python2.7Also creating executable in /Users/minyu_leung/Desktop/virtual2/ENV/bin/pythonInstalling setuptools, pip, wheel...done.</code></pre><h3 id="4-1-3-是否继承系统三方库-system-site-packages"><a href="#4-1-3-是否继承系统三方库-system-site-packages" class="headerlink" title="4.1.3 是否继承系统三方库 --system-site-packages"></a>4.1.3 是否继承系统三方库 <code>--system-site-packages</code></h3><p>添加参数<code>--system-site-packages</code>，项目检索库的时候，也会到系统的三方库中找<br> 不添加时，默认只到虚拟环境中查找库</p><pre><code class="undefined">virtualenv --system-site-packages ENV</code></pre><h2 id="4-2-激活-退出-虚拟环境"><a href="#4-2-激活-退出-虚拟环境" class="headerlink" title="4.2 激活/退出 虚拟环境"></a>4.2 激活/退出 虚拟环境</h2><p>在 Mac 下，激活所创建的虚拟环境步骤：</p><ol><li>cd 到虚拟环境文件夹目录</li></ol><pre><code class="bash">cd /Users/xxx/Desktop/testvirtuals/virtual1</code></pre><ol><li>执行命令 source bin/activate，shell 会打印出已激活的虚拟环境名称</li></ol><pre><code class="bash">$ source bin/activate(virtual1)</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-f0e1aeda8aa76b6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/977/format/webp</p><p>带 source 命令</p><ol><li><p>验证当前确实在已激活的虚拟环境中，执行命令 pip –version 和 pip list</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-6cbe76da12ffc2e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1118/format/webp</p><p>每次打印后都会提示(virtual1)，所在环境是虚拟环境</p></li><li><p>退出虚拟环境，在激活的虚拟环境中，执行命令 deactivate</p></li></ol><pre><code class="ruby">$ deactivate</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-96810edb63e6c71e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1018/format/webp</p><p>注意，不用带 source 命令</p><ol><li><p>验证已经退出，执行命令 pip –version 和 pip list</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-acc089c067eaba88.png?imageMogr2/auto-orient/strip|imageView2/2/w/1020/format/webp</p><p>结果都是来自系统环境</p></li><li><p>注意：如果系统是 Windows 的话，则不需要带上 source 命令，直接 cd 进入Scripts脚本文件夹中，然后执行 activate 和 deactivate 脚本即可。与 Mac 不同的是，虚拟环境的 bin 目录下只有 activate 脚本，没有 deactivate 脚本。</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-d1b30e5a43c651cf.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/775/format/webp</p><p>Windows 下的虚拟环境 Scripts 文件夹文件目录</p></li></ol><p>![img](https:////upload-images.jianshu.io/upload_images/748014-a37973ef28926b56.png?imageMogr2/auto-orient/strip|imageView2/2/w/633/format/webp</p><p>Mac 虚拟环境 bin 目录文件</p><p><a href="https://virtualenv.pypa.io/en/stable/userguide/" target="_blank" rel="noopener">使用文档</a>中也有说 source 使用原因：</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-2bfe425e8159747b.png?imageMogr2/auto-orient/strip|imageView2/2/w/777/format/webp</p><h2 id="4-3-在激活状态下，操作"><a href="#4-3-在激活状态下，操作" class="headerlink" title="4.3 在激活状态下，操作"></a>4.3 在激活状态下，操作</h2><ol><li>操作三方块<br> pip install requests</li><li>执行 py 文件<br> python xx.py</li></ol><p>以上操作均作用在虚拟环境中。</p><h2 id="4-4-删除虚拟环境"><a href="#4-4-删除虚拟环境" class="headerlink" title="4.4 删除虚拟环境"></a>4.4 删除虚拟环境</h2><ul><li>直接删除虚拟环境所在目录即</li></ul><h2 id="4-5-项目交接"><a href="#4-5-项目交接" class="headerlink" title="4.5 项目交接"></a>4.5 项目交接</h2><p>场景：确保共享的项目能够在其他电脑上正常运行<br> 解决：</p><ol><li>方案一：</li></ol><ul><li>连同虚拟环境和项目一起拷贝给他人</li></ul><ol><li>方案二：</li></ol><ul><li>在虚拟环境中，冻结依赖需求文本</li><li>把项目和依赖需求文本给他人</li><li>他人在本地创建一个新的虚拟环境，并根据依赖需求文本安装相关库</li></ul><p><strong>技能点</strong>：</p><ul><li>虚拟环境的创建</li><li>虚拟环境的激活</li><li>操作虚拟环境</li><li>冻结项目需求文本 pip freeze &gt; requirements.txt</li><li>根据需求文本，安装项目依赖库 pip install -r requirements.txt （在激活的虚拟环境中）</li></ul><h1 id="5-Pycharm-中使用虚拟环境"><a href="#5-Pycharm-中使用虚拟环境" class="headerlink" title="5 Pycharm 中使用虚拟环境"></a>5 Pycharm 中使用虚拟环境</h1><ol><li><p>创建项目</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-96770a324e09b1c8.png?imageMogr2/auto-orient/strip|imageView2/2/w/779/format/webp</p></li><li><p>在创建项目时，使用虚拟环境</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-f386466e4e33fa57.png?imageMogr2/auto-orient/strip|imageView2/2/w/862/format/webp</p></li></ol><p>创建后，目录结构</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-4438a8e2c308b040.png?imageMogr2/auto-orient/strip|imageView2/2/w/593/format/webp</p><ol><li><p>在项目偏好设置里可以切换环境和安装需要的库</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-25d73f4640a84b5a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1001/format/webp</p></li></ol><p>总结：<br> IDE 让虚拟环境的使用更加方便，图形化创建和切换，包的管理等。让程序员更关注项目的开发而非各种命令的记忆。</p><h1 id="6-虚拟环境进阶使用"><a href="#6-虚拟环境进阶使用" class="headerlink" title="6 虚拟环境进阶使用"></a>6 虚拟环境进阶使用</h1><h2 id="6-1-集中式虚拟环境管理"><a href="#6-1-集中式虚拟环境管理" class="headerlink" title="6.1 集中式虚拟环境管理"></a>6.1 集中式虚拟环境管理</h2><p><a href="https://pypi.org/project/virtualenvwrapper/" target="_blank" rel="noopener">virtualenvwrapper</a><br> <a href="https://virtualenvwrapper.readthedocs.io/en/latest/" target="_blank" rel="noopener">使用文档</a></p><ol><li>通过virtualenvwrapper创建的虚拟环境都会统一存放到指定位置统一管理</li><li>方便在多个虚拟环境间切换</li><li>更加方便的去使用 virtualenv</li></ol><ul><li>快速创建虚拟环境并激活</li></ul><pre><code class="undefined">mkvirtualenv venv1</code></pre><ul><li>快速在多个虚拟环境中切换</li></ul><pre><code class="undefined">workon venv2</code></pre><ul><li>快速关闭虚拟环境</li></ul><pre><code class="undefined">deactivate</code></pre><ul><li>快速删除虚拟环境</li></ul><pre><code class="undefined">rmvirtualenv env1</code></pre><ul><li>查看所有创建的虚拟环境</li></ul><pre><code class="undefined">lsvirtualenv</code></pre><p><strong>弊端</strong></p><ul><li>只是对 virtualenv 的使用封装，包的安装及虚拟环境的操作依然是分离的。</li><li>并未具备对项目包的依赖管理及需求文本的生成操作封装</li></ul><h2 id="6-2-更加基于项目的虚拟环境管理"><a href="#6-2-更加基于项目的虚拟环境管理" class="headerlink" title="6.2 更加基于项目的虚拟环境管理"></a>6.2 更加基于项目的虚拟环境管理</h2><h3 id="6-2-1-pipenv-使用优点"><a href="#6-2-1-pipenv-使用优点" class="headerlink" title="6.2.1 pipenv 使用优点"></a>6.2.1 pipenv 使用优点</h3><ol><li>推荐使用：<a href="https://pypi.org/project/pipenv/" target="_blank" rel="noopener">pipenv</a>，是  pip + virtualenv 结合体，解决了virtualenvwrapper弊端</li><li>会自动帮你创建虚拟环境，以及安装三方库</li><li>会自动的记录你的项目依赖的所有三方库</li><li>使用 pipfile 和 pipfile.lock取代了 requirements.txt</li></ol><p><a href="https://pypi.org/project/pipenv/" target="_blank" rel="noopener">使用文档</a><br> <a href="https://pypi.org/project/pipenv/" target="_blank" rel="noopener">使用文档2</a></p><p>pipenv 命令使用一览</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-2a8f6aae311ed8f7.png?imageMogr2/auto-orient/strip|imageView2/2/w/1113/format/webp</p><blockquote><p>pipenv 命令都是参照项目中的 Pipfile 位置和内容操作的，类似 cocoapods 的 pod 命令参照podfile文件操作。</p></blockquote><h3 id="6-2-2-使用步骤"><a href="#6-2-2-使用步骤" class="headerlink" title="6.2.2 使用步骤"></a>6.2.2 使用步骤</h3><h3 id="6-2-2-1-创建虚拟环境"><a href="#6-2-2-1-创建虚拟环境" class="headerlink" title="6.2.2.1 创建虚拟环境"></a>6.2.2.1 创建虚拟环境</h3><pre><code class="bash">1. cd 到项目文件夹目录下2. 在该目录下执行命令pipenv --two # 指定参照Python版本或pipenv --three3. 查看相关信息查看位置：pipenv --where查看虚拟环境位置：pipenv --venv查看解析器信息：pipenv --py</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-d7b94c520db1c332.png?imageMogr2/auto-orient/strip|imageView2/2/w/885/format/webp</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-91582750ee430c67.png?imageMogr2/auto-orient/strip|imageView2/2/w/469/format/webp</p><h3 id="6-2-2-2-激活虚拟环境"><a href="#6-2-2-2-激活虚拟环境" class="headerlink" title="6.2.2.2 激活虚拟环境"></a>6.2.2.2 激活虚拟环境</h3><pre><code class="undefined">pipenv shell</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-6a4c448fb9c3d051.png?imageMogr2/auto-orient/strip|imageView2/2/w/1119/format/webp</p><h3 id="6-2-2-3-在激活状态下操作"><a href="#6-2-2-3-在激活状态下操作" class="headerlink" title="6.2.2.3 在激活状态下操作"></a>6.2.2.3 在激活状态下操作</h3><ol><li>执行 py 文件，python xx.py ，其中 python 指的是虚拟环境 Python版本</li><li>安装包</li></ol><pre><code class="undefined">pipenv install requests</code></pre><blockquote><p>注意：不要使用 pip install 命令，使用的话虽然可以在虚拟环境中安装对应的包，但是不会更新 PIPfile 和 PIPfile.lock</p></blockquote><blockquote><p>命令：pipenv install [三方库名]<br> 作用：<br> 一、检测当前项目对应的虚拟环境是否存在，不存在则创建。如果当前项目已经存在 Pipfile 和 Pipfile.lock 文件，则参照这两个文件内容创建虚拟环境并安装文件指定的三方库<br> 二、在虚拟环境中安装指定三方库，如果没有指定，则不安装<br> 三、在项目目录下，通过 Pipfile 和 Pipfile.lock 记录当下已经安装的三方库信息</p></blockquote><p>![img](https:////upload-images.jianshu.io/upload_images/748014-691e4b565fd095f3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1127/format/webp</p><ol><li>查看包的依赖结构</li></ol><pre><code class="undefined">pipenv graph</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-71f4e8995bf218ae.png?imageMogr2/auto-orient/strip|imageView2/2/w/1117/format/webp</p><ol><li>卸载包</li></ol><pre><code class="undefined">pipenv uninstall requests</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-255f64f0d028c0f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1117/format/webp</p><h3 id="6-2-2-4-退出虚拟环境"><a href="#6-2-2-4-退出虚拟环境" class="headerlink" title="6.2.2.4 退出虚拟环境"></a>6.2.2.4 退出虚拟环境</h3><pre><code class="bash">exit或直接关闭 shell 窗口</code></pre><h3 id="6-2-2-5-删除虚拟环境"><a href="#6-2-2-5-删除虚拟环境" class="headerlink" title="6.2.2.5 删除虚拟环境"></a>6.2.2.5 删除虚拟环境</h3><pre><code class="bash">先 cd 进入 Pipfile 文件目录位置pipenv --rm</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-0bf378bb4f9a5356.png?imageMogr2/auto-orient/strip|imageView2/2/w/907/format/webp</p><h2 id="6-3-项目交接"><a href="#6-3-项目交接" class="headerlink" title="6.3 项目交接"></a>6.3 项目交接</h2><h3 id="6-3-1-上传项目时，应该包含的文件有？"><a href="#6-3-1-上传项目时，应该包含的文件有？" class="headerlink" title="6.3.1 上传项目时，应该包含的文件有？"></a>6.3.1 上传项目时，应该包含的文件有？</h3><p>应该包括文件有：</p><ol><li>包和模块源码</li><li>Pipfile 和 Pipfile.lock</li></ol><h3 id="6-3-2-拿到共享的项目后如何操作？"><a href="#6-3-2-拿到共享的项目后如何操作？" class="headerlink" title="6.3.2 拿到共享的项目后如何操作？"></a>6.3.2 拿到共享的项目后如何操作？</h3><p>操作步骤：</p><ol><li>cd 进入获取的项目文件夹目录内</li><li>检查项目是否具有Pipfile 和 Pipfile.lock 文件 （此处应该是必须有的，因为是执行上述分享操作的人给你的项目嘛♪(∇*)啦啦）</li><li>执行命令：</li></ol><pre><code class="undefined">pipenv install</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>爬图片素材</title>
    <link href="/2020/04/01/%E7%88%AC%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/"/>
    <url>/2020/04/01/%E7%88%AC%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/</url>
    
    <content type="html"><![CDATA[<pre><code>import requestsimport reimport osimport urllibheaders={&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#39;}response=requests.get(&#39;https://www.vmgirls.com/12985.html&#39;,headers=headers)# print(response.request.headers)html=response.text# 文件夹dir_name=re.findall(&#39;&lt;h1 class=&quot;post-title h3&quot;&gt;(.*?)&lt;/h1&gt;&#39;,html)[-1]if not os.path.exists(dir_name):    os.mkdir(dir_name)urls=re.findall(&#39;&lt;a href=&quot;(.*?)&quot; alt=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#39;,html)print(urls)for url in urls:    file_name=url.split(&#39;/&#39;)[-1]    response=requests.get(url,headers=headers)    with open(dir_name+&#39;/&#39;+file_name,&#39;wb&#39;)as f:        f.write(response.content)</code></pre><p><img src="9F2A3DC5A9D149FE8277BAB068E2205C" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python中的正则表达式</title>
    <link href="/2020/03/30/Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/03/30/Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="元字符和语法"><a href="#元字符和语法" class="headerlink" title="元字符和语法"></a>元字符和语法</h1><table><thead><tr><th align="center">实例</th><th align="center">匹配串</th></tr></thead><tbody><tr><td align="center">a.c</td><td align="center">abc</td></tr><tr><td align="center">a\.c</td><td align="center">a.c</td></tr><tr><td align="center">a[jq]k</td><td align="center">ajk&amp;aqk</td></tr><tr><td align="center">a\dc</td><td align="center">a1c</td></tr><tr><td align="center">a\Dc</td><td align="center">abc</td></tr><tr><td align="center">a\s</td><td align="center">a s</td></tr><tr><td align="center">a*</td><td align="center">a&amp;aaaaaaaa….</td></tr><tr><td align="center">a+</td><td align="center">aa&amp;aaaa…</td></tr><tr><td align="center">a?</td><td align="center">前一个字符0&amp;1次</td></tr><tr><td align="center">a{m}</td><td align="center">a后m个a</td></tr><tr><td align="center">{mn}</td><td align="center">m到n个前一字符</td></tr><tr><td align="center">^</td><td align="center">匹配每一行的开头</td></tr><tr><td align="center">$</td><td align="center">匹配每一行的末尾</td></tr><tr><td align="center">\A&amp;\Z</td><td align="center">仅匹配开头&amp;结尾</td></tr><tr><td align="center">## 逻辑与分组</td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">…..</th><th align="center">…….</th></tr></thead><tbody><tr><td align="center">\</td><td align="center">左右任意匹配一个（从左到右）</td></tr><tr><td align="center">a(12|34)c</td><td align="center">a34c</td></tr><tr><td align="center">(?#)</td><td align="center">忽略#后</td></tr><tr><td align="center">(?!=…)</td><td align="center">后面不是..</td></tr><tr><td align="center">(?&lt;=…)</td><td align="center">之前是…</td></tr></tbody></table><h2 id="烦人的反斜杠"><a href="#烦人的反斜杠" class="headerlink" title="烦人的反斜杠"></a>烦人的反斜杠</h2><p>原生字符串“ ”直观的解决了问题</p><h2 id="RE模块"><a href="#RE模块" class="headerlink" title="RE模块"></a>RE模块</h2><pre><code># encoding: UTF-8import re# 将正则表达式编译成Pattern对象pattern = re.compile(r&#39;hello&#39;)# 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回Nonematch = pattern.match(&#39;hello world!&#39;)if match:    # 使用Match获得分组信息    print match.group()### 输出 #### hello</code></pre><h3 id="re-compile-strPattern-flag"><a href="#re-compile-strPattern-flag" class="headerlink" title="re.compile(strPattern[, flag]):"></a>re.compile(strPattern[, flag]):</h3><p>这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。 第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。<br>可选值有：</p><ul><li>re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）</li><li>M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）</li><li>S(DOTALL): 点任意匹配模式，改变’.’的行为</li><li>L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定</li><li>U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性</li><li>X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：</li></ul><pre><code>a = re.compile(r&quot;&quot;&quot;\d +  # the integral part                   \.    # the decimal point                   \d *  # some fractional digits&quot;&quot;&quot;, re.X)b = re.compile(r&quot;\d+\.\d*&quot;)</code></pre><h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p><p><strong>属性</strong>：</p><ul><li><strong>string</strong>: 匹配时使用的文本。</li><li><strong>re</strong>: 匹配时使用的Pattern对象。</li><li><strong>pos</strong>: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</li><li><strong>endpos</strong>: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</li><li><strong>lastindex</strong>: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。</li><li><strong>lastgroup</strong>: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。</li></ul><p><strong>方法</strong>：</p><ul><li><p><strong>group</strong>([group1, …]):<br>获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。</p></li><li><p><strong>groups([default])</strong>:<br>以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。</p></li><li><p><strong>groupdict</strong>([default]):<br>返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。</p></li><li><p><strong>start([group])</strong>:<br>返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。</p></li><li><p><strong>end([group])</strong>:<br>返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。</p></li><li><p><strong>span([group])</strong>:<br>返回(start(group), end(group))。</p></li><li><p><strong>expand</strong>(template):<br>将匹配到的分组代入template中然后返回。template中可以使用\id或\g<id>、\g<name>引用分组，但不能使用编号0。\id与\g<id>是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符’0’，只能使用\g&lt;1&gt;0。</p></li></ul><h4 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h4><p>Pattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。</p><pre><code>import rep = re.compile(r&#39;(\w+) (\w+)(?P&lt;sign&gt;.*)&#39;, re.DOTALL)print &quot;p.pattern:&quot;, p.patternprint &quot;p.flags:&quot;, p.flagsprint &quot;p.groups:&quot;, p.groupsprint &quot;p.groupindex:&quot;, p.groupindex### output #### p.pattern: (\w+) (\w+)(?P&lt;sign&gt;.*)# p.flags: 16# p.groups: 3# p.groupindex: {&#39;sign&#39;: 3}</code></pre><p>以上就是Python对于正则表达式的支持 qwq !!</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python环境变量升级</title>
    <link href="/2020/03/27/python%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8D%87%E7%BA%A7/"/>
    <url>/2020/03/27/python%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8D%87%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>默认安装路径：C:\python35</code></pre><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>【在第二个内容框中找到 变量名为Path 的一行，双击<br> Python安装目录追加到变值值中，用 ； 分割</p><p> 如：原来的值;C:\python35，切记前面有分号</p><p>(备注：默认安装时会自动添加环境变量)</p><h1 id="要临时设置环境变量"><a href="#要临时设置环境变量" class="headerlink" title="要临时设置环境变量"></a>要临时设置环境变量</h1><p> 打开命令提示符并使用 set 命令：</p><pre><code>C:\&gt;set PATH=C:\Program Files\Python 3.8;%PATH%C:\&gt;set PYTHONPATH=%PYTHONPATH%;C:\My_python_libC:\&gt;python要永久修改默认环境变量，请单击“开始”并搜索“编辑环境变量”，或打开“系统属性” Advanced system settings ，然后单击 Environment Variables 按钮。在此对话框中，您可以添加或修改用户和系统变量。要更改系统变量，您需要对计算机进行无限制访问（即管理员权限）。</code></pre><p>由该控制台启动的任何应用程序都继承设这些设置。</p><h1 id="要永久修改默认环境变量"><a href="#要永久修改默认环境变量" class="headerlink" title="要永久修改默认环境变量"></a>要永久修改默认环境变量</h1><p>  单击“开始”并搜索“编辑环境变量”，或打开“系统属性” Advanced system settings ，然后单击 Environment Variables 按钮。在此对话框中，您可以添加或修改用户和系统变量。要更改系统变量，您需要对计算机进行无限制访问（即管理员权限）。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Windows会将用户变量串联的系统变量 之后 ，这可能会在修改 PATH 时导致意外结果。<br>PYTHONPATH 变量被Python 2和Python 3的所有版本使用，因此除非它只包含与所有已安装的Python版本兼容的代码，否则不要永久配置此变量。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>virtualenv的安装</title>
    <link href="/2020/03/27/virtualenv%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2020/03/27/virtualenv%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>使各应用有“独立”的Python运行环境</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>$ pip3 install virtualen</p><h1 id="开始项目"><a href="#开始项目" class="headerlink" title="开始项目"></a>开始项目</h1><h2 id="第一步（创建目录"><a href="#第一步（创建目录" class="headerlink" title="第一步（创建目录)"></a>第一步（创建目录)</h2><p>mkdir myproject<br>cd myproject/</p><h2 id="第二步（创建一个独立的Python运行环境，命名为venv：）"><a href="#第二步（创建一个独立的Python运行环境，命名为venv：）" class="headerlink" title="第二步（创建一个独立的Python运行环境，命名为venv：）"></a>第二步（创建一个独立的Python运行环境，命名为venv：）</h2><pre><code>Mac:myproject michael$ virtualenv --no-site-packages venvUsing base prefix &#39;/usr/local/.../Python.framework/Versions/3.4&#39;New python executable in venv/bin/python3.4Also creating executable in venv/bin/pythonInstalling setuptools, pip, wheel...done.</code></pre><p>命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数–no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。</p><p>新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境，可以用source进入该环境：</p><pre><code>Mac:myproject michael$ source venv/bin/activate(venv)Mac:myproject michael$</code></pre><p>有个(venv)前缀，表示当前环境是一个名为venv的Python环境。</p><p>在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响。也就是说，venv环境是专门针对myproject这个应用创建的。</p><p>退出当前的venv环境，使用deactivate命令：</p><pre><code>(venv)Mac:myproject michael$ deactivate Mac:myproject michael$</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络</title>
    <link href="/2020/03/26/%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/03/26/%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h1><p>应用层<br>表示层<br>会话层<br>传输层<br>网络层<br>数据链路层<br>物理层</p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="tcp-ip"><a href="#tcp-ip" class="headerlink" title="tcp ip"></a>tcp ip</h2><p>TCP/IP协议涵盖了OSI参考模型的第三层、第四层，即网络层、传输层。TCP/IP也不是只有TCP + IP这两种协议，它是协议栈的统称，它还包括 ARP，ICMP，IGMP，UDP，以及让域名访问成为可能的DNS，以及电脑/手机可以自动获取IP地址的DHCP。当然还有形形色色的应用层的协议如 HTTP / SMTP / FTP 等。</p><p>《TCP/IP协议》详解卷一，是一本很好的教材，一条消息竟然双向耗费9个包，仅仅是调用一次connect（）建立连接，调用一次 send（），然后程序退出。</p><p>TCP建立连接<br>看TCP如何建立连接，建立连接需要三个包的交互，这个应该是connect()完成的。</p><p>TCP发送数据<br>然后看到自己的消息内容是一个包，对方没有数据，只有确认ACK，这是两个包，这个由 send () 触发。</p><p>TCP释放连接<br>然后系统自动退出，虽然我的程序没有调用什么函数，但是系统自动帮我调用了 close () 函数，于是又触发了TCP 关闭连接，这是四个包。</p><p>试用UDP socket 编写聊天程序，直接调用一个函数Sendto() 就可以了（用IP访问），抓包一看，一个消息就是一个包，对方也没有确认，UDP就是加上一个封装头就出去了，不需要建立连接，自然也无需关闭连接。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
