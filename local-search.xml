<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>番剧</title>
    <link href="/2020/04/26/%E7%95%AA%E5%89%A7/"/>
    <url>/2020/04/26/%E7%95%AA%E5%89%A7/</url>
    
    <content type="html"><![CDATA[<p>1.《月色真美》——狗粮真甜<br>2.《徒然喜欢你》——突然撒狗粮<br>3.《好想告诉你》——好想急死你<br>4.《我的妹妹不可能那么可爱》——我的爸爸不可能打断我的腿<br>5.《白色相簿2》——又到了白色相簿的季节，你为什么那么熟练啊，明明是我先来的。。。<br>6.《濑户的花嫁》——读作人鱼，写作仁侠，颜艺玩梗通通有<br>7.《中二病也要谈恋爱》——道理我都懂，什么时候接吻？邪王真眼最强<br>8《伪恋》——四把钥匙一把锁，渣男当属一条乐。请珍惜还是软萌音的香菜<br>9.《尽管如此世界依然美丽》——正太控的福音<br>10.《小林家的龙女仆》——活在OP里的“郭德纲”<br>11.《New game》——人活着就是为了日富美前辈<br>12.《珈百璃的堕落》——冥风淳朴，使风日下<br>13.《我的青春恋爱物语果然有问题》——看大老师侃天地侃人生，记得做笔记。咳咳，悄咪咪，一色彩羽天下第一<br>14.《约会大作战》——与其约会，使其娇羞，夺其初吻，纳入后宫<br>15.《男子高中生日常》——今儿的风甚是喧嚣，把坏的东西带到了镇子上<br>16.《天才麻将少女》——没有什么是一次”岭上开花”解决不了的，如果有，那就两次<br>17.《南家三姐妹》——啊哈哈哈啊哈哈哈啊哈哈哈哈哈哈(大姐夫哪都好，可惜是个变态)<br>18.《彩云国物语》——冲着红秀丽和紫刘辉都要把番追完<br>19.《狐妖小红娘》——万剑穿心终不悔，相视一笑轻王权<br>20.《为美好的世界献上祝福》——“妈的阿库娅”，成为了2017年我羞辱别人最所向披靡的利器。<br>21.《这个美术社大有问题》——全世界都是助攻系列，可惜革命尚未成功<br>22.《某科学的超电磁炮》——镇站之宝。战歌起，唯超电磁炮永世长存<br>23.《GAMERS电玩咖》——白学已废，电学当立<br>24.《我女友与青梅竹马的修罗场》——真理只有一个，幼驯染永远不是天降妹的对手，另外，爱衣酱大胜利！<br>25.《上课小动作》——你们日本学生上课的时候真会玩<br>26.《打工吧！魔王大人》——那一夜，勇者在魔王的房间里留下了屈辱的泪水<br>27.《请问您今天要来点兔子吗》——没有点兔看我要死啦<br>28.《No Game No life 游戏人生》——松岗爱衣，你懂的，捕鱼大队预备<br>29.《樱花庄的宠物女孩》——真白是你们谁的老婆？快点带走！心疼七海，到最后她才是那个最孤单的人。<br>30.《从零开始的异世界生活》——如果真爱有颜色，那一定是蓝色<br>31.《天真与闪电》——纯爱番？亲情番？美食番？<br>32.《归宅部活动记录》——究极吐槽技能点满的女主<br>33.《线上游戏的老婆不可能是女生》——线上游戏的玩家全都是女生<br>34.《我的朋友很少》——我的后宫很多<br>35.《初恋怪兽》——我一直不明白，小学生为什么发育那么好<br>36.《家有色邻》——Uc的标题，优秀的剧情<br>37.《龙与虎》——钉宫癌患者重灾区<br>38.《路人女主的养成计划》——圣人惠骑脸怎么输？<br>39.《吹响吧！上低音号》——京阿尼出品，必属精品，病入高黄啊~<br>40.《青春之旅》——OP比正片火一百倍系列<br>41.《在下坂本，有何贵干》——可怜你帅不过坂本大佬，一代逼王，谁与争锋<br>42.《夏目友人帐》——治愈你的心<br>43.《邻座的怪同学》——恋爱番的清流，进度一集赶别人一季，总之买学习股稳赚不赔<br>44.《妄想学生会》——黄段子学生会？<br>45.《日常》——我们一日日度过的日常，实际上可能是接连不断的奇迹<br>46.《Angel Beats》——立于浮华之世，奏响天籁之音<br>47.《埃罗芒阿老师》——伏见老贼的又一商业妹控作品<br>48.《未闻花名》——已知花意，未见其花，已见其花，未闻花名<br>49.《月刊少女野崎君》——铃木和麻美子的爱情故事<br>50.《我们大家的河合庄》——番名带着“庄”字，感觉都不差。短发的河合律，超好看。<br>51.《齐木楠雄的灾难》——希望有生之年听到齐神说句“哦呼”(更新:第二季第17话，齐神终于“哦呼”了)<br>52.《一课一练》——诸葛流千术，我信了你个邪<br>53.《镇魂街》——末将于禁愿为曹家世代赴汤蹈火！国漫良心，绝对经典。<br>54.《凸变英雄》——你的爸爸，永远都是你的英雄<br>55.《关于完全听不懂老公说什么的事》——短短泡面番，处处都是梗，然后干了个爽。。。<br>56.《笨蛋，测验，召唤兽》——壮哉我FFF团<br>57.《全职高手》——你们的名字，就是一场盛世<br>58.《钢之炼金术师》——零差评神作<br>59.《快把我哥带走》——咱们中国就不流行骨科<br>60.《四月是你的谎言》——四月是你的满分作文<br>61.《山田君与七魔女》——男女交换，贵圈真乱<br>62.《清恋》——标题骗人系列，其实内容污的不行<br>63.《风夏》——天降之物带来的怦然心动永远胜过青梅竹马陪伴的稀疏平常<br>64.《如果她的旗帜被折断了》——Flag什么的，好有意思啊<br>65.《当不成勇者的我，只好认真找工作了》——魔王都打工去了，勇者焉能幸存？<br>66.《舞动青春》——长颈鹿们在跳舞<br>67.《那就是声优》——可爱又精彩，一话一大牌，声控来来来<br>68.《网球并不可笑嘛》——出到第九季了，好不好看不必说了吧<br>69.《天使的3P》—萝莉玩音乐，刺不刺激？<br>70.《萝球社！》——萝莉玩篮球，精不精彩？<br>71.《少女爱上姐姐》——女装大佬初体验<br>72.《食戟之灵》——做菜下药，妙妙妙。我撕胖次~<br>73.《学园孤岛》——轻松治愈的校园萌物日常，OP并没有欺诈，芳文大法好，嘿嘿，快去补番，手动狗头<br>74.《有你的小镇》——小镇有你，一切都好，观看之前，必备胃药(建议补漫画)<br>75.《肯普法》——魔法少男？<br>76.《三年E班》——杀老师，你是世界上最好的老师，没有之一(又名《暗杀教室》)<br>77.《Overlord》——看我骨傲天，逍遥世间，执掌霸权<br>78.《Fate系列》——吾王剑锋所指，吾等心之所向，一切都是时臣的错！<br>79.《爱吃拉面的小泉同学》——爱吃小泉的大泽同学<br>80.《我是江小白》——没喝过江小白不要紧，一定要看江小白啊<br>81.《紫罗兰永恒花园》——2018年，京紫元年，人类圣经，世纪霸权<br>82.《十二大战》——大吉大利，耗子吃鸡？<br>83.《兽娘动物园》——细思极恐的“子供向”作品<br>84.《罗小黑战记》——有一种纪年，它就叫做罗小黑更新<br>85.《我的英雄学校》——(绿谷出久，你终会成为你想要成为的，最了不起的英雄！)PS:2020年2月，漫画作者取材731部队对实验者的蔑称，用以漫画角色的命名，任何公然挑战严肃历史事件都应该抵制，希望B站尽快下架！！！<a href="https://www.zhihu.com/question/369386576" target="_blank" rel="noopener">https://www.zhihu.com/question/369386576</a><br>86.《欢迎来到实力至上的教室》——欢迎来到实力装逼主义的教室87.《品酒要在成为夫妻后》——一杯鸡尾酒，虐遍单身狗88.《人形电脑天使心》——叽，太美啦89.《野良神》——吾乃夜斗信徒是也90.《爱神巧克力》——国产青春校园良心后宫番91.《花牌情缘》——悠悠神代事，黯黯不曾闻，枫染龙川田，潺潺流水深。唉，吃饭睡觉虐太一。。。92.《宝石之国》——你要的钻石老婆到了，请查收93.《Relife完结篇》——重返十七岁之剩男剩女需要一个婚介所(正篇超级好看)94.《如果有妹妹就好了》——平坂毒的妹控作品，但是，妹妹呢？画女硬说男。万幸螃蟹公好可爱95.《关于我的女友是一本正经的碧池》——简称，关我碧事96.《Re:CREATORS》——披着魔幻穿越外壳的业界催更番97.《魔法少女小圆》——所以说啊，马猴烧酒是高危职业98.《文学少女》——不怕铅中毒的吃书少女99.《樱子小姐脚下埋着尸体》——女版骨天乐？100.《火影忍者博人传》——为了情怀，值得一追101.《一人之下》——不要碧莲张楚岚，埋人专业冯宝宝，不爱八卦诸葛青。。。。。102.《魔法高校的劣等生》——司波达也，不给就送103.《魔卡少女樱Clear Card》——壮哉初代萌神，小樱小狼，真爱不烧104.《我家大师兄脑子有坑》——万恶的进度条和我逐渐凝固的微笑，太好看啦，太短啦105.《哈哈滑小稽》——小脑斧，大西几，大鸡居。。。滑小稽好萌啊106.《网球王子》《新网球王子》——杀人网球，小意思啦，常规操作107.《撸时代》——回忆我和英雄联盟的故事，也不过如此108.《笨女孩》——妈妈啊我要秋裤<del>对不起，我不想看猴子的胖次109.《Just Because》——比村出品，必属。。咳咳，走错片场了。110.《星期一的丰满》——比村出品，必属精品，咳咳，绅士们，片场在这里。111.《姐姐的妄想日记》——姐姐的脑洞清奇，弟弟真辛苦。112.《干物妹！小埋》——我:妈妈，我想养一只小埋，妈妈:当初不给生二胎113.《排球少年》——腾空吧，小巨人，飞翔吧，乌野！！！大王Sama是真的帅！114.《鲁邦三世》——天才绅士怪盗，唯我鲁邦三世115.《斗破苍穹》——三十年河东，三十年河西，莫欺少年穷(建议食用番外与第二部)116.《田中君总是如此慵懒小剧场》——太田君总是如此可靠117.《漫画家与助手》——松岗，你够了！请停止你的松岗行为！118.《荒川爆笑团》——不笑算我输119.《龙王的工作》——大萝卜鸡的九头龙八一，生前是个体面人。(小说貌似是“银”定了)120.《骑士与魔法》——正太？萝莉？与高达121.《罪恶王冠》——樱花满地集于我心，蝶舞纷飞祈愿相随122.《Infinite Strators 》——传说中的“名作之壁”123.《URARA迷路帖》——道歉的时候露出肚皮不是常识吗124.《灼热乒乓妹》——萝莉乒乓球125.《命运石之门》——一切都是命运石之门的安排126.《幽游白书》——富坚老贼最棒的作品之一，童年经典系列。127.《黑子的篮球》——超能力篮球，奇迹的世代128.《甲铁城的卡巴内瑞》——进击的巨人原班人马制作，大大大河内一楼。。129.《段子狗日记》——嗯嗯嗯，憋气番？130.《房东妹子青春期！》——男主难道不是某敖姓男子？131.《超级索尼子THE ANIMA TION》——索尼大法好啊132.《女子高中生》——女子高中生轻松幽默的校园日常，爆笑</del>133《灵能百分百》——请珍惜琦玉老师还有头发的时候134.《攻壳机动队》——优秀的作品，总会给予人以深刻的反思135.《旋风管家》——老番新看，回忆钉宫四萌带给我最初的欢乐与感动136.《腹黑妹妹控兄记》——内容如标题，画风需适应137.《调教咖啡厅》——抖S，抖M，萌妹，伪娘。。。你想要的属性全都有138.《品酒要在成为夫妻后》——不说了，我马上去学调酒139.《比宇宙更远的地方》——比宇宙更远的地方，是梦想140.《超能力女儿》——没有什么是一顿鱼子酱解决不了的，如果有，那就两顿。三个女儿，穷养杏，富养雏，瞳养你。141.《冰菓》——好奇心可以害死猫，同理，好奇心也可以累死老公，23333142.《露蒂的玩具》——有情人终成父女？143.《中国唱诗班》——中华诗风古韵，犹如你唯美叹息144.《多田君不恋爱》——防不胜防and说好的不恋爱，都给我憋着145.《DARLING in the FRANXX》——莓良心啊<del>莓良心啊(国家队仅港澳台地区)146.《敦君与女朋友》——发狗粮的思路请清奇，傲娇什么的果然最可爱了147.《Megalo Box》——是男人就应该干男人148.《银河英雄传说》——我们的目标是星辰大海149.《宅男腐女恋爱真难》——明明是现充大胜利好伐？150.《黑色四叶草》——热血王道咆哮帝，请带上耳机放心食用(狗头)，我要成为魔法帝！！！151.《后街女孩》——哥仨不红，天理难容152.《工作细胞》——寓教于乐，我为血小板而来153.《魔法禁书目录》——不知道为什么，我现在只记得一方通行的笑声了。。。154.《刀剑神域:序列之争》——我大刀剑系列还能再战一百年155.《夏日大作战》——2018年7月暑期版权回归，不容错过啊156.《镇魂街》——末将于禁愿为曹家世代赴汤蹈火，每次都让我热泪盈眶啊。建议二刷时，阴版阳版分开食用157.《Lovelive》系列——万恶之源啊，Niconiconi(妮可妮可妮)158.《JOJO的奇妙冒险》系列——欧欧拉欧拉欧拉欧拉欧拉就完事啦159.《轻羽飞扬》——绝对硬核的羽毛球番，看妹子的看妹子，学技术的学技术，两不耽误(前三集)。自闭羽毛球，可还行？160.《ALICE of ALICE》——唯一神，不愧为后宫王的男人161.《我的脑内恋碍选项》——男主你退群吧，太羞耻了162.《鬼灯的冷彻》——理想中的领导，鬼灯大人163.《少女编号》——渡航自黑，业界药丸164.《游戏三人娘》——颜艺三人娘165.《JOJO奇妙冒险之黄金之风》——我乔鲁诺·乔巴拿有一个梦想166.《恋爱暴君》——我什么场面没见过？首相和议员？卧槽！这番剧毒！我真没见过！魔幻？后宫？马猴烧酒？青春校园？搞笑？战斗？神知道的世界？爱神巧克力？。。这到底什么番？167.《鸦KARAS》—2005年出品，一部来自未来的动画！（真正意义上的经费燃烧，超越时代的3D打戏，最后把公司做破产了，额……）168.《青春猪头少年不会梦到兔女郎学姐》——踢你的肾</del>踢你的肾<del>好魔性的OP啊！樱岛麻衣学姐，完美女友系列。168.《关于我转生变成史莱姆这档事》——开局一个挂，装备全靠吞，萌王啊！！！169.《刃牙》——是男人就应该干男人啊，热血沸腾了啊170.《刺客伍六七》——阿珍爱上了阿强，在一个没有星星的夜晚</del>171.《你的名字》——前前前世超好听，配乐画质故事都完美，新海诚出品的神级动漫电影172.《声之形》——关注校园暴力，关爱残疾与自闭的孩子，无论如何，都要好好的活下去。173.《猫眼三姐妹》——令人脸红心跳的OP，曾经年少无知的我，从此打开了新世界的大门174.《第一次辣妹》——猪脚团抄袭监狱学园的设定，无脑卖福利无剧情，强烈不推荐，踩雷预警175.《利兹与青鸟》——诚意满满的京阿尼神作，年度最佳动漫电影预定(优酷爱奇艺版权，趁B站还能看先缓存下来)176.《通灵妃》——东北话版本和河南话版本的简直笑Skr个人177.《凉宫春日的忧郁》——参见团长大人吧，推荐2009版。转学生，吐槽役等万梗之源。组长的吐槽功力，银魂既视感。178.《灼眼的夏娜》，《旋风管家》，《零之使魔》，《龙与虎》——感谢B站，不知不觉，钉宫四萌全凑齐了，啾咪<del>179.《绯弹的亚里亚》——金次，当我的奴隶吧！180.《五等分的新娘》——五等分的花嫁，五倍份的快乐吖181.《恋爱研究生》——轻百合喜剧，动画工坊，诸君，兴奋吧。182.《草莓百分百》——东西军大战，CP党争，其乐无穷啊183.《戒律的复活》——七大罪，热血战斗永远是男人的浪漫，追！追！追！184.《盾之勇者成名录》——盾之勇者育女录185.《辉夜大小姐想让我告白</del>天才们的恋爱头脑战》——死傲娇赛高！两个死傲娇赛赛高！先告白你就输啦，但是，请你们立刻结婚！186.《请吃红小豆吧》——一颗梦想被吃掉的红小豆，萌死啦187.《魔法少女 俺》——传说中的魔法兄贵188.《书店里的骷髅店员本田》——安兹大人你怎么去打工啦189.《樱兰高校男公关》——一部能够让你的腐女之魂熊熊燃烧的番190.《宇宙战舰提拉米斯》——机战？美食？轻喜剧？No No No，其实是分镜教学番191.《天使降临到我身边》——似你嘛？玛修！当宅女了啊。喵内<del>喵内</del>192.《尸兄》——我叫白小飞。。。193.《多罗罗》——手冢治虫经典重现194《约定的梦幻岛》——最爱的悬疑推理漫画之一，少年JUMP的邪道台柱！195.《六花的勇者》——此六花非彼六花，但是也吹爆，赛高！196.《家庭教师》——还记得这部童年经典的都是资深宅迷吧！指环上印刻着我们的光阴。197.《同居人是猫》——活着意义是什么？吸猫！吸猫！吸猫！198.《citrus<del>柑橘味香气</del>》——大橘已定，橘里橘气，橘势稳定。。万恶之源的梗。。199.《天降之物》——我的动力炉好痛啊200.《佐贺偶像是传奇》——这个是A站番，但是超级有意思，第一话想要成为偶像的女主出门被车撞死，神展开！第二话Rap对决神仙打架，笑得肚子疼！201.《笨拙之极的上野》——变态之极的上限and钛合金直男田中202.《电波女与青春男》——出现辣，新房45，熟悉的意识流，意识流的画风与表达方式，用心看才能Get到本番的电波。因为，女主是个装在套子里的人。203.《萌妻食神》——就根本不是美食番吧，阿姨洗铁路。。。204.《Comic Girls》——芳(百)文(合)社即正义！205.《农林》——日本的乡村爱情故事，骗大学生去种田，好狠206.《想成为世界最强》——连摔跤都不会好意思说自己是爱豆？看完后满脑子全是哲学207.《潜行吧！奈亚子》——诞生了诸多神曲的神奇番，三只碧去<del>三只碧去</del>三只碧去<del>208.《浪客剑心》——飞天御剑流奥义，超经典的怀旧番，真人版也是帅的一塌糊涂啊！209.《冬季恋歌》——又到了白色</del>啪！我去，剧情这么狗血？一查，麻吉哑巴裤内，韩剧改编的日漫，是在下输了！210.《三坪房间的侵略者！》——炸啦<del>炸啦</del>呆毛后宫炸啦，乱成一锅粥211.《博多豚骨拉面团》——邻里和睦看博多<del>212.《玉子市场》，《玉子爱情故事》——饼哥和玉子两人真是齁甜齁甜的，甜得掉牙啊！Everybody love somebody213.《我太受欢迎了该怎么办？》——逆后宫番，果然，百分之90的胖女孩都是潜力股。唉，这个看脸的世界啊！214.《编舟记》——为伟大的词典编译工作者致以最崇高的敬意！215.《皇帝圣印战记》——嗯，绿色的王。。。216.《Charlotte》——夏洛特，百年修得同船渡，千年修得神同步217.《千绪的上学路》——费劲的上学路，脑洞烧酒，爆笑啊218.《恋爱与选举与巧克力》——游戏改编的后宫攻略动漫219.《灰色的果实》，《灰色的迷宫》，《灰色的乐园》——灰色三部曲，救赎的故事，不仅仅是后宫番，女装雄二了解一下。220.《家有女友》——里番的展开，胃疼的剧情，你是姐姐党还是妹妹党？超神的OP，不解释221.《我被绑架到贵族女校当庶民样本》——葫芦娃和七个Gay佬，超魔性OP曾经血洗过B站222.《大图书馆的牧羊人》——好一个八月脸，色盲勿进223.《群居姐妹》——有妹有姐有房，父母双双忙，和谐的一家人呢224.《加速世界》——生不如加速猪225.《剪刀与狗的正确用法》——死不如剪刀狗横批:猪狗不如226.《强风吹拂》——分明平静无风，是因为你追上了自己的心吧。好温柔的BGM啊，百听不腻。227.《CLANNAD》——还记得团子大家族么？无法忘怀的泪崩神作，写作CL，读作人生。228.《飙速宅男》——教练，我想骑自行车。。。229.《ULTRAMAN机动奥特曼》——一次13集，中日配双版本，舒服了230.《熊巫女》——熊污女，不要看结局！不要看结局！不要看结局！231.《满脑都是⭕⭕的我没办法谈恋爱》——无力吐槽的标题，看上去像里番，却意外的是纯爱番，青酱真可爱。232.《我们无法一起学习》——文乃是天，老师是天外飞仙！233.《鬼灭之刃》——JUPM台柱之一，新四天王，强烈推荐的热血少年杀“鬼”的故事！声优之刃，阵容超级无敌豪华。话说，OP也太好听了，祢豆子也太可爱了吧！无惨出来晒晒太阳吧，顺便喝点紫藤花茶。234.《玛利亚狂热》——震惊！高中男主竟然是一位金发碧眼的美少女？235.《骚动时节的少女们》——冈妈出品，必备胃药。女主的名字，小野寺和纱。嗯？小野寺？和纱？总之，又沙雕又胃疼的番236.《擅长捉弄的高木同学》——擅长发狗粮的高木同学，你太太永远是你太太，单身狗慎看啊！237.《流汗吧！健身少女》——额⊙∀⊙！我真是的为了学习健身知识。务必戴上耳机食用。。。238.《猫咪日常》——给我也整一个，猛男必看番。。239.《女高中生的虚度日常》——哼，有趣的女人240.《某科学的一方通行》——爱玩矢量的一方通行241.《散华礼弥》——当恋尸癖男主遇见僵尸娘女主242.《荒川爆笑团》——随着看番的进度，智商逐渐被桥下居民同化。。为什么真人版的河童是小栗旬，摊手。243.《花开伊吕波》——好喜欢这种”女主内心强大”设定的日常番，神OP，秒变PA粉</del>244.《雏子的笔记》——猛男必看萌豚番245.《从前有座灵剑山》——从前有座山，山里有个派，派里一群大沙雕246.《核爆默示录》——核污染，废土，末世，救援。。。247.《甘城光辉游乐园》——一见公主误终生，从此沦为工具人。京阿尼式的爆笑日常喜剧，百看不厌248.《街角魔族》——马猴烧酒狂宠魔族少女，甜腻腻的<del>249·《魔术学姐》——福利学姐，冲冲冲250.《我才不会被女孩子欺负呢》——动态漫，据说原作不错，但是为什么我一看就自动脑补到了真人版呢251.《游戏人生·零》——游戏人生剧场版，向全体机凯种致以最崇高的敬意！252.《落第骑士英雄谭》——从落第骑士到无冕剑王，热血，王道，后宫，强烈推荐。253.《你遭难了吗》——美少女的荒岛求生法则，硬核程度堪比贝德双爷254.《在盛夏等待》——这世界，终有一个人，在盛夏中等待你归来。青春啊，哪怕失败，也一定要勇敢告白！255.《重来吧，魔王大人！》——我一开始以为这番是一本正经的搞沙雕，但实际上是制作组真的穷</del>穷出了特色，穷出了风采。256.《真实之泪》——你是养鸡党还是养女党？257.《魁拔》——摘一句评论:这世界上只有喜欢魁拔与不知道魁拔的人，而我有幸成为了第一种，国漫加油！258.《游戏王GX》——游城十代的E-Hero系列牌组，绝对的童年经典！最后一集和游戏的史诗级对决，燃爆了！259.《暗芝居》系列——恐怖动画，都市怪谈，总有一处高能可以震撼到你260.《文豪野犬》——为野犬干杯！！！261.《那年那兔那些事儿》——中国加油，我爱你，祖国。奔跑吧，骄傲的少年们！262.《炎炎消防队》——化为熊熊烈焰吧，超燃！263.《阳光中的青时雨》——暗恋，是青春中多么美好的记忆啊264.《这个勇者明明超强却过分谨慎》——如果你喜欢异世界番，慎勇还是蛮下饭的，毕竟有金毛阿库娅。万万没想到，后期开虐，还好是happy ending，门哥牛逼，呜呜呜。。。265.《碧蓝航线》——骚年，氪金你就会变强，充它一个亿吧266.《乒乓》——你反手无力，正手不精，脚步松散，没一个动作像样，就你还想和我同台较量？做你的美梦！(孔文革)267.《我的三体》——我的世界画风，这是一部完全献给粉丝的非商业作品268.《仙王的日常生活》——疯狂玩梗的国创动漫，给爷整笑了，王令只想当一个普通的学生269.《因为太怕痛就全点防御力了》——盾之少女成名录。。。欧皇的世界我不懂<del>270.《俺物语！！》——心有猛男，细嗅蔷薇，甜！甜！甜！神仙女友系列啊，男主真是上辈子拯救了银河系！271.《轻音少女》——K—ON，9.9评分，B站宝藏，强国源泉，轻音一生推。滑滑蛋阿</del>永远的轻音，没有终点！272.《动物狂想曲/BEASTARS》——这是一场动物版的青春人性剧。273.《冰海战记》——维京海盗，历史烟云，少年成长，宏大史诗。274.《阿松》——这不是大雄，这是阿松！！！话说，你们怎么辨认六位松？275.《理科生坠入情网故尝试证明》——明明秀得飞起，还要用鸟公式证明什么叫做爱？276.《别对映像研出手！》——致动画从业者的一封情书(A站，实在是太优秀了，忍不住分享)277.《入间同学入魔了》——OP得劲了，芭比芭比芭比芭比龙<del>恶魔之孙，异世界爽番，图一乐吧278.《索玛丽与森林之神》——有一种小时候像是在看童话般的感觉，温柔的味道。279.《织田肉桂信长》——第六天魔王织田信长惨遭狗化。。。280.《玻璃之花与崩坏的世界》——华丽有余的动漫电影，轻百合，杀毒软件美少女拯救世界281.《纯白交响曲》——游戏改编，愿每一个人都能拥有这纯白的恋曲。282.《铁胆火车侠》——国配，真童年经典系列，B站买过来有心了。最爱希望号了！！！283.《一周的朋友》——如果你需要治愈，我就推荐这旧番，陪伴是最长情的告白。284.《少女终末旅行》——真让人脸扁呢。。。285.《我不受欢迎，怎么想都是你们的错》——我记得以前看的时候片名叫做《丧女》，大部分社恐小人物的真实写照了，极具讽刺意味286.《22/7》——偶像番，音乐超nice！287.《非人哉》——爆笑的国创动漫，一集一集根本停不下来，简直有毒。289.《终将成为你》——硬核百合番。我七海灯子绝对不会接受任何人的表白，所以我会主动表白。(狗头)290.《粗点心战争》——开车，沙雕，日常，玩梗，中二，关于粗点心的科普，蛮有意思哒。。。291.《碧蓝之海》——兄贵之海，颜艺之海。挚友啊，来喝杯可燃乌龙茶吧</del>男“耕”女“织”笑死我了292.《恋爱小行星》——动画工坊+芳文社，awsl。。。291.《女武神的餐桌》——《崩坏3》官方首部原创连载动画。有内味了。292.《黑之契约者》——黑契，开局一人一刀一只猫，任务全靠演，妹子全靠撩。293.《一起一起这里那里》——芳文社早期作品，但是从不让你失望，心情不好的时候看看总会被治愈。。。294.《高分少女》——B站9.9分的神番，果然高分，一个人比祢豆子更省声优的超可爱女主，我也超喜欢日高小春呢。而且街机游戏真是我最怀念的童年记忆啊！！！(《高分少女1》在爱奇艺，前十五集，《高分少女2》在B站)295.《超元气三姐妹》——丸井家三巨头，来吧，车门焊死了，谁也别想跑。子供向的画风，十八禁的车速。296.《境界的彼方》——栗山未来:我不高兴xN。。。没有未来的未来不是我想要的未来。297.《东京教父》——引用评论区的一句话:动画不是单纯的视觉炫技，而是服务于实拍无法达到的剧情，今敏大师向世界证明了这一点。298.《水果篮子2019》——重置番，永不褪色的回忆。299.《少女们向荒野进发》——向荒野进发，向未来前行，及格的励志番。300.《学生会的一己之见》——key君真是后宫番男主的一股清流啊，玩梗玩到飞起301.《宣告黎明的露之歌》——汤浅政明，这就是我追番的理由302.《邪神与厨二病少女》——又名，百合铃家的蛇女仆。日常系，轻百合，搞笑番。夹心酱也太沙雕了，蛇渣一个，美杜莎小天使。303.《喜欢本大爷的竟然只有你一个》——反转反转反转再反转，原作小说第一卷实在是太无敌了！剧情魔改过了，动画质量可追！喜欢本大爷的一个接一个。无处不在的长椅，我都快笑喷了。一切都源自于一场罪孽深重的棒球赛啊。304.《凉风》——算是《风夏》前传吧，濑尾老贼又赚我眼泪！305.《恋爱随意链接》——我是谁？谁又是我？有趣的灵魂交换题材，还有看着非常舒服的京都脸。306.《希德尼娅的骑士》——宏达而精致的世界观，3D神作。星白！星白！星白！307.《心灵侦探八云》——你并不是孤单一人，救赎与被救赎308.《学战都市Asterisk》－－落第骑士既视感，标准的龙傲天后宫番。309.《美妙射击部》——虽然动画组它穷，万幸还不错，优质萌豚食粮。310.《Slow Start》——A1+芳文，又是一部猛男必看，温馨的日常，Slow Start的生活<del>311.《啾咪BABY》——爱杀宝贝变成啾咪宝贝了，又沙雕又欢乐312.《重启咲良田》——稍微冷门的悬疑佳作，细腻而慢节奏313.《弹丸论破》——希望与绝望交织而成的悲歌314.《食梦者》——，也名爆漫王，其实我感觉叫爆肝王吧，“亚城木梦叶”，一起成为最伟大的漫画家的故事(棋魂，死亡笔记也是小畑健的作画，天纵奇才啊)315.《ISLAND》——集悬疑，惊悚，战斗，推理恋爱喜剧为一体的神番啊，现在我也是岛学家了316.《地缚少年花子君》——日常，奇幻，怪谈，独特的美术风格。推荐女生可一看。317.《海绵宝宝历险记》——准备好了吗？孩子们。一起去抓水母吧！318.《宅饮》——这是一部卖酒的广告番吧？319.《昭和元禄落语心中》——一种伟大传承与祭奠320.《不吉波普不笑》——看这番费脑子，先关弹幕。幻想类群像剧。321.《神推偶像登上武道馆我就死而无憾》——沙雕啊，白嫖和DD不香么？单推和毒唯莫得意思。反正我尴尬癌快治好了，哈哈。322.《剑姬神圣谭》——地错外传，最强剑姬艾丝·华伦斯坦的故事。这待遇，比蓝丝带更具正宫样了。323.《政宗君的复仇》——每个胖子都是潜力股。。。324.《可塑性记忆》——这番超费纸，当初看的时候，眼泪哗哗哗得流啊325.《TARI TARI》——青春三部曲之一，PA社总能通过动画把美好的东西带给我们。326.《ANIMAYELL！》——啦啦队与芳文社，无敌327.《魔偶马戏团》——藤田老师炸裂神作，不输给潮与虎328.《火之丸相扑》——热血沸腾的相扑番329.《来自风平浪静的明天》——春秋五霸到战国七雄，这弹幕还有人记得吗？啊，美海小天使，爱花大可爱。330.《刺客守则》——我是一个莫得感情的杀手331.《前方高能之辣稽》——国产表情包动画，槽点与欢乐满满332.《黑白小姐》——Kamiya大法好！超萌电音333.《神薙》——我印象中的蓝毛女神除了阿库娅还有她，神薙。334.《迷家》——文如其名，全程就贯穿一个“迷”字，笑了335.《灵笼》——末日废土，国创3D，音乐炸裂，吹爆艺画开天！336.《天元突破红莲螺岩》——钻头才是男人的浪漫！！！337.《英雄时代》——一部未来的恢宏史诗！338.《战姬绝唱》——热血，百合，战斗。。。哦，卖歌的番剧。339.《超时空要塞△》——超级魔性而洗脑的，giligili爱，嗨得停不下来。340.《超时空要塞F》——传世经典语录，你们都是我的翅膀341.《麻辣教师GTO》——从真人电影版过来补番，鬼冢英吉，敬礼，你是最棒的老师！342.《王者天下》——日本国民级漫画，架空的中国战国史，唯有“震撼”可一言蔽之！强烈安利一波真人版(山崎贤人，长泽雅美，吉泽亮，桥本环奈)343.《哆啦A梦》——2020年3月7日，B站连蓝胖子的版权都买了，牛逼！(破音</del>)344.《命运—冠位指定 绝对魔兽战线 巴比伦尼亚》——高质量的Fate系列啊，冲冲冲！345.《阿拉德战记》——DNF改编的热血战斗动漫，我的青春系列<del>346.《BASQUASH!》——飞篮扣杀，一个集体育，魔幻，热血，广告(…)的神奇番，光是下野紘，小林由美子，钉宫理惠，户松遥，早见沙织等超豪华声优阵容就够了。347.《甜甜私房猫》——子供向，但细腻的剧情时隔多年依然能够感动每一个成年人。348.《爱书的下克上:为了成为图书管理员不择手段》——因为太喜欢读书，被掉落的书砸死后，小女主开始了起点种田文生活(…)慢热型的小书痴真心好看啊</del>349.《GJ部》——搞基部的日常生活350.《空罐少女》——开罐有惊喜，空罐美少女。这易拉罐去哪里买啊！！！351《奇异太郎少年的妖怪绘日记》——为妖怪为背景的单元喜剧，泡面番看的很舒心。352.《白箱SHIROBAKO》——PA社迄今为止评分最高的一部动画(A站)，经典梗，万策尽。喵森(武藏野车神)<del>绘麻(小天使)</del>静香(又温柔又坚强)<del>美纱(3D大佬)</del>小绿(内燃机同学)<del>23集神回，追梦的人永远都会幸福。353.《动物新世代/BNA》——扳机社吹爆，furry厨狂欢，吉成曜，永远滴神354.《乃木阪春香的秘密》——经典老番就是鲜甜鲜甜的，从《好想告诉你》开始就特别喜欢能登麻美子的声线355.《超级小白》——蜡笔小新的衍生物，泡面番356.《弹丸论破》——游戏改编，封闭式“狼人杀”，让我想起了看过的系列电影《狼人游戏》，看完以后做梦还能梦见那鬼畜的黑白熊357.《我想吃掉你的胰脏》——恋恋手记，平静的哀伤，以及揪心的疼痛，ED春夏秋冬强推358.《宝石商人理查德的谜鉴定》——轻耽美，要么看宝石要么看帅哥，赏心悦目吧359.《异度侵入ID:INVADED》——真·脑洞番，我喜欢这种推理和心理博弈的感觉(关弹幕)360.《春园庄的管理人小姐》——这番剧厉害了，小正太与大姐姐的故事(B站港澳台区)367.《虚构推理》——出色的人设，甜甜的狗粮。(祢豆子换片场变成满嘴开车的话痨了，笑)368.《请在T台上微笑》——时装模特和服装设计师的励志成长故事(A站)369.《犬夜叉完结篇》——阿篱，桔梗，犬夜叉，奈落，弥勒法师，珊瑚，冥加老爷爷，杀生丸杀殿……这么多年了，仍然记忆犹新。感谢B站。370.《思维覆写》——PET佳作，人设优秀，故事精彩，立意深刻，收尾绝妙，画风和基腐可能会劝退一部分观众371.《隐瞒之事》——老父亲养女儿的沙雕日常372.《IDOLiSH7—偶像星愿》——爱娜娜</del>我一直以为是乙女向，没想到我这个直男看的如此津津有味，一部很舒服的励志偶像群像。373.《阿尔蒂》——真·文艺复兴，热爱绘画的追梦少女的成长故事374.《无印》《超世代》《钻石珍珠》《日月》等——没想到，B站把神奇宝贝系列都陆续买下来了，感动。375.《无限系统树》——异世界，虚拟现实游戏，观感尚可，喜欢的人会很喜欢。376.《黑塔利亚》——第一次世界大战到第二次世界大战的世界史科普，拟人化的展示，寓教于乐。377.《不愉快的怪物庵》——治愈，暖心，搞笑，人妖(……)呃，绝对我心目中的是宝藏番之一，爱了爱了。378.《湘南纯爱组》——老番新看，也就看了十几遍吧。379.《石纪元》——葱头哥的科技种田流生活380.《公主连接－Re:Dive》——氪金手游的超豪华广告，这经费爆炸。381.《影之诗》——集换式卡牌游戏改编，游戏王既视感382.《转生成为了只有乙女游戏破灭Flag的邪恶大小姐》——为了活下去，野猴子不得不攻略男主，女主，男配，女配…好像哪里不对，原来是后宫番。野猴子笑死我了。哈哈哈。383.《只想受你欢迎》——五等分花嫁性转版，松岗你也有今天，哈哈。<br>PS.《公主恋人》——我真的没有看过OVA！（欢迎补充）<br>强烈安利一波台湾布袋戏——霹雳布袋戏(台独，算了，退坑了<a href="https://www.zhihu.com/question/382103725" target="_blank" rel="noopener">https://www.zhihu.com/question/382103725</a> )，金光布袋戏系列有点乱，原谅工作党哈。以后，有空重新整理一遍，把国漫，日漫，动漫电影，非B站的优秀动漫(化物语，巨人，食尸鬼，寄生兽，银魂，狂赌之渊，监狱学园，Another，高分少女1，哥布林杀手，相聚一刻，死亡笔记，出包王女，政宗君的复仇，恶魔人，炎拳(漫画)，电锯人(漫画))等分类介绍。作为一名非死宅，不知不觉也阅番无数了，满满都是回忆啊</p><p><a href="https://www.zhihu.com/question/64436442/answer/221375336" target="_blank" rel="noopener">编辑于 2020-04-24</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DNS原理</title>
    <link href="/2020/04/24/DNS%E5%8E%9F%E7%90%86/"/>
    <url>/2020/04/24/DNS%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>什么是DNS</strong></p><p>DNS就是域名系统，是因特网中的一项核心服务，是用于实现域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p><p><strong>域名结构解析</strong></p><p><a href="https://pic1.zhimg.com/80/v2-d4ebb1c03acc11c40aa2d0624e98f9f8_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-d4ebb1c03acc11c40aa2d0624e98f9f8_720w.jpg</a></p><p>如上图所示，域名结构是树状结构，树的最顶端代表根服务器，根的下一层就是由我们所熟知的.com、.net、.cn等通用域和.cn、.uk等国家域组成，称为顶级域。网上注册的域名基本都是二级域名，比如<a href="https://link.zhihu.com/?target=http%3A//baidu.com">http://baidu.com</a>、<a href="https://link.zhihu.com/?target=http%3A//taobao.com">http://taobao.com</a>等等二级域名，它们基本上是归企业和运维人员管理。接下来是三级或者四级域名，这里不多赘述。总体概括来说域名是由整体到局部的机制结构。</p><p><strong>DNS解析流程</strong></p><p><a href="https://pic1.zhimg.com/v2-f1e081e30e47c8c1f5af6b944d6eda3c_r.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/v2-f1e081e30e47c8c1f5af6b944d6eda3c_r.jpg</a></p><p>如上图所示，我们将详细阐述DNS解析流程。</p><p>1、首先客户端位置是一台电脑或手机，在打开浏览器以后，比如输入<a href="https://link.zhihu.com/?target=http%3A//www.zdns.cn">http://www.zdns.cn</a>的域名，它首先是由浏览器发起一个DNS解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里面记录的都是各个顶级域所在的服务器的位置，当向根请求<a href="https://link.zhihu.com/?target=http%3A//www.zdns.cn">http://www.zdns.cn</a>的时候，根服务器就会返回.cn服务器的位置信息。</p><p>2、递归服务器拿到.cn的权威服务器地址以后，就会寻问cn的权威服务器，知不知道<a href="https://link.zhihu.com/?target=http%3A//www.zdns.cn">http://www.zdns.cn</a>的位置。这个时候cn权威服务器查找并返回<a href="https://link.zhihu.com/?target=http%3A//zdns.cn">http://zdns.cn</a>服务器的地址。</p><p>3、继续向<a href="https://link.zhihu.com/?target=http%3A//zdns.cn">http://zdns.cn</a>的权威服务器去查询这个地址，由<a href="https://link.zhihu.com/?target=http%3A//zdns.cn">http://zdns.cn</a>的服务器给出了地址：202.173.11.10</p><p>4、最终才能进行http的链接，顺利访问网站。</p><p>5、这里补充说明，一旦递归服务器拿到解析记录以后，就会在本地进行缓存，如果下次客户端再请求本地的递归域名服务器相同域名的时候，就不会再这样一层一层查了，因为本地服务器里面已经有缓存了，这个时候就直接把<a href="https://link.zhihu.com/?target=http%3A//www.zdns.cn">http://www.zdns.cn</a>的A记录返回给客户端就可以了。</p><p><strong>DNS资源记录</strong></p><p><a href="https://pic1.zhimg.com/80/v2-d218f4a55c62ad85a043f5bc71bbf3c4_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-d218f4a55c62ad85a043f5bc71bbf3c4_720w.jpg</a></p><p>记录一条域名信息映射关系，称之为资源记录（RR）。</p><p>当我们查询域名<a href="https://link.zhihu.com/?target=http%3A//www.zdns.cn">http://www.zdns.cn</a>的时候，查询结果得到的资源记录结构体中有如下数据：</p><p>1、TTL，就是生存周期，是递归服务器会在缓存中保存该资源记录的时长。</p><p>2、网络/协议类型，它的代表的标识是IN，IN就是internet，目前DNS系统主要支持的协议是IN。</p><p>3、type，就是资源记录类型，一般的网站都是都是A记录（IPv4的主机地址）。</p><p>4、rdata是资源记录数据，就是域名关联的信息数据。</p><p><strong>小知识：</strong></p><p>下面我们列出几条常用的资源记录类型：</p><p>A ：Address地址， IPv4</p><p>AAAA：Address地址 IPv6</p><p>NS ：Name Server域名服务器</p><p>SOA：Start of Authority起始授权机构</p><p>MX：Mail Exchanger邮件交换</p><p>CNAME：Canonical Name规范名</p><p>PTR：Pointer指针</p><p>TXT：Text</p><p>SRV：Service</p><p><strong>DNS服务器的分类</strong></p><p><a href="https://pic2.zhimg.com/80/v2-eabb1795b1e3b84a82fc280ba2154639_720w.jpg" target="_blank" rel="noopener">https://pic2.zhimg.com/80/v2-eabb1795b1e3b84a82fc280ba2154639_720w.jpg</a></p><p>常见的DNS服务器就是两种：权威解析服务器和递归解析服务器。递归解析服务器也可以叫做localDNS。</p><p><strong>权威解析服务器</strong></p><p>DNS权威服务器保存着域名空间中部分区域的数据。如果DNS服务器负责管辖一个或多个区域时，称此DNS服务器为这些区域的权威服务器。</p><p>根权威DNS或者二级权威服务器中的资源记录标记被指定为区域权威服务器的DNS服务器。通过资源记录中列出服务器，其他服务器就认为它是该区域的权威服务器。这意味着在 NS 资源记录中指定的任何服务器都被其他服务器当作权威的来源，并且能肯定应答区域内所含名称的查询。</p><p><strong>递归服务器</strong></p><p>递归服务器在正常情况下，初始的时候里面没有任何域名解析数据，里面所有的域名解析数据都来自于它到权威解析服务器的查询结果，一旦查询完毕，递归服务器就会根据TTL时间在本地形成一条缓存记录，并为用户提供DNS解析的查询服务，这是递归服务器的功能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>https和http</title>
    <link href="/2020/04/23/https%E5%92%8Chttp/"/>
    <url>/2020/04/23/https%E5%92%8Chttp/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是协议？"><a href="#1-什么是协议？" class="headerlink" title="1.什么是协议？"></a><strong>1.什么是协议？</strong></h3><p>网络协议是计算机之间为了实现网络通信而达成的一种“约定”或者”规则“，有了这种”约定“，不同厂商的生产设备，以及不同操作系统组成的计算机之间，就可以实现通信。</p><h3 id="2-HTTP协议是什么？"><a href="#2-HTTP协议是什么？" class="headerlink" title="2.HTTP协议是什么？"></a><strong>2.HTTP协议是什么？</strong></h3><p>HTTP协议是<strong>超文本传输协议</strong>的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。</p><p>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p><p>HTPP有多个版本，目前广泛使用的是HTTP/1.1版本。</p><h3 id="3-HTTP原理"><a href="#3-HTTP原理" class="headerlink" title="3.HTTP原理"></a>3.HTTP原理</h3><p>HTTP是一个基于TCP/IP通信协议来传递数据的协议，传输的数据类型为HTML 文件,、图片文件, 查询结果等。</p><p>HTTP协议一般用于B/S架构（）。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>我们以访问百度为例：</p><p><a href="https://pic4.zhimg.com/80/v2-fbef2c48d13068978904f3d1688728ab_720w.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/80/v2-fbef2c48d13068978904f3d1688728ab_720w.jpg</a></p><h3 id="4-HTTP特点"><a href="#4-HTTP特点" class="headerlink" title="4.HTTP特点"></a>4.HTTP特点</h3><ol><li>http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</li><li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</li><li>无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li></ol><h3 id="5-URI和URL的区别"><a href="#5-URI和URL的区别" class="headerlink" title="5.URI和URL的区别"></a>5.URI和URL的区别</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><ul><li>URI：Uniform Resource Identifier 统一资源<strong>标识</strong>符</li><li>URL：Uniform Resource Location 统一资源<strong>定位</strong>符</li></ul><p>URI 是用来标示 一个具体的资源的，我们可以通过 URI 知道一个资源是什么。</p><p>URL 则是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。</p><h3 id="6-HTTP报文组成"><a href="#6-HTTP报文组成" class="headerlink" title="6.HTTP报文组成"></a>6.HTTP报文组成</h3><h3 id="请求报文构成"><a href="#请求报文构成" class="headerlink" title="请求报文构成"></a><strong>请求报文构成</strong></h3><ol><li><p>请求行：包括请求方法、URL、协议/版本</p></li><li><p>请求头(Request Header)</p></li><li><p>请求正文</p><p><a href="https://pic4.zhimg.com/80/v2-770cc76b2cb7da75d04a886015a9565b_720w.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/80/v2-770cc76b2cb7da75d04a886015a9565b_720w.jpg</a></p></li></ol><h3 id="响应报文构成"><a href="#响应报文构成" class="headerlink" title="响应报文构成"></a>响应报文构成</h3><ol><li>状态行</li><li>响应头</li><li>响应正文</li></ol><p><a href="https://pic4.zhimg.com/80/v2-58506e2188987db01ffb1589e208d83b_720w.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/80/v2-58506e2188987db01ffb1589e208d83b_720w.jpg</a></p><h3 id="7-常见请求方法"><a href="#7-常见请求方法" class="headerlink" title="7.常见请求方法"></a>7.常见请求方法</h3><ul><li>GET:请求指定的页面信息，并返回实体主体。</li><li>POST:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li><li>HEAD:类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li><li>PUT:从客户端向服务器传送的数据取代指定的文档的内容。</li><li>DELETE:请求服务器删除指定的页面。</li></ul><p><strong>get请求</strong></p><p><a href="https://pic4.zhimg.com/80/v2-c3de118ff545b4d49e07874063c34a4f_720w.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/80/v2-c3de118ff545b4d49e07874063c34a4f_720w.jpg</a></p><p><strong>post请求</strong></p><p><a href="https://pic4.zhimg.com/80/v2-770cc76b2cb7da75d04a886015a9565b_720w.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/80/v2-770cc76b2cb7da75d04a886015a9565b_720w.jpg</a></p><p><strong>post和get的区别：</strong></p><ul><li>都包含请求头请求行，post多了请求body。</li><li>get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。</li><li>GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。</li><li>GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。</li></ul><h3 id="8-响应状态码"><a href="#8-响应状态码" class="headerlink" title="8.响应状态码"></a>8.响应状态码</h3><p><strong>访问一个网页时，浏览器会向web服务器发出请求。此网页所在的服务器会返回一个包含HTTP状态码的信息头用以响应浏览器的请求。</strong></p><p><strong>状态码分类</strong>：</p><ul><li>1XX- 信息型，服务器收到请求，需要请求者继续操作。</li><li>2XX- 成功型，请求成功收到，理解并处理。</li><li>3XX - 重定向，需要进一步的操作以完成请求。</li><li>4XX - 客户端错误，请求包含语法错误或无法完成请求。</li><li>5XX - 服务器错误，服务器在处理请求的过程中发生了错误。</li></ul><p><strong>常见状态码</strong>：</p><ul><li>200 OK - 客户端请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>302 - 临时跳转</li><li>400 Bad Request - 客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>404 - 请求资源不存在，可能是输入了错误的URL</li><li>500 - 服务器内部发生了不可预期的错误</li><li>503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li></ul><h3 id="9-为什么要用https？"><a href="#9-为什么要用https？" class="headerlink" title="9.为什么要用https？"></a>9.为什么要用https？</h3><p>实际使用中，绝大说的网站现在都采用的是https协议，这也是未来互联网发展的趋势。下面是通过wireshark抓取的一个博客网站的登录请求过程。</p><p><a href="https://pic1.zhimg.com/80/v2-f300863d073601e3a14affae37cedae8_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-f300863d073601e3a14affae37cedae8_720w.jpg</a></p><p>可以看到访问的账号密码都是明文传输， 这样客户端发出的请求很容易被不法分子截取利用，因此，HTTP协议不适合传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信息非常不安全。</p><p><strong>一般http中存在如下问题：</strong></p><ul><li>请求信息明文传输，容易被窃听截取。</li><li>数据的完整性未校验，容易被篡改</li><li>没有验证对方身份，存在冒充危险</li></ul><h3 id="10-什么是HTTPS"><a href="#10-什么是HTTPS" class="headerlink" title="10.什么是HTTPS?"></a>10.什么是HTTPS?</h3><p>为了解决上述HTTP存在的问题，就用到了HTTPS。</p><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p><p><strong>那么SSL又是什么？</strong></p><p>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><p><strong>SSL发展史（互联网加密通信）</strong></p><ol><li>1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。</li><li>1995年NetSpace发布SSL/2.0版本，很快发现有严重漏洞</li><li>1996年发布SSL/3.0版本，得到大规模应用</li><li>1999年，发布了SSL升级版TLS/1.0版本，目前应用最广泛的版本</li><li>2006年和2008年，发布了TLS/1.1版本和TLS/1.2版本</li></ol><h3 id="11-浏览器在使用HTTPS传输数据的流程是什么？"><a href="#11-浏览器在使用HTTPS传输数据的流程是什么？" class="headerlink" title="11.浏览器在使用HTTPS传输数据的流程是什么？"></a><strong>11.浏览器在使用HTTPS传输数据的流程是什么？</strong></h3><p><a href="https://pic4.zhimg.com/80/v2-a994fbf3094d737814fe01c2b919477b_720w.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/80/v2-a994fbf3094d737814fe01c2b919477b_720w.jpg</a></p><ol><li>首先客户端通过URL访问服务器建立SSL连接。</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。</li><li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>服务器利用自己的私钥解密出会话密钥。</li><li>服务器利用会话密钥加密与客户端之间的通信。</li></ol><h3 id="12-HTTPS的缺点"><a href="#12-HTTPS的缺点" class="headerlink" title="12.HTTPS的缺点"></a><strong>12.HTTPS的缺点</strong></h3><ul><li>HTTPS协议多次握手，导致页面的加载时间延长近50%；</li><li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；</li><li>申请SSL证书需要钱，功能越强大的证书费用越高。</li><li>SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</li></ul><h3 id="13-总结HTTPS和HTTP的区别"><a href="#13-总结HTTPS和HTTP的区别" class="headerlink" title="13.总结HTTPS和HTTP的区别"></a><strong>13.总结HTTPS和HTTP的区别</strong></h3><ul><li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。</li><li>http和https使用连接方式不同，默认端口也不一样，http是80，https是443。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次python面试</title>
    <link href="/2020/04/23/%E8%AE%B0%E4%B8%80%E6%AC%A1python%E9%9D%A2%E8%AF%95/"/>
    <url>/2020/04/23/%E8%AE%B0%E4%B8%80%E6%AC%A1python%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>1、写一个方法，传递两个参数，分别代表年份和月份，计算这个月的天数（可选）。</p><pre><code>import calendar monthRange = calendar.monthrange(2016,9) print(monthRange)</code></pre><p>2、编写一个健身器材类，要求Use()无参无返回值，负责打印“被使用中” Info()无参无返回值，负责打印设备的所有信息<br>2).<br>编写跑步机类，继承健身器类，在构造函数中修改默认为电力驱动<br>  i. 隐藏Use方法，打印“跑步机被使用中” </p><p>  ii. 添加字段：品牌 </p><p>3).编写哑铃，继承健身器类 隐藏Use方法，打印“哑铃被使用中”<br>4).在测试类中：<br>创建健身器列表，存放不同类型的健身器，依次执行每个元素的Use方法</p><pre><code>class Fitness_Equipment:  name=&#39;器材&#39;  def use(self,name):     print(&quot;被使用中!&quot;)  def info()   print(&quot;设备所有信息&quot;)class Treadmill(Fitness_Equipment):    def __init__(self):        print(&quot;我是电力驱动&quot;)     Treadmill.use(treadmill.self)   class Dumbbel(Fitness_Equipment)    dumbbel.use(treadmill.self) +</code></pre><p>3、寻找两个有序数组的中位数<br>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>则中位数是 2.0</p><p>示例 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>则中位数是 (2 + 3)/2 = 2.5</p><p>4、给定一个数组，它的第 i 个元素是第 i个的值。</p><p>如果你最多只允许完成一次比较，设计一个算法来计算出给定数组中两个数字之间的最大差值。</p><p>例如给定数列 [7,1,5,3,6,4]<br>输出应该是6</p><p>5、计算方阵中1的个数<br>给你一个大小为 m * n 的方阵 mat，方阵由若干1 和 0 。</p><p>请你返回方阵中最少的 k 行的索引，按从最少到最多排序。<br>如果第 i 行的1数量少于第 j 行，或者两行1数量相同但 i 小于 j，那么我们认为第 i 行小于第 j 行。<br>1 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p><p>例子1：<br>输入：mat =<br>[[1,1,0,0,0],<br> [1,1,1,1,0],<br> [1,0,0,0,0],<br> [1,1,0,0,0],<br> [1,1,1,1,1]],<br>k = 3</p><p>输出：[2,0,3]</p><p>每行中的1数目：<br>行 0 -&gt; 2<br>行 1 -&gt; 4<br>行 2 -&gt; 1<br>行 3 -&gt; 2<br>行 4 -&gt; 5<br>从最弱到最强对这些行排序后得到 [2,0,3,1,4]</p><p>例子2：<br>输入：mat =<br>[[1,0,0,0],<br> [1,1,1,1],<br> [1,0,0,0],<br> [1,0,0,0]],<br>k = 2<br>输出：[0,2]<br>解释：<br>每行中的1数目：<br>行 0 -&gt; 1<br>行 1 -&gt; 4<br>行 2 -&gt; 1<br>行 3 -&gt; 1<br>从最弱到最强对这些行排序后得到 [0,2,3,1]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次英语面试准备</title>
    <link href="/2020/04/23/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2020/04/23/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="套近乎-how-are-you"><a href="#套近乎-how-are-you" class="headerlink" title="套近乎:how are you ?"></a>套近乎:how are you ?</h2><p>i’m great(重音),how  are you.</p><p>(i took the suberway here,it’s great to finally meet you in person.)</p><p>how are you,</p><p>basic information:</p><p>my name is huangjie,nice to meeet you,you can call me “huang”,i’m 24years old,i was born and raised in  small-town henan xinyang, now living in hangzhou for a few weeks.i ‘m a Network engineering  student graduate from tian jing chengjian university.where i gained my Network engineering degree.i worked at seiweilanshi technology (Co. Ltd) for about 5 month as a  Technical Support.,i just started in the Technical Support group at  the company.  </p><h2 id="为啥离开前公司"><a href="#为啥离开前公司" class="headerlink" title="为啥离开前公司"></a>为啥离开前公司</h2><p> i want new career challenges.i want to advance my career,i think </p><p>the new job  ofers me more opportunities for me.</p><p>my longterm goals involve growing with the company,where i can continue to learn,take on additional responsibilities and contribute as much value as i can.i intend to take advantage of all this………………………</p><h2 id="薪资"><a href="#薪资" class="headerlink" title="薪资"></a>薪资</h2><p>my salary expectations are in line  with my experience and qualifications .i belive that you will pay  your employee fairly</p><h5 id="其他问题吗"><a href="#其他问题吗" class="headerlink" title="其他问题吗"></a>其他问题吗</h5><p>what’s the growth potential for this position?</p><h2 id="爱好-兴趣"><a href="#爱好-兴趣" class="headerlink" title="爱好,兴趣"></a>爱好,兴趣</h2><p>   i  enjoy ping pong,cooking,i’m an avid Marvel  fan.my favorite city is hangzhou and xingyang.(hangzhou is a city features a perfect blending of hill and water,and lake and town,with water resources,and a ubiquitous yet harmonious presence of rivers,canals,lakes,sea,creek.)hangzou’s picture nature view has earned the fame of “Paradise on earth” for milleniums.</p><p>well,xinyang is my hometown,it’s where i was burn and rise.</p><h2 id="你工作时遇到的最大的难题是什么？"><a href="#你工作时遇到的最大的难题是什么？" class="headerlink" title="你工作时遇到的最大的难题是什么？"></a>你工作时遇到的最大的难题是什么？</h2><p>One of our team members left us because we couldn’t reach an agreement on the task we were running. Even though it was difficult when she quit without notice, we still managed to rearrange the department workload to cover the position until a replacement was hired. Everyone was very busy then. But somehow it helped strengthen our abilities.</p><p>因为对正在进行的任务无法达成一致意见，我们的一位组员离开了我们。虽然她的离开给我们造成了很大困难，但是我们任然成功地重新分配了部门工作量，并且坚持到空缺被补上。那时每个人都很忙，但是这反而锻炼了我们的能力。</p><p>Once, we were faced with a sudden order increase for our new product. It was for a new customer. I immediately sat down with the production supervisor, our materials manager, and the union steward. We were able to lay out a workable plan that maximized hourly labor costs, guaranteed materials were available and, with only a sight adjustment, met the production deadline. While it was challenging and involved long hours, the pay-off was a signed contract with a new customer.</p><p>有一次我们遇到了新产品突然增加订单，是一位新客户。我立刻与生产主任、材料经理、工会代表开会协商。我们制定出来一个可行方案，最大化每小时的劳动量，保证材料供应，而且仅仅用了一个微小的调整，我们就赶上了交货日期。这件事很具挑战性，投入了大量的时间，但是回报很丰厚，我们与新客户签订了合约。</p><p>When I was working on a software implementation team, we took over another company and had to transit many clients to a new product in a short amount of time. It took a lot of planning, time, hard work and effort, but we were able to complete the project in a timely manner.</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>i’m looking forward to working with everyone.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tcp,ip</title>
    <link href="/2020/04/23/tcp,ip/"/>
    <url>/2020/04/23/tcp,ip/</url>
    
    <content type="html"><![CDATA[<p><a href="https://pic4.zhimg.com/80/v2-b336a50e1d671a5ef82f532c492474fe_720w.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/80/v2-b336a50e1d671a5ef82f532c492474fe_720w.jpg</a></p><p>在日常生活中，我们要传递信息，以前最常用的手段是邮寄信件，想象一下你写信寄信的过程，写信产生数据，寄信传递数据，标准的信件格式是要在信封上写“<strong>收信人地址”</strong>和“<strong>寄信人地址”</strong>（由此引入IP地址），“<strong>收信人地址”</strong>对应数据包里IP头部中的“<strong>目的ip地址”</strong>，“<strong>寄信人地址”</strong>对应数据包里IP头部中的“<strong>源ip地址”</strong>，写上寄信、收信两个地址就可以保证信件可以邮寄到目的地了。</p><p><a href="https://pic1.zhimg.com/80/v2-5eea93c9e2e93e95154cd9c28b8baf6b_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-5eea93c9e2e93e95154cd9c28b8baf6b_720w.jpg</a></p><p>但信件邮寄到目的地址后由谁来收？从上面这封信的收件人地址检索到这个地址是“沈阳大学”的，沈阳大学里可能住着几万人，那你这封信是邮寄给居住沈阳大学里的那个人的？收件人不明确，邮局就算帮你把信件送到这个地址，也没办法帮你投递到具体的收信人。</p><p>因此，我们邮件信件需要填写“收件人姓名”、“收件人地址”和“寄件人姓名”、“寄件人地址”的组合，这样才能保证信件能准确投递到具体的收件人手中。</p><p><a href="https://pic1.zhimg.com/80/v2-7d2263e0134aa3edfd5aa12e20378923_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-7d2263e0134aa3edfd5aa12e20378923_720w.jpg</a></p><p>所以我们要在信件上添加<strong>收信人姓名</strong>和<strong>寄信人姓名</strong>（由此引入端口号），这个时候收件人姓名就对应数据包里TCP协议头部中的目的端口号，寄信人姓名对应数据包里TCP协议头部中的源端口号。</p><p><strong>我们再来对比传递信件与传递数据包的过程：</strong></p><p>1.首先是位于南宁的李小明给沈阳的王小花通过QQ发送了一条消息，李小明的电脑将此消息打包成TCP数据包发送到计算机网络中，计算机网络通过数据包中的<strong>目的IP地址</strong>把该数据包准确传递到王小花的电脑。</p><p><a href="https://pic1.zhimg.com/80/v2-1c35961cf3cfbc613e635c95f2a0a161_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-1c35961cf3cfbc613e635c95f2a0a161_720w.jpg</a></p><p>2.王小花的电脑收到了李小明的电脑发送过来的数据包，但是王小花的电脑上同时运行有多个程序（例如图中的QQ和微信），虽然王小花的电脑知道这个数据包是传输给它的，但是它不知道该把这个数据包中的数据交给那个程序（就像上面讲的，信件虽然邮寄到了沈阳大学，但沈阳大学里住着那么多人，这封信上没有标示说是邮寄给谁的）。</p><p><a href="https://pic3.zhimg.com/80/v2-5d85e9ae6d3aea64fb94c8374268687b_720w.jpg" target="_blank" rel="noopener">https://pic3.zhimg.com/80/v2-5d85e9ae6d3aea64fb94c8374268687b_720w.jpg</a></p><p>3.针对以上的问题。如果我们使用数据包结构中的源端口号和目的端口号，根据不同的程序使用不同的端口号来发送和接受数据，这样数据包就能像邮寄信件一样准确投递到具体的电脑上指定的程序了。例如我们指定QQ和微信使用的端口号分别是8000和8080，那么只要你的电脑接收的数据包里目的端口号是8000，那这个数据包就是传输给QQ的。</p><p><a href="https://pic1.zhimg.com/80/v2-8277699b99838f4cf4c593e2853c5b4c_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-8277699b99838f4cf4c593e2853c5b4c_720w.jpg</a></p><p><a href="https://pic2.zhimg.com/80/v2-5eb9bd32e989d1ee787fd1584fbf2bc2_720w.jpg" target="_blank" rel="noopener">https://pic2.zhimg.com/80/v2-5eb9bd32e989d1ee787fd1584fbf2bc2_720w.jpg</a></p><p>由上面的例子我们还可以引申出数据包结构中的其他字段的作用，例如我们收到信后可以简单地通过信封是否完整来检查该信件是否被别人在传输途中拆开并篡改过信件内容，那么我们怎么保证我们收到的数据包里的数据有没有在中途被别人拆开修改过呢？数据包结构中有一个字段叫TCP校验和就是专门做这个工作的。由数据包的字段可以看出，很多字段都有其用处，只是我们一开始学的时候没必要学的那么仔细而已。</p><p>一定要形象地理解数据包，简单的想一下，计算机网络不就是帮助我们传递信息的吗？对于邮寄信件来说，信息的载体是信纸和信封，那计算机网络中信息的载体是什么？就是各种类型的数据包啊！ 数据包里有我们关心的信息，也有我们不关心的花销，我们要学的就是如何使网络按照我们的要求传递信息。例如，我们邮寄信件，有平信，有挂号信，根据不同的应用场景选择不同的邮寄方式。计算机网络里信息传输也是一样，针对不同的场景使用不同的协议， 有些场景需要多种协议同时配合使用。</p><p>上面那个QQ的例子不太严谨，因为QQ和微信的信息都是通过腾讯服务器中转的，但你是初学者没必要一开始就深究这些细节，总之要学会把一切抽象的东西都对照生活中的一些场景使之形象化。这样你的学习过程就不会那么枯燥乏味了。</p><p>再来看一下为什么需要网络协议，我们看下图的简单类比：</p><p><a href="https://pic1.zhimg.com/80/v2-c3838237fb8de37bb00ac390667d3dd0_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-c3838237fb8de37bb00ac390667d3dd0_720w.jpg</a></p><p>从上图可以看出，我们邮寄信件只是想要把我们写在信纸信息传递出去，对于我们来说，邮寄信件需要购买信封和邮票，这对于我们来说是没有意义的，甚至我们会觉得连信纸都是多余的，因为还要购买信纸，我们只是想传递信息而已，信封、邮票和信纸对于我们来说是传递信息的额外花销，但是没有这些花销，你的信息就无法通过邮局传递。同理，在计算机网络里也是一样的，我们的通过计算机网络传递信息也需要额外的花销，这些花销体现在计算机网络里就是TCP/IP的各种协议数据包的头部（除去应用层数据之外的其他信息）。</p><p>你要知道计算机网络里的数据交换都是像我们日常邮寄信件一样通过各种的数据包来传递的，理解了数据包的作用之后你就应该开始学习计算机网络是如何把数据包传输到目的地的？例如我们的电脑在生成数据包时是怎么知道对方电脑的ip地址的，（由此引入DNS）？我们的信件是最开始是通过邮局帮我们邮寄的，那么我们的电脑的数据包应该由谁来帮我们传输呢？（由此引入网关），网关又是如何帮我们把数据包传输到目的地的？（由此引入各种路由协议）。</p><p>所以，你想要学习网络协议，就要先把一些基本的协议的作用和工作过程搞清楚，网络设备还没智能到人脑的程度，它是由人类创造出来的，它的工作过程肯定是符合人类的交流习惯，按照人类的交流习惯来设计的。所以要以人类的思维方式去理解这些协议。例如，你给别人打电话，不可能电话一接通你就啪啦啪啦地说一大通，万一对方接通电话后因为有事还没来得及倾听呢？这不太符合正常人类的交流习惯。一般是电话接通后，双方一般会有个交互的过程，一般是你说一声“你好”，然后对方也回复一声“你好”，双方通过各自一句“你好”明确对方的注意力都放在了电话沟通上，然后你们双方就可以开始交流了，这才是正常的人类交流方式，这个过程体现在计算机网络里就是网络协议！我们通过TCP协议在两台电脑建立网络连接之前要先发数据包进行沟通，沟通后再建立连接，然后才是信息的传输。而UDP协议就类似于我们的校园广播，广播内容已经通过广播站播放出去了，你能不能听到，那就与广播站无关了，正常情况下，不可能你说没注意听然后再让广播站再播放一次广播内容。</p><p>同理，我们来看一下网络广播，对于某一个网络的网络广播，只要发送一个网络广播包，这个子网里的所有电脑都能收到这些广播包，这是一个很方便的通知机制，但是会增加对广播数据不感兴趣主机的处理负荷。类似我们的校园广播，校园广播一开启播放，校园里的所有人都能听到，但是不是所有人都对广播内容感兴趣，有些人选择倾听，有些人选择忽略。但不管你是倾听还是忽略，广播的声音都会传到你的耳边。例如，校园广播一条失物招领通知，你根本没丢东西，所以这个广播内容与你无关，但是广播的声音还是会传到你的耳边。对比广场舞音乐，对于跳广场舞的大妈大婶来说，这就是音乐，对于想睡觉的您来说，这就是噪音。</p><p>怎样才能更好地理解常见的网络协议？学习网络协议就是要先学习它的工作过程，例如DHCP协议，协议大概是这样讲的：启用了DHCP协议的电脑启动后便会发送广播数据包网络中寻找DHCP服务器，如果网络中有DHCP服务器，这台DHCP服务器便会发送广播数据包与你的电脑进行响应。</p><p>这个过程很简单，就是我想要获取ip地址，然后你给我提供一个。想象一下如果你是DHCP协议的设计者，你会考虑到在ip获取和分配过程中会有哪些特殊情况呢？</p><p>第一种，如果在你启动电脑的过程中网络中的dhcp服务器刚好宕机了，这时怎么办？让你的电脑一直徒劳地发送寻找DHCP服务器的广播包吗？还是在发现没有DHCP服务器与你响应后就再也不发了？还是每隔一段时间就再发送一次寻找DHCP服务器的广播包？</p><p>第二种，如果DHCP服务器的可用ip地址刚好已经分配完了，那又怎么处理？</p><p>第三种，如果网络中同时有两台以上的DHCP服务器，那又该怎么处理？</p><p>第四种，对于已经分配出去的ip地址就这么一直保持分配出去的状态吗？还是要回收？如果要回收？是我去问你还要不要使用这个ip地址？还是我设定一个回收的时间？只要你在这个时间段内你没有再次联系我重新获取这个ip地址我就把它回收？等等。。。</p><p>通过这样的思考你可以发现，网络协议其实也是按照人的思维方式在工作，但是网络设备不会像人一样思考，所以我们当初给它设计各种协议的时候就要尽可能地为它想到这些协议所要应对的场景。例如，你可以先学习ARP协议的工作过程，然后再百度搜索ARP攻击是怎么回事？就是利用ARP协议设计的不严谨，伪造ARP数据包篡改网络里其他电脑的ARP缓存列表。ARP协议采用广播发送协议数据包，这就导致里网络里的每一台电脑都会收到ARP的协议数据包，而ARP协议规定即使你的电脑没有发出arp请求，只要有ARP回应包到达你的主机，你就要对这些协议包进行处理，并将回应包中的mac和ip对应关系放入自己的arp缓存。如果ARP回应包里面的网关IP与ARP对应关系是正确的，这个问题不大，但如果有人在网络中伪造了错误的网关IP与ARP对应关系并广播到网络里，那就出问题了，你可能也意识到你上不了网是因为网关IP对应的ARP对应关系出错，但是没有办法，因为你的电脑上运行的ARP协议规定，你的电脑必须要接受这个错误的对应关系，这就是网络协议设计的不严谨，设计和实现ARP协议的时候没有想到居然会有人在网络中伪造ARP回应包并广播到网络中。</p><p>强烈建议看《计算机网络自顶向下方法与Internet特色》这本书，这本书对常见的网络协议的工作过程进行了分析，可读性很强，看起来比《TCP/IP详解》轻松多了，了解了常见协议的工作过程你就可以动手做实验来验证这个协议的工作过程了，建议先使用模拟器来做实验，像cisco packet tracer 就很好用，它有个模拟功能可以像看动画一样看到网络数据包是如何在网络拓扑结构中传输和交互的，对了解协议的工作过程非常有用，还有抓取数据包的功能，可以抓去指定协议的数据包进行查看。</p><p>使用真实设备通过在电脑上安装抓包工具进行抓包也可以，只不过没有模拟器上看得那么直观，对于初学者还是建议先以模拟器做实验为主，因为你可以很直观地观察你所设计的网络的运行情况，更容易把心放在学习网络协议的工作过程上。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解释Python是如何实现继承的</title>
    <link href="/2020/04/20/%E8%A7%A3%E9%87%8APython%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84/"/>
    <url>/2020/04/20/%E8%A7%A3%E9%87%8APython%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="解释Python是如何实现继承的。"><a href="#解释Python是如何实现继承的。" class="headerlink" title="解释Python是如何实现继承的。"></a>解释Python是如何实现继承的。</h1><p> 对于你定义的每一个类，Python会计算出一个所谓的方法解析顺序(MRO)列表。 这个MRO列表就是一个简单的所有基类的线性顺序表。例如：</p><pre><code>&gt;&gt;&gt; C.__mro__(&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;,&lt;class &#39;__main__.Base&#39;&gt;, &lt;class &#39;object&#39;&gt;)&gt;&gt;&gt;</code></pre><p>为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p><p>而这个MRO列表的构造是通过一个C3线性化算法来实现的。 我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则：</p><ul><li>子类会先于父类被检查</li><li>多个父类会根据它们在列表中的顺序被检查</li><li>如果对下一个类存在两个合法的选择，选择第一个父类</li></ul><p>老实说，你所要知道的就是MRO列表中的类顺序会让你定义的任意类层级关系变得有意义。</p><p>当你使用 <code>super()</code> 函数时，Python会在MRO列表上继续搜索下一个类。 只要每个重定义的方法统一使用 <code>super()</code> 并只调用它一次， 那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次。 这也是为什么在第二个例子中你不会调用两次 <code>Base.__init__()</code> 的原因。</p><p><code>super()</code> 有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类， 你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类：</p><pre><code>class A:    def spam(self):        print(&#39;A.spam&#39;)        super().spam()</code></pre><p>如果你试着直接使用这个类就会出错：</p><pre><code>&gt;&gt;&gt; a = A()&gt;&gt;&gt; a.spam()A.spamTraceback (most recent call last):    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    File &quot;&lt;stdin&gt;&quot;, line 4, in spamAttributeError: &#39;super&#39; object has no attribute &#39;spam&#39;&gt;&gt;&gt;</code></pre><p>但是，如果你使用多继承的话看看会发生什么：</p><pre><code>&gt;&gt;&gt; class B:...     def spam(self):...         print(&#39;B.spam&#39;)...&gt;&gt;&gt; class C(A,B):...     pass...&gt;&gt;&gt; c = C()&gt;&gt;&gt; c.spam()A.spamB.spam&gt;&gt;&gt;</code></pre><p>你可以看到在类A中使用 <code>super().spam()</code> 实际上调用的是跟类A毫无关系的类B中的 <code>spam()</code> 方法。 这个用类C的MRO列表就可以完全解释清楚了：</p><pre><code>&gt;&gt;&gt; C.__mro__(&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;,&lt;class &#39;object&#39;&gt;)&gt;&gt;&gt;</code></pre><p>在定义混入类的时候这样使用 <code>super()</code> 是很普遍的。可以参考8.13和8.18小节。</p><p>然而，由于 <code>super()</code> 可能会调用不是你想要的方法，你应该遵循一些通用原则。 首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。 这样可以确保 <code>super()</code> 调用一个非直接父类方法时不会出错。 其次，最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法。</p><p>在Python社区中对于 <code>super()</code> 的使用有时候会引来一些争议。 尽管如此，如果一切顺利的话，你应该在你最新代码中使用它。 Raymond Hettinger为此写了一篇非常好的文章 <a href="http://rhettinger.wordpress.com/2011/05/26/super-considered-super" target="_blank" rel="noopener">“Python’s super() Considered Super!”</a> ， 通过大量的例子向我们解释了为什么 <code>super()</code> 是极好的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python类</title>
    <link href="/2020/04/20/Python%E7%B1%BB/"/>
    <url>/2020/04/20/Python%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Python类定义"><a href="#一、Python类定义" class="headerlink" title="一、Python类定义"></a>一、Python类定义</h1><p>类是用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p><h1 id="二、Python创建类"><a href="#二、Python创建类" class="headerlink" title="二、Python创建类"></a>二、Python创建类</h1><p>使用<strong>class</strong>语句来创建一个新类，class之后为类的名称并以冒号结尾，类的组成包括成员变量和成员函数。</p><p>注意：python2.2后继承object的目的是使这个类成为new style class，没有继承object的为传统的classic class。</p><p>示例：</p><pre><code class="ruby">class user(object):#一般都写成继承object&quot;user information &quot;name=&#39;emma&#39;age=&#39;18&#39;def who(self):print &#39;My name is &#39;+self.name +&quot;.I&#39;m&quot;+str(self.age)+&#39;years old.&#39;</code></pre><h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><p><strong>1）类中的成员函数必须跟参数self。</strong><br> <strong>2）成员函数调用成员变量时也要加上self。</strong></p><h1 id="三、Python构造函数和析构函数"><a href="#三、Python构造函数和析构函数" class="headerlink" title="三、Python构造函数和析构函数"></a>三、Python构造函数和析构函数</h1><p>1.<code>__init__()</code>方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法。<br> 2.<code>__del__ ()</code>，被称为类的析构函数，<code>__del__()</code>在对象消逝的时候被调用，当对象不再被使用时，<code>__del__()</code>方法运行。<br> 示例：</p><pre><code class="ruby">class user(object):&quot;user information&quot;count=0def __init__(self,name,age):self.name=nameself.age=ageuser.count+=1def who(self):print &#39;My name is &#39;+self.name +&quot;.I&#39;m&quot;+str(self.age)+&#39;years old.&#39;def __del__(self):class_name=self.__class__.__name__print class_name,&quot;destroyed&quot;</code></pre><p>注：一定要注意缩进，否则会报错。</p><h1 id="四、Python创建实例对象"><a href="#四、Python创建实例对象" class="headerlink" title="四、Python创建实例对象"></a>四、Python创建实例对象</h1><p>1.要创建一个类的实例，可以使用类的名称，并通过<code>__init__</code>方法接受参数<br> 2.可以使用点(.)来访问对象的属性<br> 3.类的类的文档字符串可以通过<code>ClassName.__doc__</code>查看<br> 示例：</p><pre><code class="ruby">class user(object):&quot;user information&quot; #文档注释信息count=0def __init__(self,name,age):self.name=nameself.age=ageuser.count+=1def who(self):print &#39;My name is &#39;+self.name +&quot;.I&#39;m &quot; + str(self.age) + &#39; years old.&#39;def __del__(self):class_name=self.__class__.__name__print class_name,&quot;destroyed&quot;u1=user(&#39;emma&#39;,18) #创建示例对象u1，类名后面传参，构造方法被调用u1.who() #调用类中的成员函数printu1.count #调用类中的成员变量u2=user(&#39;emma123&#39;,20)u2.who()printu2.countprintuser.__doc__ #查看类文档的信息</code></pre><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>1）打印字符串时需注意加空格隔开，如’ years old.’引号里面第一个字符为空格。<br> 2）<code>__init__()</code>前后都是两个下划线，如写成一个会报错：<code>TypeError: object() takes no parameters</code><br> =》<code>def_init_</code>应该改为<code>def__init__</code>，其他同理。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python面试题前22道</title>
    <link href="/2020/04/19/Python%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%8D22%E9%81%93/"/>
    <url>/2020/04/19/Python%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%8D22%E9%81%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Python面试题"><a href="#Python面试题" class="headerlink" title="Python面试题"></a>Python面试题</h1><p><strong>1、一行代码实现1–100之和</strong></p><p>利用sum()函数求和</p><blockquote><blockquote><blockquote><p>sum(range(0,101))<br>5050</p></blockquote></blockquote></blockquote><p><strong>2、如何在一个函数内部修改全局变量</strong></p><p>利用global 修改全局变量</p><h5 id="3、列出5个python标准库"><a href="#3、列出5个python标准库" class="headerlink" title="3、列出5个python标准库"></a><strong>3</strong>、列出5个python标准库</h5><p>os：提供了不少与操作系统相关联的函数</p><p>sys: 通常用于命令行参数</p><p>re: 正则匹配</p><p>math: 数学运算</p><p>datetime:处理日期时间</p><h5 id="4、字典如何删除键和合并两个字典"><a href="#4、字典如何删除键和合并两个字典" class="headerlink" title="4、字典如何删除键和合并两个字典"></a>4、字典如何删除键和合并两个字典</h5><p>del和update方法</p><pre><code>del dic[&quot;&quot;]dic.update(dic2)</code></pre><h5 id="5、谈下python的GIL"><a href="#5、谈下python的GIL" class="headerlink" title="5、谈下python的GIL"></a>5、谈下python的GIL</h5><p>GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。</p><p>多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大</p><p>   在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。</p><p>  多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低</p><p>  <strong>“python下想要充分利用多核CPU，就用多进程”</strong></p><h5 id="6、python实现列表去重的方法"><a href="#6、python实现列表去重的方法" class="headerlink" title="6、python实现列表去重的方法"></a>6、python实现列表去重的方法</h5><p>先通过集合去重，在转列表</p><pre><code>a=set(list)##转列表 [x for x in a]</code></pre><h5 id="7、fun-args-kwargs-中的args-kwargs什么意思？"><a href="#7、fun-args-kwargs-中的args-kwargs什么意思？" class="headerlink" title="7、fun(args,*kwargs)中的args,*kwargs什么意思？"></a>7、fun(<em>args,*</em>kwargs)中的<em>args,*</em>kwargs什么意思？</h5><p>这就要从函数的参数说起了。函数在传参时通常分为四种情况：</p><p>普通参数，即在调用函数时必须按照准确的顺序来进行参数传递。</p><p>默认参数，即参数含有默认值，在调用函数时可以进行参数传递，若没有进行参数传递则使用默认值，要注意，默认参数必须在普通参数的右侧（否则解释器无法解析）。</p><p>元组参数，即 *args，参数格式化存储在一个元组中，长度没有限制，必须位于普通参数和默认参数之后。</p><p>字典参数，即 **kwargs，参数格式化存储在一个字典中，必须位于参数列表的最后面。</p><p>普通参数实例如下，在调用函数的时候必须传入参数，否则会抛出 TypeError 异常：</p><p>def fun(name):<br>    print ‘Hello’, name</p><p>fun(‘Python’)</p><p>默认参数必须跟在普通参数之后，不能在普通参数之前，默认参数可以传值，也可以不传，不传值时就采用默认参数：</p><p>def fun(base, rate=0.1):<br>    return base + base*rate</p><p>fun(100)<br>fun(100, 0.2)</p><p>元组参数需要跟在普通参数和默认参数的后面，其最大的特点就是不限制长度：</p><p>def fun(arg1, arg2=’Default’, *args):<br>    print ‘arg1:’, arg1<br>    print ‘arg2:’, arg2<br>    for eacharg in args:<br>        print ‘tuple arg:’, eacharg</p><p>fun(‘Python’)<br>fun(‘Python’, ‘Excellent’)<br>fun(‘Python’, ‘Excellent’, ‘I’, ‘Love’, ‘Python’, 100, ‘Years’)</p><p>最后一次调用的结果为：</p><p>arg1: Python</p><p>arg2: Excellent</p><p>tuple arg: I</p><p>tuple arg: Love</p><p>tuple arg: Python</p><p>tuple arg: 100</p><p>tuple arg: Years</p><p>由此可见，元组的长度是不受限制的。</p><p>字典参数必须跟在其它参数后面，并且长度也是不受限制的：</p><p>def fun(arg1, arg2=’Default’, <em>args, *</em>kwargs):<br>    print ‘arg1:’, arg1<br>    print ‘arg2:’, arg2<br>    for eacharg in args:<br>        print ‘tuple arg:’, eacharg</p><pre><code>for eachkwarg in kwargs.keys():    print &#39;dict arg&#39;, eachkwarg, &#39;:&#39;, kwargs[eachkwarg]</code></pre><p>fun(‘Python’, ‘Excellent’, ‘I’, ‘Love’, language=’Python’, number=100, time=’Years’)</p><p>运行的输出结果为：</p><p>arg1: Python</p><p>arg2: Excellent</p><p>tuple arg: I</p><p>tuple arg: Love</p><p>dict arg number : 100</p><p>dict arg language : Python</p><p>dict arg time : Years</p><p>当我们将普通参数和默认参数都放到元组或者字典参数中时，函数的定义就变为仅仅剩余元组参数和字典参数了：</p><pre><code>def fun(*args, **kwargs):    for eacharg in args:        print &#39;tuple arg:&#39;, eacharg        for eachkwarg in kwargs.keys():    print &#39;dict arg&#39;, eachkwarg, &#39;:&#39;, kwargs[eachkwarg]fun(&#39;Python&#39;, &#39;Excellent&#39;, &#39;I&#39;, &#39;Love&#39;, language=&#39;Python&#39;, number=100, time=&#39;Years&#39;)</code></pre><p>这也是很多源码中对函数的定义。运行结果输出为：</p><p>tuple arg: Python</p><p>tuple arg: Excellent</p><p>tuple arg: I</p><p>tuple arg: Love</p><p>dict arg number : 100</p><p>dict arg language : Python</p><p>dict arg time : Years</p><p>所有参数均可以正确获取。</p><h5 id="8、python2和python3的range（100）的区别"><a href="#8、python2和python3的range（100）的区别" class="headerlink" title="8、python2和python3的range（100）的区别"></a>8、python2和python3的range（100）的区别</h5><p>python2返回列表，python3返回迭代器，节约内存</p><p><strong>9、一句话解释什么样的语言能够用装饰器?</strong></p><p>函数可以作为参数传递的语言，可以使用装饰器</p><p><strong>10、python内建数据类型有哪些</strong></p><p>整型–int</p><p>布尔型–bool</p><p>字符串–str</p><p>列表–list</p><p>元组–tuple</p><p>字典–dict</p><p><strong>11、简述面向对象中<strong>new</strong>和<strong>init</strong>区别</strong></p><ul><li><strong>init</strong>是初始化方法，创建对象后，就立刻被默认调用了，可接收参数</li><li><strong>new</strong>至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别</li><li>new必须要有返回值，返回实例化出来的实例，这点在自己实现new时要特别注意，可以return父类（通过super(当前类名, cls)）new出来的实例，或者直接是object的new__出来的实例</li><li>3、<strong>init</strong>有一个参数self，就是这个<strong>new</strong>返回的实例，<strong>init</strong>在<strong>new</strong>的基础上可以完成一些其它初始化的动作，<strong>init</strong>不需要返回值</li><li>4、如果<strong>new</strong>创建的是当前类的实例，会自动调用<strong>init</strong>函数，通过return语句里面调用的<strong>new</strong>函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的<strong>init</strong>函数，也不会调用其他类的<strong>init</strong>函数。**</li></ul><h5 id="12、简述with方法打开处理文件帮我我们做了什么？"><a href="#12、简述with方法打开处理文件帮我我们做了什么？" class="headerlink" title="12、简述with方法打开处理文件帮我我们做了什么？"></a>12、简述with方法打开处理文件帮我我们做了什么？</h5><p>打开文件在进行读写的时候可能会出现一些异常状况，如果按照常规的f.open写法，我们需要try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要执行finally f.close()关闭文件，with方法帮我们实现了finally中f.close</p><h5 id="13、列表-1-2-3-4-5-请使用map-函数输出-1-4-9-16-25-，并使用列表推导式提取出大于10的数，最终输出-16-25"><a href="#13、列表-1-2-3-4-5-请使用map-函数输出-1-4-9-16-25-，并使用列表推导式提取出大于10的数，最终输出-16-25" class="headerlink" title="13、列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]"></a><strong>13</strong>、列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]</h5><p>map（）函数第一个参数是fun，第二个参数是一般是list，第三个参数可以写list，也可以不写，根据需求</p><pre><code>list=[1,2,3,4,5,6]def fn(x):  return x**2  res=map(fn,list)  res=[i for i in res if i&gt;10]  print(res)</code></pre><h5 id="14、python中生成随机整数、随机小数、0–1之间小数方法"><a href="#14、python中生成随机整数、随机小数、0–1之间小数方法" class="headerlink" title="14、python中生成随机整数、随机小数、0–1之间小数方法"></a>14、python中生成随机整数、随机小数、0–1之间小数方法</h5><p>随机整数：random.randint(a,b),生成区间内的整数</p><p>随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数</p><p>0-1随机小数：random.random(),括号中不传参</p><h5 id="15、避免转义给字符串加哪个字母表示原始字符串？"><a href="#15、避免转义给字符串加哪个字母表示原始字符串？" class="headerlink" title="15、避免转义给字符串加哪个字母表示原始字符串？"></a>15、避免转义给字符串加哪个字母表示原始字符串？</h5><p>r , 表示需要原始字符串，不转义特殊字符</p><h5 id="16、-lt-div-class-quot-nam-quot-gt-中国-lt-div-gt-，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的"><a href="#16、-lt-div-class-quot-nam-quot-gt-中国-lt-div-gt-，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的" class="headerlink" title="16、&lt;div class=&quot;nam&quot;&gt;中国&lt;/div&gt;，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的"></a>16、<strong><em><code>&lt;div class=&quot;nam&quot;&gt;中国&lt;/div&gt;</code></em></strong>，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的</h5><pre><code>res=re.findall(r&#39;&lt;div class=&quot;.*&quot;&gt; (.*?)&lt;/div&gt;’,str)</code></pre><h5 id="17、python中断言方法举例"><a href="#17、python中断言方法举例" class="headerlink" title="17、python中断言方法举例"></a>17、python中断言方法举例</h5><p>assert（）方法，断言成功，则程序继续执行，断言失败，则程序报错</p><h5 id="18、数据表student有id-name-score-city字段，其中name中的名字可有重复，需要消除重复行-请写sql语句"><a href="#18、数据表student有id-name-score-city字段，其中name中的名字可有重复，需要消除重复行-请写sql语句" class="headerlink" title="18、数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句"></a>18、数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句</h5><p>select distinct name from student</p><p><strong>19、10个Linux常用命令</strong></p><p>ls pwd cd touch rm mkdir tree cp mv cat more grep echo</p><p><strong>20、python2和python3区别？列举5个</strong></p><ul><li><p>Python3 使用 print 必须要以小括号包裹打印内容，比如 print(‘hi’)</p><p>Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print ‘hi’</p></li><li><p>python2 range(1,10)返回列表，python3中返回迭代器，节约内存</p></li><li><p>python2中使用ascii编码，python中使用utf-8编码</p></li><li><p>python2中unicode表示字符串序列，str表示字节序列</p><p>python3中str表示字符串序列，byte表示字节序列</p></li><li><p>python2中为正常显示中文，引入coding声明，python3中不需要</p></li><li><p>python2中是raw_input()函数，python3中是input()函数</p></li></ul><p><strong>21、列出python中可变数据类型和不可变数据类型，并简述原理</strong></p><p>不可变数据类型：数值型、字符串型string和元组tuple</p><p>  不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址），如下图用id()方法可以打印对象的id</p><p>可变数据类型：列表list和字典dict；</p><p>  允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p><p><strong>22、s = “ajldjlajfdljfddd”，去重并从小到大排序输出”adfjl”</strong></p><p>set去重，去重转成list,利用sort方法排序，reeverse=False是从小到大排</p><p>list是不 变数据类型，s.sort时候没有返回值，所以注释的代码写法不正确</p><pre><code>s = &quot;ajldjlajfdljfddd&quot;S = SET(S)s=list(s)s.sort(reverse=False)res=&quot;&quot;.join(s)rint(res)</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>爬虫的二级代理</title>
    <link href="/2020/04/19/%E7%88%AC%E8%99%AB%E7%9A%84%E4%BA%8C%E7%BA%A7%E4%BB%A3%E7%90%86/"/>
    <url>/2020/04/19/%E7%88%AC%E8%99%AB%E7%9A%84%E4%BA%8C%E7%BA%A7%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理服务器工作原理<br>代理服务器工作原理：</p><p>1、客户端 A 向代理<br>代理服务器工作原理<br>代理服务器工作原理：</p><p>1、客户端 A 向代理服务器发出访问 Internet 的请求 。<br>2、代理服务器接受请求后，首先与访问控制列表中的访问规则相匹配，如果满足规则，则在缓存中查找是否有需要的资源信息。<br>3、如果缓存中存在客户端 A 的请求信息，那么将此信息返回给客户端 A ; 如果没有代理服务器将代替客户端去向 Internet 请求指定的信息。<br>4、Internet 上的主机将请求的信息发送到代理服务器，代理服务器会将信息存入缓存中。<br>5、代理服务器将 Internet 上主机的返回信息传给客户端 A 。<br>6、当客户端 B 也请求相同的信息时。<br>7、代理服务器也会接受请求后，与访问控制列表中的规则相匹配。<br>8、如果满足规则，代理服务器将会把缓存中的信息直接传给客户端 B 。</p><p>代理分类<br>正向代理（控制内网访问互联网）</p><p>反向代理（控制外网访问内网）</p><p>透明代理（不加密的正向代理）</p><p>正向代理<br>代理内部主机上网,共享上网，缓存，控制内网用户上网行为等功能（客户端需要设置代理服务器的IP和代理端口）</p><p>正向代理分析图：<br>        外网<br>         |<br>        modem<br>         |<br>        路由器(dhcp,snat共享上网，上网行为控制，限速等)<br>         |<br>         |<br>     squid正向代理(共享上网，静态页面缓存加速，内网用户四七层上网行为控制，限速等)<br>         |<br>         |<br>    |———————-|<br> 上网用户一            上网用户二</p><pre><code>        公网         ｜         ｜            br0    172.16.13.250        squid 服务器         virbr1    192.168.100.1                    |         |         |            内网用户VM1                             eth0(virbr1)                    192.168.100.128</code></pre><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>从外部网络访问内部服务器，与正向方向相反，主要用于网站架构的缓存加速或CDN</p><pre><code>        client          |          |        反向代理 (缓存加速，七层切分，负载均衡，会话保持等)          ｜          ｜              web</code></pre><h3 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h3><p>和正向代理的功能完全一致（客户端不需要设置代理服务器的IP和代理端口，对用户是透明的）</p><p>参考资料<br><a href="https://www.cnblogs.com/yanjieli/p/7507456.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanjieli/p/7507456.html</a></p><p>Squid<br>概念<br>Squid 是一款缓存代理服务器软件，广泛用于网站的负载均衡架构中，常见的缓存服务器还有varnish、ATS等。</p><p>正向代理服务器可满足内网仅有一台服务器可以上网，而要供内网所有机器上网的需求，也可以用于爬虫的代理访问。在实践中我将Squid作为爬虫代理服务器，实现了多 IP 切换的功能。</p><p>安装<br>yum install -y squid<br>1<br>配置说明<br>配置鉴权<br>yum install httpd</p><h6 id="然后执行如下命令进行生成-用户名和密码，这里的示例为生成一个账号：hello"><a href="#然后执行如下命令进行生成-用户名和密码，这里的示例为生成一个账号：hello" class="headerlink" title="然后执行如下命令进行生成 用户名和密码，这里的示例为生成一个账号：hello"></a>然后执行如下命令进行生成 用户名和密码，这里的示例为生成一个账号：hello</h6><h6 id="执行该命令之后，根据提示输入设置密码"><a href="#执行该命令之后，根据提示输入设置密码" class="headerlink" title="执行该命令之后，根据提示输入设置密码"></a>执行该命令之后，根据提示输入设置密码</h6><p>htpasswd -c /etc/squid/passwd hello</p><p>配置文件<br><code>（/etd/squid/squid.conf）</code></p><p><code>acl all src 0.0.0.0/0.0.0.0     #允许所有IP访问</code><br><code>acl manager proto http        #manager url协议为http</code><br><code>acl localhost src 127.0.0.1/255.255.255.255 #允午本机IP</code><br><code>acl to_localhost dst 127.0.0.1         #允午目的地址为本机IP</code><br><code>acl CONNECT method CONNECT     #请求方法以CONNECT</code></p><p><code>#http_access allow all         #允许所有人使用该代理.</code></p><p><code>#http_reply_access allow all         #允许所有客户端使用该代理</code></p><p><code>acl Safe_ports port 80     # 允许安全更新的端口为80</code><br><code>acl Safe_ports port 443    #允许安全更新的端口为443</code><br><code>acl localnet src 10.195.249.225   #</code><br><code>acl localnet src 10.195.236.141   #</code></p><p><code>http_access allow localnet      #</code><br><code>http_access deny !Safe_ports      #</code></p><p>acl OverConnLimit maxconn 16    #限制每个IP最大允许16个连接，防止攻击</p><p>http_access deny OverConnLimit</p><p>icp_access deny all             #禁止从邻居服务器缓冲内发送和接收ICP请求.<br>miss_access allow all         #允许直接更新请求<br>ident_lookup_access deny all                 #禁止lookup检查DNS<br>http_port 8080 transparent                 #指定Squid监听浏览器客户请求的端口号。</p><p>hierarchy_stoplist cgi-bin ?         #用来强制某些特定的对象不被缓存，主要是处于安全的目的。</p><p>acl QUERY urlpath_regex cgi-bin ?</p><p>cache deny QUERY</p><p>cache_mem 1 GB     #这是一个优化选项，增加该内存值有利于缓存。应该注意的是：</p><pre><code>       \#一般来说如果系统有内存，设置该值为(n/)3M。现在是3G 所以这里1G</code></pre><p>fqdncache_size 1024    #FQDN 高速缓存大小</p><p>maximum_object_size_in_memory 2 MB     #允许最大的文件载入内存</p><p>memory_replacement_policy heap LFUDA  #动态使用最小的，移出内存cache</p><p>cache_replacement_policy heap LFUDA     #动态使用最小的，移出硬盘cache</p><p>cache_dir ufs /home/cache 5000 32 512 #高速缓存目录 ufs 类型 使用的缓冲值最大允午1000MB空间，</p><p>#32个一级目录，512个二级目录</p><p>max_open_disk_fds 0                 #允许最大打开文件数量,0 无限制</p><p>minimum_object_size 1 KB             #允午最小文件请求体大小</p><p>maximum_object_size 20 MB         #允午最大文件请求体大小</p><p>cache_swap_low 90              #最小允许使用swap 90%</p><p>cache_swap_high 95              #最多允许使用swap 95%</p><p>ipcache_size 2048                # IP 地址高速缓存大小 2M<br>ipcache_low 90                #最小允许ipcache使用swap 90%<br>ipcache_high 95                 #最大允许ipcache使用swap 90%</p><p>access_log /var/log/squid/access.log squid     #定义日志存放记录<br>cache_log /var/log/squid/cache.log squid<br>cache_store_log none             #禁止store日志</p><p>emulate_httpd_log on     #将使Squid仿照Web服务器的格式创建访问记录。如果希望使用</p><pre><code>            \#Web访问记录分析程序，就需要设置这个参数。</code></pre><p>refresh_pattern . 0 20% 4320 override-expire override-lastmod reload-into-ims ignore-reload  #更新cache规则</p><p>acl buggy_server url_regex ^http://…. http://      #只允许http的请求broken_posts allow buggy_server</p><p>acl apache rep_header Server ^Apache         #允许apache的编码</p><p>broken_vary_encoding allow apache</p><p>request_entities off                     #禁止非http的标分准请求，防止攻击<br>header_access header allow all             #允许所有的http报头<br>relaxed_header_parser on                 #不严格分析http报头.<br>client_lifetime 120 minute                 #最大客户连接时间 120分钟<br>cache_mgr <a href="mailto:sky@test.com">sky@test.com</a>             #指定当缓冲出现问题时向缓冲管理者发送告警信息的地址信息。<br>cache_effective_user squid             #这里以用户squid的身份Squid服务器<br>cache_effective_group squid</p><p>icp_port 0            #指定Squid从邻居服务器缓冲内发送和接收ICP请求的端口号。<br>           #这里设置为0是因为这里配置Squid为内部Web服务器的加速器，<br>           #所以不需要使用邻居服务器的缓冲。0是禁用</p><p># cache_peer 设置允许更新缓存的主机，因是本机所以127.0.0.1</p><p>cache_peer 127.0.0.1 parent 80 0 no-query default multicast-responder no-netdb-exchange<br>cache_peer_domain 127.0.0.1<br>hostname_aliases 127.0.0.1</p><p>error_directory /usr/share/squid/errors/Simplify_Chinese     #定义错误路径</p><p>always_direct allow all         # cache丢失或不存在是允许所有请求直接转发到原始服务器<br>ignore_unknown_nameservers on     #开反DNS查询，当域名地址不相同时候，禁止访问<br>coredump_dir  /var/log/squid         #定义dump的目录<br>max_filedesc 2048        #最大打开的文件描述</p><p>half_closed_clients off     #使Squid在当read不再返回数据时立即关闭客户端的连接。</p><pre><code>            \#有时read不再返回数据是由于某些客户关闭TCP的发送数据            \#而仍然保持接收数据。而Squid分辨不出TCP半关闭和完全关闭。</code></pre><p>squid在做爬虫代理时候，我们只需要做到一个squid代理，然后对其他代理做转发轮询，如何使用squid做代理并</p><p>自动转发轮询？</p><p>加上这行代码：</p><p>cache_peer 120.xx.xx.32 parent 80 0 no-query weighted-round-robin weight=2 connect-fail-limit=2 allow-miss max-conn=5 name=proxy-90<br>1<br>注意，当120.xx.xx.32 是相同 但是端口不同的时候，必须设置不同的name，否则会报错cache_peer 120.xx.xx.32 specified twice 这时候及得设置不同的name。</p><p>配置关键字含义<br>语法是这样的 cache_peer Web服务器地址 服务器类型 http端口 icp端口 [可选项], 可选项包括：</p><p>proxy-only：指明从peer得到的数据在本地不进行缓存，缺省地，squid是要缓存这部分数据的；<br>weight=n：用于你有多个peer的情况，这时如果多于一个以上的peer拥有你请求的数据时，squid通过计算每个peer的ICP响应时间来 决定其weight的值，然后squid向其中拥有最大weight的peer发出ICP请求。也即weight值越大，其优先级越高。当然你也可以手工 指定其weight值；<br>no-query：不向该peer发送ICP请求。如果该peer不可用时，可以使用该选项；<br>Default：有点象路由表中的缺省路由，该peer将被用作最后的尝试手段。当你只有一个父代理服务器并且其不支持ICP协议时，可以使用default和no-query选项让所有请求都发送到该父代理服务器；<br>login=user:password：当你的父代理服务器要求用户认证时可以使用该选项来进行认证。<br>更新完成后保存重启squid，就会发现 squid 已经正常可用了。<br>访问控制<br>squid的acl（access control list)访问控制（下面列举一些常见的控制）</p><p>acl denyip src  192.168.100.128/32     –拒绝内网的192.168.100.128/32上网<br>http_access deny denyip</p><p>acl denyip src 192.168.100.128-192.168.100.132/255.255.255.255<br>http_access deny denyip</p><p>acl vip  arp  00:0C:29:79:0C:1A<br>http_access allow  vip </p><p>acl  baddsturl2  dst   220.11.22.33  –不能访问这个外网IP的网站<br>http_access deny baddsturl2</p><p>acl  baddsturl  dstdomain -i  <a href="http://www.163.com" target="_blank" rel="noopener">www.163.com</a>  –不能访问<a href="http://www.163.com和WWW.163.COM；-i参数定义大小写都匹配；" target="_blank" rel="noopener">www.163.com和WWW.163.COM；-i参数定义大小写都匹配；</a>  但是可以访问war.163.com或sports.163.com<br>http_access deny baddsturl</p><p>acl  baddsturl  dstdom_regex -i  163    –这是把163以下的所有域名都禁止  ，但直接使用IP仍然是可以访问的<br>http_access deny   baddsturl</p><p>acl  baddsturl  dstdom_regex “/etc/squid/baddsturl”  –如果网址太多，可以写成一个文件，然后在这个文件里一行一个网站写上你要禁止的<br>http_access deny baddsturl</p><p>acl baddsturl3  url_regex  -i  baidu   –拒绝访问url里有baidu这个关键字的网站<br>http_access deny baddsturl3</p><p>acl badfile  urlpath_regex -i .mp3$ .rmvb$ .exe$ .zip$ .mp4$ .avi$  .rar$<br>http_access deny badfile    –禁止下载带有定义后缀名的文件</p><p>acl badipclient2  src 192.168.100.0/255.255.255.0<br>acl worktime time  MTWHF 9:00-17:00<br>http_access deny badipclient2 worktime  –拒绝192.168.100.0网段工作时间不能上网</p><p>acl badipclient3  src 192.168.100.128<br>acl conn5  maxconn  5<br>http_access deny badipclient3 conn5    –最大连接数为5</p><p><a href="https://www.cnblogs.com/wangxiaoqiangs/p/5796597.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangxiaoqiangs/p/5796597.html</a></p><p>初始化<br>修改完配置文件之后保存，然后输入以下命令进行初始化 squid</p><p>squid -z<br>1<br>2<br>3<br>问题<br>TCP_MISS/503<br>发现日志中有如下的内容</p><p>1587003941.248      0 172.25.0.1 TCP_MISS/503 4362 GET <a href="http://gtj.hangzhou.gov.cn/col/col1363087/index.html" target="_blank" rel="noopener">http://gtj.hangzhou.gov.cn/col/col1363087/index.html</a> - HIER_NONE/- text/html<br>1587003942.505      0 172.25.0.1 TCP_MISS/503 4362 GET <a href="http://gtj.hangzhou.gov.cn/col/col1363087/index.html" target="_blank" rel="noopener">http://gtj.hangzhou.gov.cn/col/col1363087/index.html</a> - HIER_NONE/- text/html<br>1587003943.779    301 172.25.0.1 TCP_MISS/200 388 GET <a href="http://httpbin.org/ip" target="_blank" rel="noopener">http://httpbin.org/ip</a> - HIER_DIRECT/34.230.193.231 application/json<br>1587003943.899      0 172.25.0.1 TCP_MISS/503 4357 GET <a href="http://gtj.hangzhou.gov.cn/col/col1363087/index.html" target="_blank" rel="noopener">http://gtj.hangzhou.gov.cn/col/col1363087/index.html</a> - HIER_NONE/- text/html<br>1587003945.333      0 172.25.0.1 TCP_MISS/503 4362 GET <a href="http://gtj.hangzhou.gov.cn/col/col1363087/index.html" target="_blank" rel="noopener">http://gtj.hangzhou.gov.cn/col/col1363087/index.html</a> - HIER_NONE/- text/html</p><p>查看到一个关键字TCP_MISS/503</p><p>谷歌之，找到这篇文章：<a href="https://forums.freebsd.org/threads/34184/" target="_blank" rel="noopener">https://forums.freebsd.org/threads/34184/</a></p><p>解决：</p><p>原来是IPv6不支持，按照里面的提示，在/etc/squid/squid.conf里面配置一个dns_v4_first on</p><p>再次尝试的时候可以了！</p><p>如果还是不行的话，直接修改系统的配置</p><p>修改 /etc/sysconfig/network:<br>设置 NETWORKING_IPV6=no</p><p>(最好reboot重启一次)</p><p>参考资料<br><a href="http://cn.linux.vbird.org/linux_server/0420squid.php#server_default" target="_blank" rel="noopener">http://cn.linux.vbird.org/linux_server/0420squid.php#server_default</a></p><p>代理池<br><a href="https://github.com/AaronJny/open_proxy_pool" target="_blank" rel="noopener">https://github.com/AaronJny/open_proxy_pool</a></p><p>配置文件更新程序<br><a href="https://github.com/xNathan/squid_proxy_pool" target="_blank" rel="noopener">https://github.com/xNathan/squid_proxy_pool</a></p><p>上述项目的文档说明</p><p><a href="https://xnathan.com/2017/03/01/squid-anony-proxy/" target="_blank" rel="noopener">https://xnathan.com/2017/03/01/squid-anony-proxy/</a></p><p><a href="https://xnathan.com/2017/02/28/squid-proxy/" target="_blank" rel="noopener">https://xnathan.com/2017/02/28/squid-proxy/</a></p><p><a href="https://xnathan.com/2017/03/02/squid-proxy-pool/" target="_blank" rel="noopener">https://xnathan.com/2017/03/02/squid-proxy-pool/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql的使用</title>
    <link href="/2020/04/18/mysql%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/04/18/mysql%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>mysql 是一门关系型数据库, 不同于mongoDB 来说. mysql 需要给不同的表之间建立相互联系,以便确定完整性约束. 这里我们看看Mysql中常用的基本概念就差不多了.</p><h2 id="mysql常用术语"><a href="#mysql常用术语" class="headerlink" title="mysql常用术语"></a>mysql常用术语</h2><ul><li>冗余: 用来表示存储两倍的数据, 但会使数据访问更快. 相当于redis</li><li>主键: 用来执行每个表的关键性数据, 并且,每个表中只有一个主键.</li><li>外键: 这应该是mysql的关键, 使用外键来关联不同表.</li><li>复合键: 将多个键组合一起来作为索引值. 一般用于复合索引</li><li>索引:借用一组值, 来对表进行排序. 可以比作书的目录.</li><li>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体</li></ul><h2 id="mysql之初命令"><a href="#mysql之初命令" class="headerlink" title="mysql之初命令"></a>mysql之初命令</h2><p>在MAC 上下载mysql 很简单. 直接使用homebrew 即可. 他会帮你把mysql的所有其他东西都完全的安装好. 然后, 就是简单的开关操作.</p><ul><li>开启mysql: mysql.server start</li><li>关闭mysql: mysql.server stop</li><li>打开交互命令: mysql</li></ul><p>OK, 这样就已经满足前期你对mysql的基本要求 如果你想,将你的mysql上锁, 即, 添加登录密码的话, 就可以使用:</p><pre><code class="text">mysqladmin -u root password &quot;new_password&quot;;</code></pre><p>如果你想设置为开启自启的话,可以使用:</p><pre><code class="text">// MACln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents</code></pre><p>其他的自行google把.</p><h2 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h2><p>上述已经提到了, 使用mysql即可连接到数据库. 当你使用mysql进行连接的时候, 这并不是完整意义上的连接, 因为当多人协作的时候,往往一个数据库, 会有很多users进行连接, 而这mysql只是数据库给的一个匿名用户, 如果是单机版的Mysql这样使用当然是最方便的。 另外, 你还可以使用</p><pre><code class="text">mysql -h host -u user -p// 接着输入你的密码</code></pre><p>这里就是比较高级的。 在指定的hostname上使用指定的user进行连接. 有童鞋可能会问了, host和user到底是什么呢？ e… 你可以输入echo $HOST和echo $USER来查看. 当然, 这种方式是最高级的, 也最有可能会遇到这样的problem</p><pre><code class="text"> ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)</code></pre><p>这句话的意思就是, 亲, 你的mysql还没运行呢~</p><p>接着, 我们来看一下稍微简单的调用.你的HOST实际是可以忽略的, 如果你不是远程登录的话. 接着就可以使用一下的命令:</p><pre><code class="text">mysql -u user -p</code></pre><p>其实俺最常用的就是mysql 方便干脆, 不过有时候需要user的时候,还会使用一下mysql -u user -p这样的参数. 如果你想查看你Mysql中,有多少USER的话, 就可以使用, SELECT USER();进行查看.</p><p>如果你在电脑里面有其他的用户需要添加时, 这就需要你进行手动添加用户.</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>在Mysql中添加用户,其实也非常简单, 只需要使用CREATE USER 和 GRANT就可以了。 我们这里创建一个普通用户-jimmy. 然后赋予它一下简单的权限</p><pre><code class="text">CREATE USER &#39;jimmy&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;your_password&#39;;// 创建一个jimmy的用户, 并且, 他的密码为,your_password&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP    -&gt; ON *.*   -&gt; TO &#39;jimmy&#39;@&#39;localhost&#39;;// 赋予jimmy 一些基本的权限, 让他去访问某些执行的数据库, 上文中的`*.*`(注意这不是颜文字, 这表示所有的数据库) 就可以写为你允许该用户访问的数据库的name, 比如, 你可以改为`bank`,`tencent`... 等等</code></pre><p>这样, 你就可以使用mysql -u xxx -p 进行指定用户的登录了. 如果,你想创建一个管理员账户的话, 代码就更简单了。</p><pre><code class="text">CREATE USER &#39;admin&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;your_ps&#39;;// 创建一个管理员账户GRANT ALL PRIVILEGES ON *.* TO &#39;admin&#39;@&#39;localhost&#39; WITH GRANT OPTION;// ok</code></pre><p>如果你想检查, 你创建的用户的权限对不对时, 可以使用.</p><pre><code class="text">SHOW GRANTS FOR &#39;admin&#39;@&#39;localhost&#39;;</code></pre><p>进行查看. 接下来, 假设出现很多bugs. md… 密码写错了,怎么办？ 用户创建错了,怎么办？ 这些,mysql 都已经提供了一些相关的办法.</p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>这里有很多种方法, 简单介绍两种. 一种是使用SET,一种是使用ALERT(v5.7.6).</p><p>SET 修改密码应该算是比较常用的. 使用SET直接修改密码即可. 格式为:</p><pre><code class="text">SET PASSWORD FOR &#39;jimmy&#39;@&#39;localhost&#39; = PASSWORD(&#39;your_ps&#39;);</code></pre><p>上面那种方法,适用于root的用户进行修改, 如果你想修改自己的密码的话,就更简单了. 直接使用.</p><pre><code class="text">SET PASSWORD = PASSWORD(&#39;your_ps&#39;);</code></pre><p>来看一下ALERT的相关语法吧.</p><pre><code class="text">ALERT USER &#39;jimmy&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;your_ps&#39;;</code></pre><p>如果你不想输,‘jimmy’@’localhost 这一串的话, 可以直接使用USER()进行代替.</p><pre><code class="text">ALERT USER USER() IDENTIFIED BY &#39;your_ps&#39;;</code></pre><p>另外, 如果你只想在shell 中直接修改的话,可以直接使用</p><pre><code class="text">mysqladmin -u user_name -h host_name password &quot;new_password&quot;</code></pre><p>直接修改即可.</p><p>如果你连用户都创建错了。 那该怎么办呢？ 删呗.</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>在删之前,你可以看看,mysql中,有多少其他的用户. 一般，mysql创建新用户后, 都会把用户信息放到mysql.user中去.我们来检查一下吧.</p><pre><code class="text">`SELECT User FROM mysql.user</code></pre><p>选择你想要删除的用户名.直接drop就行了.</p><pre><code class="text">DROP USER &#39;jimmy&#39;@&#39;localhost&#39;;</code></pre><h2 id="语句格式"><a href="#语句格式" class="headerlink" title="语句格式"></a>语句格式</h2><p>在sql中, 每条语句都是以;(semicolon)结尾。这里简单演示一下, 如果你想查看mysql的版本号， 或者日期时间的话，可以使用.</p><pre><code class="text">SELECT VERSION(),CURRENT_DATE;// 返回数据+-----------+--------------+| version() | current_date |+-----------+--------------+| 5.7.11    | 2016-07-02   |+-----------+--------------+1 row in set (0.00 sec)</code></pre><p>另外, 在mysql中, 大小写是不区分的. 如果你更熟悉小写的话,就可以使用。</p><pre><code class="text">select version(),current_date;</code></pre><p>这完全没有太大的影响。 另外,sql语句可以在一行中书写, 例如:</p><pre><code class="text">select version(); select now(); select current_date;</code></pre><p>这3条语句都会执行一次。 由于,mysql是根据semicolon来决定语句的结束, 所以, 你书写语句的方式, 可以这样写.</p><pre><code class="text">&gt; select     -&gt; ,    -&gt; current_date;</code></pre><p>如果你换行之后发现自己打错了, 那该怎么办呢？ 简单,输入/c即可.</p><h2 id="数据库之初操作"><a href="#数据库之初操作" class="headerlink" title="数据库之初操作"></a>数据库之初操作</h2><p>进入数据库后, 第一件事, 应该看看, 这里面有哪些已经创建好的用户.</p><pre><code class="text">show databases;// 你有可能会发现有如下的信息；+----------+| Database |+----------+| mysql    || test     || tmp      |+----------+</code></pre><p>然后, 你可以选择其一并进行相关操作.</p><pre><code class="text">USE test</code></pre><p>当你已经进入数据库, 但突然忘记了,自己是哪个用户,哪个数据库. so how to do? 上面已经介绍了,查找用户, 可以直接使用SELECT USER(); 那查找数据库同理就应该为.</p><pre><code class="text">SELECT DATABASE();</code></pre><p>如果, 你没有相关的db的话, 那就需要你手动进行创建了.</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>使用方法很简单:</p><pre><code class="text">CREATE DATABASE db_name;// 这里的db_name 是大小写敏感的,需要注意一下.</code></pre><p>之后, 你就需要手动进行选择你需要的数据库. 还是上面那个命令. USE db_name; 当然， 如果你嫌登录之后再USE 有点麻烦, 你可以直接使用.</p><pre><code class="text">mysql -u user -p db_name</code></pre><p>进行相关登录. ok, 之后,就是数据表里的事了.</p><h3 id="数据表相关"><a href="#数据表相关" class="headerlink" title="数据表相关"></a>数据表相关</h3><p>Table和Database的初阶段准备其实没太大的差别。 同样就是, 创建,进入,over. 你可以先检查一下,你的数据库中有没有已经建好的表.</p><pre><code class="text">SHOW TABLES;</code></pre><p>如果没有的话, 你可以随便建一个表. 比如, 你现在创建一个person的表, 里面的字段有name,birth.</p><pre><code class="text">CREATE TABLE person(name VARCHAR(20),birth DATE);</code></pre><p>这样你就成功的创建了一个表,接着, 你可以看看关于你的表的相关描述.</p><pre><code class="text">DESCRIBE person;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GB28181的协议栈功能</title>
    <link href="/2020/04/18/GB28181%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8A%9F%E8%83%BD/"/>
    <url>/2020/04/18/GB28181%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>GB28181的协议栈功能。</p><pre><code>         GB/T-28181协议其实就是在国际上通用的SIP协议进行私有化定制，流媒体方面就是在国际最流行的编码上进行封装（当然也有我们国家的编码标准SVAC）。         既然是国际上通用协议，那肯定就可以借助开源组织的力量了，要知道这是全球最大的软件组织，几乎所有的程序员都为之敬佩！开源组织给了推进计算机技术发展的很好良方。SIP协议实现完全可以用osip来作为基础协议栈（至少我看到绝大多数厂家是如此实现，海康、大华。。。。），使用开源没什么不好的，至少我们知道他们是稳定的，可靠的，会一直维护的。       我采用的是libosip+libexosip+libxml来实现IPC和平台协议功能，前面两者负责sip协议的实现，libxml用来封装和解析实体信令。通过3~4年的市场应用感觉挺稳定的。       流媒体方面：从编码中获取的h.264+g711的视音频帧，进行PS媒体协议封装（自己写的PS封装协议），再经过RTP传输协议（自己实现）发送至平台。       平台对收到的RTP流媒体进行解RTP,解PS，再进行h.264+g711的解码。</code></pre><p>  GB28181协议已经慢慢的进行了规范完善，现在大的趋势也已经是这样，虽然以前有很多的私有协议平台，但新建的平安城市等政府都需要能支持GB28181的互联互通，GB28181协议还有互联功能，这个功能比ONVIF好很多，因为可以进行大面积的组网，可以有上下级平台的区分，这一点是ONVIF不能做到的。</p><pre><code>       ONVIF协议其实也有很多不足，如对事件的具体定义，如对视频分析的定义都是模糊的。用户开发自己的需要自己定义，而且没有对流媒体的方面的定义，因为媒体是通过RTSP协议进行的。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shell命令</title>
    <link href="/2020/04/18/shell%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/04/18/shell%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>文件、目录操作命令<br>1、ls命令</p><p>功能：显示文件和目录的信息</p><p>ls　以默认方式显示当前目录文件列表</p><p>ls -a 显示所有文件包括隐藏文件</p><p>ls -l 显示文件属性，包括大小，日期，符号连接，是否可读写及是否可执行</p><p>ls -lh 显示文件的大小，以容易理解的格式印出文件大小 (例如 1K 234M2G)</p><p>ls -lt 显示文件，按照修改时间排序</p><p>2、cd命令</p><p>功能：改名目录</p><p>cd dir　切换到当前目录下的dir目录</p><p>cd /　切换到根目录</p><p>cd ..　切换到到上一级目录</p><p>cd ../..　切换到上二级目录</p><p>cd ~　切换到用户目录，比如是root用户，则切换到/root下</p><p>3、cp命令</p><p>功能：copy文件</p><p>cp source target　将文件source复制为target</p><p>cp /root /source.　将/root下的文件source复制到当前目录</p><p>cp –av soure_dir target_dir　将整个目录复制，两目录完全一样</p><p>4、rm命令</p><p>功能：删除文件或目录</p><p>rm file　删除某一个文件</p><p>rm -f file 删除时候不进行提示。可以于r参数配合使用</p><p>rm -rf dir　删除当前目录下叫dir的整个目录</p><p>5、mv命令</p><p>功能：将文件移动走，或者改名，在uinx下面没有改名的命令，如果想改名，可以使用该命令</p><p>mv source target　将文件source更名为target</p><p>6、diff</p><p>功能：比较文件内容</p><p>diff dir1 dir2　比较目录1与目录2的文件列表是否相同，但不比较文件的实际内容，不同则列出</p><p>diff file1<br>file2　比较文件1与文件2的内容是否相同，如果是文本格式的文件，则将不相同的内容显示，如果是二进制代码则只表示两个文件是不同的</p><p>comm file1 file2　比较文件，显示两个文件不相同的内容</p><p>7、ln命令</p><p>功能：建立链接。windows的快捷方式就是根据链接的原理来做的</p><p>ln source_path target_path 硬连接</p><p>ln -s source_path target_path 软连接</p><p>查看文件内容命令<br>1、cat命令</p><p>显示文件的内容，和DOS的type相同</p><p>cat file</p><p>2、more命令</p><p>功能：分页显示命令</p><p>more　file</p><p>more命令也可以通过管道符(|)与其他的命令一起使用,例如：</p><p>ps ux|more</p><p>ls|more</p><p>3、tail 命令</p><p>功能：显示文件的最后几行</p><p>tail -n 100 aaa.txt 显示文件aaa.txt文件的最后100行</p><p>4、vi命令</p><p>vi file　编辑文件file</p><p>vi 原基本使用及命令：</p><p>输入命令的方式为先按[ESC]键，然后输入:w(写入文件),:w!(不询问方式写入文件）,:wq保存并退出,:q退出,q!不保存退出</p><p>5、touch命令</p><p>功能：创建一个空文件</p><p>touch aaa.txt 创建一个空文件，文件名为aaa.txt</p><p>基本系统命令<br>1、man命令</p><p>功能：查看某个命令的帮助，如果你不知道某个命令的用法不懂，可以问他，他知道就回告诉你</p><p>例如：</p><p>man ls 显示ls命令的帮助内容</p><p>2、w命令</p><p>功能：显示登录用户的详细信息</p><p>例如：</p><p>Sarge:~# w</p><p>22:06:51 up 43 min, 1 user, load average: 0.00, 0.00, 0.00</p><p>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</p><p>zhoulj pts/0 10.140.0.109 21:24 0.00s 0.85s 0.09s sshd:<br>zhoulj [priv]</p><p>3、who命令</p><p>功能：显示登录用户</p><p>例如：</p><p>Sarge:~# who</p><p>zhoulj pts/0 Mar 13 21:24 (10.140.0.109)</p><p>4、last命令</p><p>功能：查看最近那些用户登录系统</p><p>例如：</p><p>Sarge:~# last</p><p>zhoulj pts/0 10.140.0.109 Mon Mar 13 21:24 still logged in</p><p>reboot system boot 2.6.8-2-386 Mon Mar 13 21:23 (00:43)</p><p>zhoulj pts/0 10.140.0.105 Sun Mar 12 22:51 - down (00:00)</p><p>zhoulj pts/0 10.140.0.105 Sun Mar 12 22:51 - 22:51 (00:00)</p><p>root tty1 Sun Mar 12 22:50 - down (00:01)</p><p>root tty1 Sun Mar 12 22:46 - 22:48 (00:02)</p><p>root tty1 Sun Mar 12 22:43 - 22:46 (00:02)</p><p>reboot system boot 2.6.8-2-386 Mon Mar 13 06:34 (-7:-41)</p><p>wtmp begins Mon Mar 13 06:34:11 2006</p><p>5、date命令</p><p>功能：系统日期设定</p><p>date　显示当前日期时间</p><p>date -s 20:30:30　设置系统时间为20:30:30</p><p>date -s 2002-3-5　设置系统时期为2003-3-5</p><p>date -s “060520 06:00:00”　设置系统时期为2006年5月20日6点整。</p><p>6、clock命令</p><p>功能：时钟设置</p><p>clock –r　对系统Bios中读取时间参数</p><p>clock –w　将系统时间(如由date设置的时间)写入Bios</p><p>7、uname命令</p><p>功能：查看系统版本</p><p>uname -R　显示操作系统内核的version</p><p>例如：</p><p>Sarge:~# uname -a</p><p>Linux Sarge 2.6.8-2-386 #1 Tue Aug 16 12:46:35 UTC 2005 i686 GNU/Linux</p><p>8、关闭和重新启动系统命令</p><p>reboot　 重新启动计算机</p><p>shutdown -r now 重新启动计算机，停止服务后重新启动计算机</p><p>shutdown -h now 关闭计算机，停止服务后再关闭系统</p><p>halt 关闭计算机</p><p>一般用shutdown -r now,在重启系统是，关闭相关服务，shutdown -h now也是如此。</p><p>9、su命令</p><p>功能：切换用户</p><p>su - 切换到root用户</p><p>su - zhoulj 切换到zhoulj用户，</p><p>注意：- ，他很关键，使用-，将使用用户的环境变量</p><p>四、监视系统状态命令</p><p>1、top命令</p><p>功能：查看系统cpu、内存等使用情况</p><p>2、free命令</p><p>功能：查看内存和swap分区使用情况</p><p>例如：</p><p>Sarge:~# free -tm</p><pre><code>        total       used       free     shared    buffers     cached</code></pre><p>1<br>Mem: 187 42 145 0 6 16</p><p>-/+ buffers/cache: 19 167</p><p>Swap: 243 0 243</p><p>Total: 430 42 388</p><p>3、uptime</p><p>功能：现在的时间 ，系统开机运转到现在经过的时间，连线的使用者数量，最近一分钟，五分钟和十五分钟的系统负载</p><p>例如：</p><p>Sarge:~# uptime</p><p>21:54:46 up 31 min, 1 user, load average: 0.00, 0.00, 0.00</p><p>4、vmstat命令</p><p>功能：监视虚拟内存使用情况</p><p>例如：</p><p>Sarge:~# vmstat</p><p>procs memory swap io system<br>cpu</p><p>r b swpd free buff cache si so bi bo in cs us<br>sy id wa</p><p>1 0 0 63704 8100 32272 0 0 8 3 103 17 0<br>1 98 1</p><p>5、ps命令</p><p>功能：显示进程信息</p><p>ps ux 显示当前用户的进程</p><p>ps uxwww 显示当前用户的进程的详细信息</p><p>ps aux 显示所有用户的进程</p><p>ps ef 显示系统所有进程信息</p><p>6、kill命令</p><p>功能：干掉某个进程，进程号可以通过ps命令得到</p><p>kill -9 1001　将进程编号为1001的程序干掉</p><p>kill all -9 apache　将所有名字为apapche的程序杀死，kill不是万能的，对僵死的程序则无效。</p><p>五、磁盘操作命令</p><p>1、df命令</p><p>功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>参数 功能</p><p>-a 列出全部目录</p><p>-Ta 列出全部目录，并且显示文件类型</p><p>-B 显示块信息</p><p>-i 以i节点列出全部目录</p><p>-h 按照日常习惯显示（如：1K、100M、20G）</p><p>-x [filesystype] 不显示[filesystype]</p><p>例如：</p><p>Sarge:~# df -Th</p><p>Filesystem Type Size Used Avail Use% Mounted on</p><p>/dev/sda1 ext3 265M 64M 187M 26% /</p><p>tmpfs tmpfs 94M 0 94M 0% /dev/shm</p><p>/dev/sda6 ext3 714M 8.1M 667M 2% /home</p><p>/dev/sda8 ext3 956M 215M 691M 24% /usr</p><p>/dev/sda7 ext3 714M 57M 619M 9% /var</p><p>2、du命令</p><p>功能：检测一个目录和（递归地）所有它的子目录中的文件占用的磁盘空间。</p><p>参数 功能</p><p>-s [dirName] 显示目录占用总空间</p><p>-sk [dirName] 显示目录占用总空间，以k为单位</p><p>-sb [dirName] 显示目录占用总空间，以b为单位</p><p>-sm [dirName] 显示目录占用总空间，以m为单位</p><p>-sc [dirName] 显示目录占用总空间，加上目录统计</p><p>-sh [dirName] 只统计目录大小</p><p>例如：</p><p>Sarge:~# du -sh /etc</p><p>1.3M /etc</p><p>3、mount命令</p><p>功能：使用mount命令就可在Linux中挂载各种文件系统。</p><p>格式：mount -t 设备名 挂载点</p><p>（1）、mount /dev/sda1 /mnt/filetest</p><p>mount -t vfat /dev/hda /mnt/fatfile</p><p>mount -t ntfs /dev/hda /mnt/ntfsfile</p><p>mount -t iso9660 /dev/cdrom /mnt/cdrom</p><p>mount -o 设备名 挂载点</p><p>（2）、使用usb设备</p><p>modprobe usb-storage</p><p>mkdir /mnt/usb</p><p>mount -t auto /dev/sdx1 /mnt/usb</p><p>umount /mnt/usb</p><p>4、mkswap命令</p><p>功能：使用mkswap命令可以创建swap空间，如：</p><p>debian:~# mkswap -c /dev/hda4</p><p>debian:~# swapon /dev/hda4 #启用新创建的swap空间，停用可使用swapoff命令</p><p>5、fdisk命令</p><p>功能：对磁盘进行分区</p><p>fdisk /dev/xxx 格式化xxx设备(xxx是指磁盘驱动器的名字，例如hdb，sdc)</p><p>fdisk -l 显示磁盘的分区表</p><p>6、mkfs命令</p><p>功能：格式化文件系统，可以指定文件系统的类型，如ext2、ext3、fat、ntfs等</p><p>格式1：mkfs.ext3 options /dev/xxx</p><p>格式2：mkfs -t ext2 options /dev/xxx</p><p>参数 功能</p><p>-b 块大小</p><p>-i 节点大写</p><p>-m 预留管理空间大小</p><p>例如：</p><p>debian:~#mkfs.ext3 /dev/sdb1</p><p>7、e2fsck命令</p><p>功能：磁盘检测</p><p>e2fsck /dev/hda1　检查/dev/hda1是否有文件系统错误，提示修复方式</p><p>e2fsck -p /dev/hda1　检查/dev/hda1是否有错误，如果有则自动修复</p><p>e2fsck -y /dev/hda1　检查错误，所有提问均于yes方式执行</p><p>e2fsck -c /dev/hda1　检查磁盘是否有坏区</p><p>8、tune2fs命令</p><p>功能：调整ext2/ext3文件的参数</p><p>参数 功能</p><p>-l 查看文件系统信息</p><p>-c 设置强制自检的挂载次数</p><p>-i 设置强制自检的间隔时间，单位天</p><p>-m 保留块的百分比</p><p>-j 将ext2文件系统转换成ext3格式</p><p>Sarge:~# tune2fs -l /dev/sda1</p><p>9、dd命令</p><p>功能：功能：把指定的输入文件拷贝到指定的输出文件中，并且在拷贝过程中可以进行格式转换。</p><p>跟DOS下的diskcopy命令的作用类似。</p><p>dd if=/dev/fd0 of=floppy.img　将软盘的内容复制成一个镜像</p><p>dd if=floppy.img of=/dev/fd0　将一个镜像的内容复制到软盘，做驱动盘的时候经常用。</p><p>用户和组相关命令<br>1、groupadd命令</p><p>功能：添加组</p><p>groupadd test1 添加test1组</p><p>groupadd -g 1111 test2 添加test2组，组id为1111</p><p>2、useradd命令</p><p>功能：添加用户</p><p>useradd user1 添加用户user1，home为/home/user1，组为user1</p><p>useradd -g test1 -m -d /home/test1 test1<br>添加用户test1，home为/home/test1，组为test1</p><p>user list　显示已登陆的用户列表</p><p>3、passwd命令</p><p>功能：更改用户密码</p><p>passwd user1　修改用户user1的密码</p><p>passwd -d root　将root用户的密码删除</p><p>4、userdel命令</p><p>功能：删除用户</p><p>userdel user1　删除user1用户</p><p>5、chown命令</p><p>功能：改变文件或目录的所有者</p><p>chown user1 /dir　将/dir目录设置为user1所有</p><p>chown -R user1.user1<br>/dir　将/dir目录下所有文件和目录，设置为user1所有,组为user1。-R递归到下面的每个文件和目录</p><p>6、chgrp命令</p><p>功能：改变文件或目录的所有组</p><p>chgrp user1 /dir　将/dir目录设置为user1所有</p><p>7、chmod命令</p><p>功能：改变用户的权限</p><p>chmod a+x file　将file文件设置为可执行，脚本类文件一定要这样设置一个，否则得用bash file才能执行</p><p>chmod 666 file　将文件file设置为可读写</p><p>chmod 750 file 将文件file设置为，所有者为完全权限，同组可以读和执行，其他无权限</p><p>8、id命令</p><p>功能：显示用户的信息，包括uid、gid等</p><p>Sarge:~# id zhoulj</p><p>uid=500(zhoulj) gid=500(zhoulj) groups=500(zhoulj)</p><p>9、finger命令</p><p>功能：显示用的信息</p><p>注意：debian下没有该命令。</p><p>Sarge:~# finger zhoulj</p><p>Login: zhoulj Name:</p><p>Directory: /home/zhoulj Shell: /bin/bash</p><p>On since Sun May 21 07:59 (CST) on pts/0 from 192.168.1.4</p><p>No mail.</p><p>No Plan.</p><p>压缩命令<br>1、gzip格式命令</p><p>功能：压缩文件，gz格式的</p><p>注意：生成的文件会把源文件覆盖</p><p>gzip -v 压缩文件，并且显示进度</p><p>-d 解压缩</p><p>gnuzip -f 解压缩</p><p>例如：</p><p>Sarge:~# gzip a.sh</p><p>Sarge:~#ll</p><p>-rwxr-xr-x 1 root root 71 12月 18 21:08 a.sh.gz</p><p>Sarge:~# gzip -d a.sh.gz</p><p>Sarge:~#ll</p><p>-rwxr-xr-x 1 root root 48 12月 18 21:08 a.sh</p><p>2、zip格式命令</p><p>功能：压缩和解压缩zip命令</p><p>zip</p><p>unzip</p><p>例如：</p><p>Sarge:~# zip a.sh.zip a.sh</p><p>adding: a.sh (stored 0%)</p><p>Sarge:~# ll</p><p>-rw-r–r– 1 root root 188 5月 21 10:37 a.sh.zip</p><p>Sarge:~# unzip a.sh.zip</p><p>Archive: a.sh.zip</p><p>replace a.sh? [y]es, [n]o, [A]ll, [N]one, [r]ename: r</p><p>new name: a1.sh</p><p>extracting: a1.sh</p><p>Sarge:~ # ll</p><p>-rwxr-xr-x 1 root root 48 12月 18 21:08 a1.sh</p><p>3、bzip2根式命令</p><p>功能：bzip2格式压缩命令，</p><p>注意：生成的文件会把源文件覆盖</p><p>bzip2</p><p>bunzip2</p><p>例如：</p><p>Sarge:~ # bzip2 a.sh</p><p>Sarge:~# ll</p><p>-rwxr-xr-x 1 root root 85 12月 18 21:08 a.sh.bz2</p><p>Sarge:~ # bunzip2 a.sh.bz2</p><p>Sarge:~# ll</p><p>-rwxr-xr-x 1 root root 48 12月 18 21:08 a.sh</p><p>4、tar命令</p><p>功能：归档、压缩等，比较重要，会经常使用。</p><p>-cvf 压缩文件或目录</p><p>-xvf 解压缩文件或目录</p><p>-zcvf 压缩文件或，格式tar.gz</p><p>-zxvf 解压缩文件或，格式tar.gz</p><p>-zcvf 压缩文件或，格式tgz</p><p>-zxvf 解压缩文件或，格式tgz</p><p>举例:</p><p>Sarge:~ # tar cvf abc.tar *.sh</p><p>Sarge:~# tar xvf abc.tar</p><p>Sarge:~# tar czvf abc.tar.gz *.sh</p><p>Sarge:~# ll</p><p>-rw-r–r– 1 root root 20480 5月 21 10:50 abc.tar</p><p>-rw-r–r– 1 root root 1223 5月 21 10:53 abc.tar.gz</p><p>Sarge:~# tar xzvf abc.tar.gz</p><p>网络相关命令<br>1、ifconfig命令</p><p>功能：显示修改网卡的信息</p><p>ifconfig 显示网络信息</p><p>ifconfig eth0 显示eth0网络信息</p><p>修改网络信息：</p><p>ifconfig eth0 192.168.1.1 netmask 255.255.255.0<br>设置网卡1的地址192.168.1.1，掩码为255.255.255.0</p><p>ifconfig eth0:1 192.168.1.2　 捆绑网卡1的第二个地址为192.168.1.2</p><p>ifconfig eth0:x 192.168.1.n　 捆绑网卡1的第n个地址为192.168.1.n</p><p>例如：</p><p>Sarge:~# ifconfig eth0:1 192.168.1.11</p><p>Sarge:~ # ifconfig</p><p>eth0 Link encap:Ethernet HWaddr 00:0C:29:06:9C:24</p><pre><code>  inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1  RX packets:4220 errors:0 dropped:0 overruns:0 frame:0  TX packets:3586 errors:0 dropped:0 overruns:0 carrier:0  collisions:0 txqueuelen:1000  RX bytes:342493 (334.4 Kb)  TX bytes:469020 (458.0 Kb)  Interrupt:9 Base address:0x1400</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>eth0:1 Link encap:Ethernet HWaddr 00:0C:29:06:9C:24</p><pre><code>  inet addr:192.168.1.11  Bcast:192.168.1.255  Mask:255.255.255.0  UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1  Interrupt:9 Base address:0x1400</code></pre><p>1<br>2<br>3<br>4<br>5<br>2、route命令</p><p>功能：显示当前路由设置情况</p><p>route 显示当前路由设置情况，比较慢一般不用。</p><p>route add -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254 添加静态路由</p><p>route del -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254 添加静态路由</p><p>route add default gw 192.168.1.1 metric1　 设置192.168.1.1为默认的路由</p><p>route del default　 将默认的路由删除</p><p>举例：</p><p>Sarge:~# route add -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254</p><p>Sarge:~# netstat -nr</p><p>Kernel IP routing table</p><p>Destination Gateway Genmask Flags MSS Window<br>irtt Iface</p><p>192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0</p><p>10.0.0.0 192.168.1.254 255.255.0.0 UG 0 0 0 eth0</p><p>169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0</p><p>0.0.0.0 192.168.1.254 0.0.0.0 UG 0 0 0 eth0</p><p>Sarge:~# route del -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254</p><p>Sarge:~# netstat -nr</p><p>Kernel IP routing table</p><p>Destination Gateway Genmask Flags MSS Window<br>irtt Iface</p><p>192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0</p><p>169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0</p><p>0.0.0.0 192.168.1.254 0.0.0.0 UG 0 0 0 eth0</p><p>3、netstat命令</p><p>功能：显示网络状态</p><p>netstat -an 查看网络端口信息</p><p>netstat -nr 查看路由表信息，比route快多了，</p><p>4、启动网络的命令</p><p>redhat族的命令:</p><p>/etc/init.d/network</p><p>debian命令:</p><p>/etc/init.d/networking</p><p>例如：</p><p>/etc/init.d/network stop 停止网络，</p><p>/etc/init.d/network start 启动网络，</p><p>5、手工修改网络配置</p><p>(1)、debian系统</p><p>配置文件位置为：/etc/network/interfaces</p><p>Sarge:~# The loopback network interface</p><p>auto lo</p><p>iface lo inet loopback</p><p>Sarge:~# The primary network interface</p><p>auto eth0 eth1</p><p>iface eth0 inet static</p><pre><code>address 10.4.5.6netmask 255.255.255.0network 10.4.5.0broadcast 10.4.5.255</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>iface eth1 inet static</p><pre><code>address 219.25.5.60netmask 255.255.255.192network 219.25.5.0broadcast 219.25.5.63gateway 219.25.5.30</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>修改后保存配置后，运行</p><p>/etc/init.d/networking restart</p><p>网络配置就改变了</p><p>(2)、redhat系统</p><p>配置文件位置为：/etc/sysconfig/network-scripts/ifcfg-eth0</p><p>DEVICE=eth0</p><p>BOOTPROTO=static</p><p>BROADCAST=192.168.1.255</p><p>IPADDR=192.168.1.5</p><p>NETMASK=255.255.255.0</p><p>NETWORK=192.168.1.0</p><p>GATEWAY=192.168.1.254</p><p>ONBOOT=yes</p><p>TYPE=Ethernet</p><p>修改后保存配置后，运行</p><p>/etc/init.d/network restart</p><p>或者</p><p>service network restart</p><p>网络配置就改变了。</p><p>默认DNS的文件的位置为：/etc/resolv.conf</p><p>Sarge:~#cat /etc/resolv.conf</p><p>search test.com.cn</p><p>nameserver 192.168.1.11</p><p>6、网络排错</p><p>(1)、ping命令</p><p>功能：不说了，不知道就用干这行了。</p><p>ping</p><p>(2)、traceroute命令</p><p>功能：路由跟踪</p><p>traceroute</p><p>traceroute 207.68.173.7</p><p>(3)、nslookup命令</p><p>功能：域名解析排错</p><p>例如：</p><p>$ nslookup</p><p>Note: nslookup is deprecated and may be removed from future releases.</p><p>Consider using the dig’ orhost’ programs instead. Run nslookup<br>with</p><p>the `-sil[ent]’ option to prevent this message from appearing.</p><p>Server: 192.168.1.11</p><p>Address: 192.168.1.11#53</p><p>Non-authoritative answer:</p><p>Name:</p><p>Address: 202.118.66.66</p><p>server 202.118.66.6</p><p>Default server: 202.118.66.6</p><p>Address: 202.118.66.6#53</p><p>Server: 202.118.66.6</p><p>Address: 202.118.66.6#53</p><p>Non-authoritative answer: canonical name =</p><p>Name:</p><p>Address: 202.108.22.5</p><p>其他命令<br>1、ssh命令</p><p>功能：远程登陆到其他UNIX主机</p><p>ssh -l user1 192.168.1.2 使用用户名user1登陆到192.168.1.2</p><p>ssh</p><p>使用用户名user1登陆到192.168.1.2</p><p>2、scp命令</p><p>功能：安全copy</p><p>例如：</p><p>scp abc.tar.gz</p><p>:~ 将本地的abc.tar.gz 复制到 192.168.1.5的user1用户的根(/home/user1)下。</p><p>3、telnet命令</p><p>功能：登陆到远程主机</p><p>例如：</p><p>telnet 192.168.1.5</p><p>3、find</p><p>   find pathname -options [-print -exec -ok]<br>   让我们来看看该命令的参数：<br>   pathname find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。<br>   -print find命令将匹配的文件输出到标准输出。<br>   -exec find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {} ;，注意{}和\；之间的空格，同时两个{}之间没有空格,<br>   注意一定有分号结尾。<br>   0) -ok 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行<br>   find . -name “datafile” -ctime -1 -exec ls -l {} ; 找到文件名为datafile<em>, 同时创建实际为1天之内的文件, 然后显示他们的明细.<br>   find . -name “datafile” -ctime -1 -exec rm -f {} ; 找到文件名为datafile</em>, 同时创建实际为1天之内的文件, 然后删除他们.</p><p>   find . -name “datafile” -ctime -1 -ok ls -l {} ; 这两个例子和上面的唯一区别就是-ok会在每个文件被执行命令时提示用户, 更加安全.<br>   find . -name “datafile” -ctime -1 -ok rm -f {} ; </p><p>   1) find . -name   基于文件名查找,但是文件名的大小写敏感.<br>   find . -name “datafile*”</p><p>   2) find . -iname  基于文件名查找,但是文件名的大小写不敏感.<br>   find . -iname “datafile*”</p><p>   3) find . -maxdepth 2 -name fred 找出文件名为fred,其中find搜索的目录深度为2(距当前目录), 其中当前目录被视为第一层.</p><p>   4) find . -perm 644 -maxdepth 3 -name “datafile*”  (表示权限为644的, 搜索的目录深度为3, 名字为datafile*的文件)</p><p>   5) find . -path “./rw” -prune -o -name “datafile*” 列出所有不在./rw及其子目录下文件名为datafile<em>的文件。<br>   find . -path “./dir</em>“ 列出所有符合dir<em>的目录及其目录的文件.<br>   find . ( -path “./d1” -o -path “./d2” ) -prune -o -name “datafile</em>“ 列出所有不在./d1和d2及其子目录下文件名为datafile*的文件。</p><p>   6) find . -user ydev 找出所有属主用户为ydev的文件。<br>   find . ! -user ydev 找出所有属主用户不为ydev的文件， 注意!和-user之间的空格。</p><p>   7) find . -nouser    找出所有没有属主用户的文件，换句话就是，主用户可能已经被删除。</p><p>   8) find . -group ydev 找出所有属主用户组为ydev的文件。</p><p>   9) find . -nogroup    找出所有没有属主用户组的文件，换句话就是，主用户组可能已经被删除。</p><p>   10) find . -mtime -3[+3] 找出修改数据时间在3日之内[之外]的文件。<br>   find . -mmin  -3[+3] 找出修改数据时间在3分钟之内[之外]的文件。<br>   find . -atime -3[+3] 找出访问时间在3日之内[之外]的文件。<br>   find . -amin  -3[+3] 找出访问时间在3分钟之内[之外]的文件。<br>   find . -ctime -3[+3] 找出修改状态时间在3日之内[之外]的文件。<br>   find . -cmin  -3[+3] 找出修改状态时间在3分钟之内[之外]的文件。</p><p>   11) find . -newer eldest_file ! -newer newest_file 找出文件的更改时间 between eldest_file and newest_file。<br>   find . -newer file     找出所有比file的更改时间更新的文件<br>   find . ! -newer file 找出所有比file的更改时间更老的文件</p><p>   12) find . -type d    找出文件类型为目录的文件。<br>   find . ! -type d  找出文件类型为非目录的文件。<br>   b - 块设备文件。<br>   d - 目录。<br>   c - 字符设备文件。<br>   p - 管道文件。<br>   l - 符号链接文件。<br>   f - 普通文件。</p><p>   13) find . -size [+/-]100[c/k/M/G] 表示文件的长度为等于[大于/小于]100块[字节/k/M/G]的文件。</p><p>   14) find . -empty 查找所有的空文件或者空目录.</p><p>   15) find . -type f | xargs grep “ABC”<br>   使用xargs和-exec的区别是, -exec可能会为每个搜索出的file,启动一个新的进程执行-exec的操作, 而xargs都是在一个进程内完成, 效率更高.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo命令</title>
    <link href="/2020/04/17/hexo%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/04/17/hexo%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><pre><code>$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre><code>$ hexo new &quot;post title with whitespace&quot;</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre><code>hexo new page --path about/me &quot;About me&quot;</code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre><code>hexo new page --path about/me</code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><pre><code>$ hexo generate</code></pre><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><pre><code>$ hexo g</code></pre><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><pre><code>$ hexo publish [layout] &lt;filename&gt;</code></pre><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><pre><code>$ hexo server</code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><pre><code>$ hexo deploy</code></pre><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><pre><code>$ hexo d</code></pre><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><pre><code>$ hexo render &lt;file1&gt; [file2] ...</code></pre><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><pre><code>$ hexo migrate &lt;type&gt;</code></pre><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration" target="_blank" rel="noopener">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><pre><code>$ hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><pre><code>$ hexo list &lt;type&gt;</code></pre><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><pre><code>$ hexo version</code></pre><p>显示 Hexo 版本。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><pre><code>$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><pre><code>$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new" target="_blank" rel="noopener">提交调试信息到 GitHub</a>。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><pre><code>$ hexo --silent</code></pre><p>隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><pre><code># 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><pre><code># 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><pre><code>$ hexo --draft</code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><pre><code>$ hexo --cwd /path/to/cwd</code></pre><p>自定义当前工作目录（Current working directory）的路径。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最新(2020)virtualenv的一些命令</title>
    <link href="/2020/04/16/%E6%9C%80%E6%96%B0(2020)virtualenv%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/04/16/%E6%9C%80%E6%96%B0(2020)virtualenv%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="最新-2020-virtualenv的一些命令"><a href="#最新-2020-virtualenv的一些命令" class="headerlink" title="最新(2020)virtualenv的一些命令"></a>最新(2020)virtualenv的一些命令</h1><p>which python3 查看python目录</p><p><a href="http://www.wailian.work/album/xUiBn/?sort=date_desc&amp;pagev=1" target="_blank" rel="noopener">http://www.wailian.work/album/xUiBn/?sort=date_desc&amp;pagev=1</a></p><p>virtualenv venv2 -p python3 安装指定版本</p><p>source bin/active 进入虚拟环境(已经更改了入口,现已不适用)</p><h2 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h2><p>在Windows上 virtualenv 创建了batch file</p><pre><code>\env\Scripts\activate.bat</code></pre><p>启动脚本在脚本文件夹</p><pre><code>\path\to\env\Scripts\activate</code></pre><p>如:</p><pre><code>C:\Users\&#39;Username&#39;\venv\Scripts\activate.bat</code></pre><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>虚拟环境是一个包含二进制程序和 shell 脚本的目录。二进制程序包含执行脚本的 <em>python</em> 和安装其它模块的 <em>pip</em>。脚本包括激活环境的脚本，<a href="https://wiki.archlinux.org/index.php/Bash" target="_blank" rel="noopener">bash</a>, csh 和<a href="https://wiki.archlinux.org/index.php/Fish" target="_blank" rel="noopener">fish</a> 个有一个。这个虚拟环境模拟了一个完整的 <a href="https://wiki.archlinux.org/index.php/Python" target="_blank" rel="noopener">Python</a> 执行环境和需要的模块，将程序运行的环境与系统其它部分隔离开来。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://wiki.archlinux.org/index.php/Python" target="_blank" rel="noopener">Python</a> 从 3.3 开始包含了 <em>venv</em> 程序，无需单独安装。 如果使用的是老版本的 Python, 需要额外<a href="https://wiki.archlinux.org/index.php/安装" target="_blank" rel="noopener">安装</a> <em>virtualenv</em>。</p><ul><li>Python 3.3+: <a href="https://www.archlinux.org/packages/?name=python" target="_blank" rel="noopener">python</a></li><li>Python 3: <a href="https://www.archlinux.org/packages/?name=python-virtualenv" target="_blank" rel="noopener">python-virtualenv</a></li><li>Python 2: <a href="https://www.archlinux.org/packages/?name=python2-virtualenv" target="_blank" rel="noopener">python2-virtualenv</a></li></ul><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>使用<em>venv</em> 或 <em>virtualenv</em> 在项目目录创建虚拟环境，请将 venv 目录加入版本控制系统，这样只要执行 <code>pip freeze</code> 就可以重建虚拟环境。</p><h4 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h4><p><strong>Note:</strong> 此方法代替了从 <a href="https://www.archlinux.org/packages/?name=python" target="_blank" rel="noopener">python</a> 3.6 就不建议使用的 <em>pyvenv</em>。</p><p><a href="https://www.archlinux.org/packages/?name=python" target="_blank" rel="noopener">python</a> 软件包从 3.3 开始就提供了此工具:</p><pre><code>$ python -m venv venv</code></pre><h4 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h4><p>Python 3 使用 <a href="https://www.archlinux.org/packages/?name=python-virtualenv" target="_blank" rel="noopener">python-virtualenv</a> 提供的 <em>virtualenv</em>。</p><pre><code>$ virtualenv venv</code></pre><p>Python 2 使用 <a href="https://www.archlinux.org/packages/?name=python2-virtualenv" target="_blank" rel="noopener">python2-virtualenv</a> 提供的 <em>virtualenv2</em>。</p><pre><code>$ virtualenv2 venv</code></pre><h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>要激活虚拟环境(这里假设使用的是 bash):</p><pre><code>$ source venv/bin/activate(venv) $</code></pre><p>一旦进入虚拟环境，就可以通过 <em>pip</em> 安装软件包，并正常执行脚本。</p><p>要退出寻环境，执行 <code>bin/activate</code> 下的:</p><pre><code>(venv) $ deactivate</code></pre><h2 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h2><p>二进制的版本由使用的虚拟环境工具决定。使用 Python 2 工具创建的虚拟环境中，<em>python</em> 命令指向 <code>bin/python2.7</code>，<em>venv</em> 创建的环境中， python 指向 <code>bin/python3.6</code>.</p><p><em>venv</em> 和 <em>virtualenv</em> 差别在于 venv 默认使用系统的 Python 程序:</p><pre><code>$ ls -l venv/bin/python3.6lrwxrwxrwx 1 foo foo 7 Jun  3 19:57 venv/bin/python3.6 -&gt; /usr/bin/python3</code></pre><p>而 <em>virtualenv</em> 工具使用环境目录中的 Python 程序:</p><pre><code>$ ls -l virtualenv/bin/python3.6lrwxrwxrwx 1 foo foo 7 Jun  3 19:58 virtualenv/bin/python3.6 -&gt; python3</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python虚拟环境(创建激活操作删除-virtualenv、Pycharm、virtualenvwrapper、pipenv)</title>
    <link href="/2020/04/16/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83(%E5%88%9B%E5%BB%BA%E6%BF%80%E6%B4%BB%E6%93%8D%E4%BD%9C%E5%88%A0%E9%99%A4-virtualenv%E3%80%81Pycharm%E3%80%81virtualenvwrapper%E3%80%81pipenv)/"/>
    <url>/2020/04/16/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83(%E5%88%9B%E5%BB%BA%E6%BF%80%E6%B4%BB%E6%93%8D%E4%BD%9C%E5%88%A0%E9%99%A4-virtualenv%E3%80%81Pycharm%E3%80%81virtualenvwrapper%E3%80%81pipenv)/</url>
    
    <content type="html"><![CDATA[<h1 id="Python基础42-虚拟环境-创建-激活-操作-删除-virtualenv、Pycharm、virtualenvwrapper、pipenv"><a href="#Python基础42-虚拟环境-创建-激活-操作-删除-virtualenv、Pycharm、virtualenvwrapper、pipenv" class="headerlink" title="Python基础42-虚拟环境(创建/激活/操作/删除-virtualenv、Pycharm、virtualenvwrapper、pipenv)"></a>Python基础42-虚拟环境(创建/激活/操作/删除-virtualenv、Pycharm、virtualenvwrapper、pipenv)</h1><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><ul><li>一个独立的局部的 Python 环境</li><li>完全模拟系统全局 Python 环境的使用，如安装、卸载包到逻辑操作等</li></ul><h1 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h1><ul><li>让项目运行在一个独立的局部的 Python 环境中，使采用不同环境的项目互不干扰。</li></ul><h1 id="3-安装虚拟环境"><a href="#3-安装虚拟环境" class="headerlink" title="3 安装虚拟环境"></a>3 安装虚拟环境</h1><ul><li>virtualenv，就是一个三方包</li><li>安装命令，pip install virtualenv</li><li>使用文档，<a href="https://virtualenv.pypa.io/en/stable/userguide/" target="_blank" rel="noopener">https://virtualenv.pypa.io/en/stable/userguide/</a></li></ul><p>安装过程中，如果出现如下 error 信息是，可以尝试切换源重新下载</p><pre><code class="csharp">$ pip install virtualenv -i https://pypi.python.org/simple/                  Looking in indexes: https://pypi.python.org/simple/Collecting virtualenv  Downloading https://files.pythonhosted.org/packages/b6/30/96a02b2287098b23b875bc8c2f58071c35d2efe84f747b64d523721dc2b5/virtualenv-16.0.0-py2.py3-none-any.whl (1.9MB)    4% |█▌                              | 92kB 2.7kB/s eta 0:11:08Exception:Traceback (most recent call last): ....pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=&#39;files.pythonhosted.org&#39;, port=443): Read timed out.</code></pre><p>清华源，可以</p><pre><code class="cpp">$ pip install virtualenv -i https://pypi.tuna.tsinghua.edu.cn/simple/      Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple/Collecting virtualenv  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/ed/ea/e20b5cbebf45d3096e8138ab74eda139595d827677f38e9dd543e6015bdf/virtualenv-15.2.0-py2.py3-none-any.whl (2.6MB)    100% |████████████████████████████████| 2.6MB 4.1MB/sInstalling collected packages: virtualenvSuccessfully installed virtualenv-15.2.0</code></pre><h1 id="4-使用虚拟环境"><a href="#4-使用虚拟环境" class="headerlink" title="4 使用虚拟环境"></a>4 使用虚拟环境</h1><h2 id="4-1-创建一个局部的隔离的虚拟环境"><a href="#4-1-创建一个局部的隔离的虚拟环境" class="headerlink" title="4.1 创建一个局部的隔离的虚拟环境"></a>4.1 创建一个局部的隔离的虚拟环境</h2><h3 id="4-1-1-创建命令：virtualenv-虚拟环境名称"><a href="#4-1-1-创建命令：virtualenv-虚拟环境名称" class="headerlink" title="4.1.1 创建命令：virtualenv 虚拟环境名称"></a>4.1.1 创建命令：virtualenv 虚拟环境名称</h3><pre><code class="undefined">virtualenv ENV</code></pre><ul><li>cd 到存放虚拟环境的的地址</li><li>执行命令virtualenv ENV，创建名为ENV 的虚拟环境</li></ul><pre><code class="bash">% cd /Users/xxx/Desktop/testvirtuals                    % virtualenv virtual1                   Using base prefix &#39;/usr/local/Cellar/python3/3.6.4_1/Frameworks/Python.framework/Versions/3.6&#39;New python executable in /Users/xxx/Desktop/testvirtuals/virtual1/bin/python3.6Also creating executable in /Users/xxx/Desktop/testvirtuals/virtual1/bin/pythonInstalling setuptools, pip, wheel...done.</code></pre><p>创建虚拟环境结果</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-6999784eb34dd793.png?imageMogr2/auto-orient/strip|imageView2/2/w/818/format/webp</p><p>注意：</p><ul><li><code>Using base prefix</code> 使用的是3.6版本环境，原因是 virtualenv 安装位置就在3.6下，所以默认使用的是其安装位置版本的 Python 环境</li><li>虚拟环境文件包括：Python解析器，包管理工具(setuptools, pip, wheel)，三方包等</li><li>即使创建的 bin 脚本命令集含有 python 和 python3两个脚本，实际它们的版本都是3.6，这个防止使用者理解不足导致已为使用 python 命令时是使用 Python2.x 版本。</li></ul><pre><code class="jsx">% /Users/xxx/Desktop/testvirtuals/virtual1/bin/python3 --versionPython 3.6.4% /Users/xxx/Desktop/testvirtuals/virtual1/bin/python --versionPython 3.6.4</code></pre><h3 id="4-1-2-指定-Python-版本创建虚拟环境"><a href="#4-1-2-指定-Python-版本创建虚拟环境" class="headerlink" title="4.1.2 指定 Python 版本创建虚拟环境"></a>4.1.2 指定 Python 版本创建虚拟环境</h3><p>可选参数：-p<br> 指定 Python2.x 版本创建虚拟环境</p><pre><code class="bash">virtualenv -p /usr/local/bin/python2.7 testvirtual2</code></pre><p>执行效果</p><pre><code class="bash">$ virtualenv -p /usr/local/bin/python2.7 ENVRunning virtualenv with interpreter /usr/local/bin/python2.7New python executable in /Users/minyu_leung/Desktop/virtual2/ENV/bin/python2.7Also creating executable in /Users/minyu_leung/Desktop/virtual2/ENV/bin/pythonInstalling setuptools, pip, wheel...done.</code></pre><h3 id="4-1-3-是否继承系统三方库-system-site-packages"><a href="#4-1-3-是否继承系统三方库-system-site-packages" class="headerlink" title="4.1.3 是否继承系统三方库 --system-site-packages"></a>4.1.3 是否继承系统三方库 <code>--system-site-packages</code></h3><p>添加参数<code>--system-site-packages</code>，项目检索库的时候，也会到系统的三方库中找<br> 不添加时，默认只到虚拟环境中查找库</p><pre><code class="undefined">virtualenv --system-site-packages ENV</code></pre><h2 id="4-2-激活-退出-虚拟环境"><a href="#4-2-激活-退出-虚拟环境" class="headerlink" title="4.2 激活/退出 虚拟环境"></a>4.2 激活/退出 虚拟环境</h2><p>在 Mac 下，激活所创建的虚拟环境步骤：</p><ol><li>cd 到虚拟环境文件夹目录</li></ol><pre><code class="bash">cd /Users/xxx/Desktop/testvirtuals/virtual1</code></pre><ol><li>执行命令 source bin/activate，shell 会打印出已激活的虚拟环境名称</li></ol><pre><code class="bash">$ source bin/activate(virtual1)</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-f0e1aeda8aa76b6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/977/format/webp</p><p>带 source 命令</p><ol><li><p>验证当前确实在已激活的虚拟环境中，执行命令 pip –version 和 pip list</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-6cbe76da12ffc2e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1118/format/webp</p><p>每次打印后都会提示(virtual1)，所在环境是虚拟环境</p></li><li><p>退出虚拟环境，在激活的虚拟环境中，执行命令 deactivate</p></li></ol><pre><code class="ruby">$ deactivate</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-96810edb63e6c71e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1018/format/webp</p><p>注意，不用带 source 命令</p><ol><li><p>验证已经退出，执行命令 pip –version 和 pip list</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-acc089c067eaba88.png?imageMogr2/auto-orient/strip|imageView2/2/w/1020/format/webp</p><p>结果都是来自系统环境</p></li><li><p>注意：如果系统是 Windows 的话，则不需要带上 source 命令，直接 cd 进入Scripts脚本文件夹中，然后执行 activate 和 deactivate 脚本即可。与 Mac 不同的是，虚拟环境的 bin 目录下只有 activate 脚本，没有 deactivate 脚本。</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-d1b30e5a43c651cf.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/775/format/webp</p><p>Windows 下的虚拟环境 Scripts 文件夹文件目录</p></li></ol><p>![img](https:////upload-images.jianshu.io/upload_images/748014-a37973ef28926b56.png?imageMogr2/auto-orient/strip|imageView2/2/w/633/format/webp</p><p>Mac 虚拟环境 bin 目录文件</p><p><a href="https://virtualenv.pypa.io/en/stable/userguide/" target="_blank" rel="noopener">使用文档</a>中也有说 source 使用原因：</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-2bfe425e8159747b.png?imageMogr2/auto-orient/strip|imageView2/2/w/777/format/webp</p><h2 id="4-3-在激活状态下，操作"><a href="#4-3-在激活状态下，操作" class="headerlink" title="4.3 在激活状态下，操作"></a>4.3 在激活状态下，操作</h2><ol><li>操作三方块<br> pip install requests</li><li>执行 py 文件<br> python xx.py</li></ol><p>以上操作均作用在虚拟环境中。</p><h2 id="4-4-删除虚拟环境"><a href="#4-4-删除虚拟环境" class="headerlink" title="4.4 删除虚拟环境"></a>4.4 删除虚拟环境</h2><ul><li>直接删除虚拟环境所在目录即</li></ul><h2 id="4-5-项目交接"><a href="#4-5-项目交接" class="headerlink" title="4.5 项目交接"></a>4.5 项目交接</h2><p>场景：确保共享的项目能够在其他电脑上正常运行<br> 解决：</p><ol><li>方案一：</li></ol><ul><li>连同虚拟环境和项目一起拷贝给他人</li></ul><ol><li>方案二：</li></ol><ul><li>在虚拟环境中，冻结依赖需求文本</li><li>把项目和依赖需求文本给他人</li><li>他人在本地创建一个新的虚拟环境，并根据依赖需求文本安装相关库</li></ul><p><strong>技能点</strong>：</p><ul><li>虚拟环境的创建</li><li>虚拟环境的激活</li><li>操作虚拟环境</li><li>冻结项目需求文本 pip freeze &gt; requirements.txt</li><li>根据需求文本，安装项目依赖库 pip install -r requirements.txt （在激活的虚拟环境中）</li></ul><h1 id="5-Pycharm-中使用虚拟环境"><a href="#5-Pycharm-中使用虚拟环境" class="headerlink" title="5 Pycharm 中使用虚拟环境"></a>5 Pycharm 中使用虚拟环境</h1><ol><li><p>创建项目</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-96770a324e09b1c8.png?imageMogr2/auto-orient/strip|imageView2/2/w/779/format/webp</p></li><li><p>在创建项目时，使用虚拟环境</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-f386466e4e33fa57.png?imageMogr2/auto-orient/strip|imageView2/2/w/862/format/webp</p></li></ol><p>创建后，目录结构</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-4438a8e2c308b040.png?imageMogr2/auto-orient/strip|imageView2/2/w/593/format/webp</p><ol><li><p>在项目偏好设置里可以切换环境和安装需要的库</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-25d73f4640a84b5a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1001/format/webp</p></li></ol><p>总结：<br> IDE 让虚拟环境的使用更加方便，图形化创建和切换，包的管理等。让程序员更关注项目的开发而非各种命令的记忆。</p><h1 id="6-虚拟环境进阶使用"><a href="#6-虚拟环境进阶使用" class="headerlink" title="6 虚拟环境进阶使用"></a>6 虚拟环境进阶使用</h1><h2 id="6-1-集中式虚拟环境管理"><a href="#6-1-集中式虚拟环境管理" class="headerlink" title="6.1 集中式虚拟环境管理"></a>6.1 集中式虚拟环境管理</h2><p><a href="https://pypi.org/project/virtualenvwrapper/" target="_blank" rel="noopener">virtualenvwrapper</a><br> <a href="https://virtualenvwrapper.readthedocs.io/en/latest/" target="_blank" rel="noopener">使用文档</a></p><ol><li>通过virtualenvwrapper创建的虚拟环境都会统一存放到指定位置统一管理</li><li>方便在多个虚拟环境间切换</li><li>更加方便的去使用 virtualenv</li></ol><ul><li>快速创建虚拟环境并激活</li></ul><pre><code class="undefined">mkvirtualenv venv1</code></pre><ul><li>快速在多个虚拟环境中切换</li></ul><pre><code class="undefined">workon venv2</code></pre><ul><li>快速关闭虚拟环境</li></ul><pre><code class="undefined">deactivate</code></pre><ul><li>快速删除虚拟环境</li></ul><pre><code class="undefined">rmvirtualenv env1</code></pre><ul><li>查看所有创建的虚拟环境</li></ul><pre><code class="undefined">lsvirtualenv</code></pre><p><strong>弊端</strong></p><ul><li>只是对 virtualenv 的使用封装，包的安装及虚拟环境的操作依然是分离的。</li><li>并未具备对项目包的依赖管理及需求文本的生成操作封装</li></ul><h2 id="6-2-更加基于项目的虚拟环境管理"><a href="#6-2-更加基于项目的虚拟环境管理" class="headerlink" title="6.2 更加基于项目的虚拟环境管理"></a>6.2 更加基于项目的虚拟环境管理</h2><h3 id="6-2-1-pipenv-使用优点"><a href="#6-2-1-pipenv-使用优点" class="headerlink" title="6.2.1 pipenv 使用优点"></a>6.2.1 pipenv 使用优点</h3><ol><li>推荐使用：<a href="https://pypi.org/project/pipenv/" target="_blank" rel="noopener">pipenv</a>，是  pip + virtualenv 结合体，解决了virtualenvwrapper弊端</li><li>会自动帮你创建虚拟环境，以及安装三方库</li><li>会自动的记录你的项目依赖的所有三方库</li><li>使用 pipfile 和 pipfile.lock取代了 requirements.txt</li></ol><p><a href="https://pypi.org/project/pipenv/" target="_blank" rel="noopener">使用文档</a><br> <a href="https://pypi.org/project/pipenv/" target="_blank" rel="noopener">使用文档2</a></p><p>pipenv 命令使用一览</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-2a8f6aae311ed8f7.png?imageMogr2/auto-orient/strip|imageView2/2/w/1113/format/webp</p><blockquote><p>pipenv 命令都是参照项目中的 Pipfile 位置和内容操作的，类似 cocoapods 的 pod 命令参照podfile文件操作。</p></blockquote><h3 id="6-2-2-使用步骤"><a href="#6-2-2-使用步骤" class="headerlink" title="6.2.2 使用步骤"></a>6.2.2 使用步骤</h3><h3 id="6-2-2-1-创建虚拟环境"><a href="#6-2-2-1-创建虚拟环境" class="headerlink" title="6.2.2.1 创建虚拟环境"></a>6.2.2.1 创建虚拟环境</h3><pre><code class="bash">1. cd 到项目文件夹目录下2. 在该目录下执行命令pipenv --two # 指定参照Python版本或pipenv --three3. 查看相关信息查看位置：pipenv --where查看虚拟环境位置：pipenv --venv查看解析器信息：pipenv --py</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-d7b94c520db1c332.png?imageMogr2/auto-orient/strip|imageView2/2/w/885/format/webp</p><p>![img](https:////upload-images.jianshu.io/upload_images/748014-91582750ee430c67.png?imageMogr2/auto-orient/strip|imageView2/2/w/469/format/webp</p><h3 id="6-2-2-2-激活虚拟环境"><a href="#6-2-2-2-激活虚拟环境" class="headerlink" title="6.2.2.2 激活虚拟环境"></a>6.2.2.2 激活虚拟环境</h3><pre><code class="undefined">pipenv shell</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-6a4c448fb9c3d051.png?imageMogr2/auto-orient/strip|imageView2/2/w/1119/format/webp</p><h3 id="6-2-2-3-在激活状态下操作"><a href="#6-2-2-3-在激活状态下操作" class="headerlink" title="6.2.2.3 在激活状态下操作"></a>6.2.2.3 在激活状态下操作</h3><ol><li>执行 py 文件，python xx.py ，其中 python 指的是虚拟环境 Python版本</li><li>安装包</li></ol><pre><code class="undefined">pipenv install requests</code></pre><blockquote><p>注意：不要使用 pip install 命令，使用的话虽然可以在虚拟环境中安装对应的包，但是不会更新 PIPfile 和 PIPfile.lock</p></blockquote><blockquote><p>命令：pipenv install [三方库名]<br> 作用：<br> 一、检测当前项目对应的虚拟环境是否存在，不存在则创建。如果当前项目已经存在 Pipfile 和 Pipfile.lock 文件，则参照这两个文件内容创建虚拟环境并安装文件指定的三方库<br> 二、在虚拟环境中安装指定三方库，如果没有指定，则不安装<br> 三、在项目目录下，通过 Pipfile 和 Pipfile.lock 记录当下已经安装的三方库信息</p></blockquote><p>![img](https:////upload-images.jianshu.io/upload_images/748014-691e4b565fd095f3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1127/format/webp</p><ol><li>查看包的依赖结构</li></ol><pre><code class="undefined">pipenv graph</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-71f4e8995bf218ae.png?imageMogr2/auto-orient/strip|imageView2/2/w/1117/format/webp</p><ol><li>卸载包</li></ol><pre><code class="undefined">pipenv uninstall requests</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-255f64f0d028c0f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1117/format/webp</p><h3 id="6-2-2-4-退出虚拟环境"><a href="#6-2-2-4-退出虚拟环境" class="headerlink" title="6.2.2.4 退出虚拟环境"></a>6.2.2.4 退出虚拟环境</h3><pre><code class="bash">exit或直接关闭 shell 窗口</code></pre><h3 id="6-2-2-5-删除虚拟环境"><a href="#6-2-2-5-删除虚拟环境" class="headerlink" title="6.2.2.5 删除虚拟环境"></a>6.2.2.5 删除虚拟环境</h3><pre><code class="bash">先 cd 进入 Pipfile 文件目录位置pipenv --rm</code></pre><p>![img](https:////upload-images.jianshu.io/upload_images/748014-0bf378bb4f9a5356.png?imageMogr2/auto-orient/strip|imageView2/2/w/907/format/webp</p><h2 id="6-3-项目交接"><a href="#6-3-项目交接" class="headerlink" title="6.3 项目交接"></a>6.3 项目交接</h2><h3 id="6-3-1-上传项目时，应该包含的文件有？"><a href="#6-3-1-上传项目时，应该包含的文件有？" class="headerlink" title="6.3.1 上传项目时，应该包含的文件有？"></a>6.3.1 上传项目时，应该包含的文件有？</h3><p>应该包括文件有：</p><ol><li>包和模块源码</li><li>Pipfile 和 Pipfile.lock</li></ol><h3 id="6-3-2-拿到共享的项目后如何操作？"><a href="#6-3-2-拿到共享的项目后如何操作？" class="headerlink" title="6.3.2 拿到共享的项目后如何操作？"></a>6.3.2 拿到共享的项目后如何操作？</h3><p>操作步骤：</p><ol><li>cd 进入获取的项目文件夹目录内</li><li>检查项目是否具有Pipfile 和 Pipfile.lock 文件 （此处应该是必须有的，因为是执行上述分享操作的人给你的项目嘛♪(∇*)啦啦）</li><li>执行命令：</li></ol><pre><code class="undefined">pipenv install</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>爬图片素材</title>
    <link href="/2020/04/01/%E7%88%AC%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/"/>
    <url>/2020/04/01/%E7%88%AC%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/</url>
    
    <content type="html"><![CDATA[<pre><code>import requestsimport reimport osimport urllibheaders={&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#39;}response=requests.get(&#39;https://www.vmgirls.com/12985.html&#39;,headers=headers)# print(response.request.headers)html=response.text# 文件夹dir_name=re.findall(&#39;&lt;h1 class=&quot;post-title h3&quot;&gt;(.*?)&lt;/h1&gt;&#39;,html)[-1]if not os.path.exists(dir_name):    os.mkdir(dir_name)urls=re.findall(&#39;&lt;a href=&quot;(.*?)&quot; alt=&quot;.*?&quot; title=&quot;.*?&quot;&gt;&#39;,html)print(urls)for url in urls:    file_name=url.split(&#39;/&#39;)[-1]    response=requests.get(url,headers=headers)    with open(dir_name+&#39;/&#39;+file_name,&#39;wb&#39;)as f:        f.write(response.content)</code></pre><p><img src="9F2A3DC5A9D149FE8277BAB068E2205C" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python中的正则表达式</title>
    <link href="/2020/03/30/Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/03/30/Python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="元字符和语法"><a href="#元字符和语法" class="headerlink" title="元字符和语法"></a>元字符和语法</h1><table><thead><tr><th align="center">实例</th><th align="center">匹配串</th></tr></thead><tbody><tr><td align="center">a.c</td><td align="center">abc</td></tr><tr><td align="center">a\.c</td><td align="center">a.c</td></tr><tr><td align="center">a[jq]k</td><td align="center">ajk&amp;aqk</td></tr><tr><td align="center">a\dc</td><td align="center">a1c</td></tr><tr><td align="center">a\Dc</td><td align="center">abc</td></tr><tr><td align="center">a\s</td><td align="center">a s</td></tr><tr><td align="center">a*</td><td align="center">a&amp;aaaaaaaa….</td></tr><tr><td align="center">a+</td><td align="center">aa&amp;aaaa…</td></tr><tr><td align="center">a?</td><td align="center">前一个字符0&amp;1次</td></tr><tr><td align="center">a{m}</td><td align="center">a后m个a</td></tr><tr><td align="center">{mn}</td><td align="center">m到n个前一字符</td></tr><tr><td align="center">^</td><td align="center">匹配每一行的开头</td></tr><tr><td align="center">$</td><td align="center">匹配每一行的末尾</td></tr><tr><td align="center">\A&amp;\Z</td><td align="center">仅匹配开头&amp;结尾</td></tr><tr><td align="center">## 逻辑与分组</td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">…..</th><th align="center">…….</th></tr></thead><tbody><tr><td align="center">\</td><td align="center">左右任意匹配一个（从左到右）</td></tr><tr><td align="center">a(12|34)c</td><td align="center">a34c</td></tr><tr><td align="center">(?#)</td><td align="center">忽略#后</td></tr><tr><td align="center">(?!=…)</td><td align="center">后面不是..</td></tr><tr><td align="center">(?&lt;=…)</td><td align="center">之前是…</td></tr></tbody></table><h2 id="烦人的反斜杠"><a href="#烦人的反斜杠" class="headerlink" title="烦人的反斜杠"></a>烦人的反斜杠</h2><p>原生字符串“ ”直观的解决了问题</p><h2 id="RE模块"><a href="#RE模块" class="headerlink" title="RE模块"></a>RE模块</h2><pre><code># encoding: UTF-8import re# 将正则表达式编译成Pattern对象pattern = re.compile(r&#39;hello&#39;)# 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回Nonematch = pattern.match(&#39;hello world!&#39;)if match:    # 使用Match获得分组信息    print match.group()### 输出 #### hello</code></pre><h3 id="re-compile-strPattern-flag"><a href="#re-compile-strPattern-flag" class="headerlink" title="re.compile(strPattern[, flag]):"></a>re.compile(strPattern[, flag]):</h3><p>这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。 第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。<br>可选值有：</p><ul><li>re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）</li><li>M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）</li><li>S(DOTALL): 点任意匹配模式，改变’.’的行为</li><li>L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定</li><li>U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性</li><li>X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：</li></ul><pre><code>a = re.compile(r&quot;&quot;&quot;\d +  # the integral part                   \.    # the decimal point                   \d *  # some fractional digits&quot;&quot;&quot;, re.X)b = re.compile(r&quot;\d+\.\d*&quot;)</code></pre><h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p><p><strong>属性</strong>：</p><ul><li><strong>string</strong>: 匹配时使用的文本。</li><li><strong>re</strong>: 匹配时使用的Pattern对象。</li><li><strong>pos</strong>: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</li><li><strong>endpos</strong>: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</li><li><strong>lastindex</strong>: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。</li><li><strong>lastgroup</strong>: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。</li></ul><p><strong>方法</strong>：</p><ul><li><p><strong>group</strong>([group1, …]):<br>获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。</p></li><li><p><strong>groups([default])</strong>:<br>以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。</p></li><li><p><strong>groupdict</strong>([default]):<br>返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。</p></li><li><p><strong>start([group])</strong>:<br>返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。</p></li><li><p><strong>end([group])</strong>:<br>返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。</p></li><li><p><strong>span([group])</strong>:<br>返回(start(group), end(group))。</p></li><li><p><strong>expand</strong>(template):<br>将匹配到的分组代入template中然后返回。template中可以使用\id或\g<id>、\g<name>引用分组，但不能使用编号0。\id与\g<id>是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符’0’，只能使用\g&lt;1&gt;0。</p></li></ul><h4 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h4><p>Pattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。</p><pre><code>import rep = re.compile(r&#39;(\w+) (\w+)(?P&lt;sign&gt;.*)&#39;, re.DOTALL)print &quot;p.pattern:&quot;, p.patternprint &quot;p.flags:&quot;, p.flagsprint &quot;p.groups:&quot;, p.groupsprint &quot;p.groupindex:&quot;, p.groupindex### output #### p.pattern: (\w+) (\w+)(?P&lt;sign&gt;.*)# p.flags: 16# p.groups: 3# p.groupindex: {&#39;sign&#39;: 3}</code></pre><p>以上就是Python对于正则表达式的支持 qwq !!</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python环境变量升级</title>
    <link href="/2020/03/27/python%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8D%87%E7%BA%A7/"/>
    <url>/2020/03/27/python%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8D%87%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>默认安装路径：C:\python35</code></pre><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>【在第二个内容框中找到 变量名为Path 的一行，双击<br> Python安装目录追加到变值值中，用 ； 分割</p><p> 如：原来的值;C:\python35，切记前面有分号</p><p>(备注：默认安装时会自动添加环境变量)</p><h1 id="要临时设置环境变量"><a href="#要临时设置环境变量" class="headerlink" title="要临时设置环境变量"></a>要临时设置环境变量</h1><p> 打开命令提示符并使用 set 命令：</p><pre><code>C:\&gt;set PATH=C:\Program Files\Python 3.8;%PATH%C:\&gt;set PYTHONPATH=%PYTHONPATH%;C:\My_python_libC:\&gt;python要永久修改默认环境变量，请单击“开始”并搜索“编辑环境变量”，或打开“系统属性” Advanced system settings ，然后单击 Environment Variables 按钮。在此对话框中，您可以添加或修改用户和系统变量。要更改系统变量，您需要对计算机进行无限制访问（即管理员权限）。</code></pre><p>由该控制台启动的任何应用程序都继承设这些设置。</p><h1 id="要永久修改默认环境变量"><a href="#要永久修改默认环境变量" class="headerlink" title="要永久修改默认环境变量"></a>要永久修改默认环境变量</h1><p>  单击“开始”并搜索“编辑环境变量”，或打开“系统属性” Advanced system settings ，然后单击 Environment Variables 按钮。在此对话框中，您可以添加或修改用户和系统变量。要更改系统变量，您需要对计算机进行无限制访问（即管理员权限）。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Windows会将用户变量串联的系统变量 之后 ，这可能会在修改 PATH 时导致意外结果。<br>PYTHONPATH 变量被Python 2和Python 3的所有版本使用，因此除非它只包含与所有已安装的Python版本兼容的代码，否则不要永久配置此变量。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>virtualenv的安装</title>
    <link href="/2020/03/27/virtualenv%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2020/03/27/virtualenv%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>使各应用有“独立”的Python运行环境</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>$ pip3 install virtualen</p><h1 id="开始项目"><a href="#开始项目" class="headerlink" title="开始项目"></a>开始项目</h1><h2 id="第一步（创建目录"><a href="#第一步（创建目录" class="headerlink" title="第一步（创建目录)"></a>第一步（创建目录)</h2><p>mkdir myproject<br>cd myproject/</p><h2 id="第二步（创建一个独立的Python运行环境，命名为venv：）"><a href="#第二步（创建一个独立的Python运行环境，命名为venv：）" class="headerlink" title="第二步（创建一个独立的Python运行环境，命名为venv：）"></a>第二步（创建一个独立的Python运行环境，命名为venv：）</h2><pre><code>Mac:myproject michael$ virtualenv --no-site-packages venvUsing base prefix &#39;/usr/local/.../Python.framework/Versions/3.4&#39;New python executable in venv/bin/python3.4Also creating executable in venv/bin/pythonInstalling setuptools, pip, wheel...done.</code></pre><p>命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数–no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。</p><p>新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境，可以用source进入该环境：</p><pre><code>Mac:myproject michael$ source venv/bin/activate(venv)Mac:myproject michael$</code></pre><p>有个(venv)前缀，表示当前环境是一个名为venv的Python环境。</p><p>在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响。也就是说，venv环境是专门针对myproject这个应用创建的。</p><p>退出当前的venv环境，使用deactivate命令：</p><pre><code>(venv)Mac:myproject michael$ deactivate Mac:myproject michael$</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络</title>
    <link href="/2020/03/26/%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/03/26/%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h1><p>应用层<br>表示层<br>会话层<br>传输层<br>网络层<br>数据链路层<br>物理层</p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="tcp-ip"><a href="#tcp-ip" class="headerlink" title="tcp ip"></a>tcp ip</h2><p>TCP/IP协议涵盖了OSI参考模型的第三层、第四层，即网络层、传输层。TCP/IP也不是只有TCP + IP这两种协议，它是协议栈的统称，它还包括 ARP，ICMP，IGMP，UDP，以及让域名访问成为可能的DNS，以及电脑/手机可以自动获取IP地址的DHCP。当然还有形形色色的应用层的协议如 HTTP / SMTP / FTP 等。</p><p>《TCP/IP协议》详解卷一，是一本很好的教材，一条消息竟然双向耗费9个包，仅仅是调用一次connect（）建立连接，调用一次 send（），然后程序退出。</p><p>TCP建立连接<br>看TCP如何建立连接，建立连接需要三个包的交互，这个应该是connect()完成的。</p><p>TCP发送数据<br>然后看到自己的消息内容是一个包，对方没有数据，只有确认ACK，这是两个包，这个由 send () 触发。</p><p>TCP释放连接<br>然后系统自动退出，虽然我的程序没有调用什么函数，但是系统自动帮我调用了 close () 函数，于是又触发了TCP 关闭连接，这是四个包。</p><p>试用UDP socket 编写聊天程序，直接调用一个函数Sendto() 就可以了（用IP访问），抓包一看，一个消息就是一个包，对方也没有确认，UDP就是加上一个封装头就出去了，不需要建立连接，自然也无需关闭连接。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
